(window["cfWebpackJsonp"] = window["cfWebpackJsonp"] || []).push([["modeljs"],{

/***/ "../../libs/model.js/lib/allowed-values-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AllowedValuesRule = void 0;
var validation_rule_1 = __webpack_require__("../../libs/model.js/lib/validation-rule.js");
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var property_chain_1 = __webpack_require__("../../libs/model.js/lib/property-chain.js");
var AllowedValuesRule = /** @class */ (function (_super) {
    __extends(AllowedValuesRule, _super);
    /**
     * Creates a rule that validates whether a selected value or values is in a list of allowed values.
     * @param rootType The root type to bind the rule to
     * @param options The rule configuration options
     */
    function AllowedValuesRule(rootType, options) {
        var _this = this;
        // ensure the rule name is specified
        options.name = options.name || "AllowedValues";
        // ensure the error message is specified
        options.message = options.message || function () { return rootType.model.getResource("allowed-values"); };
        // convert property path sources into a source function
        var source;
        if (options.source instanceof property_1.Property || options.source instanceof property_chain_1.PropertyChain) {
            var sourcePath_1 = options.source;
            options.onChangeOf = [sourcePath_1];
            options.source = source = function () { return sourcePath_1.value(this); };
        }
        else
            source = options.source;
        // create the validation function
        options.isValid = function (prop, value) {
            if (options.ignoreValidation) {
                return true;
            }
            // return true if no value is currently selected
            if (!value) {
                return true;
            }
            // get the list of allowed values of the property for the given object
            var allowed = source.call(this);
            // ensure that the value or list of values is in the allowed values list (single and multi-select)
            if (value instanceof Array) {
                return value.every(function (item) { return allowed.indexOf(item) >= 0; });
            }
            else {
                return allowed.indexOf(value) >= 0;
            }
        };
        // call the base type constructor
        _this = _super.call(this, rootType, options) || this;
        // store the allowed values source
        _this.source = source;
        _this.ignoreValidation = !!options.ignoreValidation;
        _this.preventInvalidValues = !!options.preventInvalidValues;
        return _this;
    }
    AllowedValuesRule.prototype.values = function (obj) {
        return this.source.call(obj);
    };
    AllowedValuesRule.prototype.toString = function () {
        return this.property.containingType.fullName + "." + this.property.name + " allowed values";
    };
    return AllowedValuesRule;
}(validation_rule_1.ValidationRule));
exports.AllowedValuesRule = AllowedValuesRule;


/***/ }),

/***/ "../../libs/model.js/lib/calculated-property-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalculatedPropertyRule = void 0;
var rule_1 = __webpack_require__("../../libs/model.js/lib/rule.js");
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var observable_array_1 = __webpack_require__("../../libs/model.js/lib/observable-array.js");
var rule_invocation_type_1 = __webpack_require__("../../libs/model.js/lib/rule-invocation-type.js");
var calculationErrorDefault = null;
var CalculatedPropertyRule = /** @class */ (function (_super) {
    __extends(CalculatedPropertyRule, _super);
    function CalculatedPropertyRule(rootType, name, options) {
        var _this = this;
        var property;
        var defaultIfError = calculationErrorDefault;
        var calculateFn;
        if (!name) {
            name = options.name;
        }
        if (options) {
            if (options.property) {
                property = typeof options.property === "string" ? rootType.getProperty(options.property) : options.property;
                // indicate that the rule is responsible for returning the value of the calculated property
                options.returns = [property];
            }
            if (!name) {
                // Generate a reasonable default rule name if not specified
                name = options.name = (rootType.fullName + "." + (typeof property === "string" ? property : property.name) + ".Calculated");
            }
            if (options.hasOwnProperty("defaultIfError"))
                defaultIfError = options.defaultIfError;
            calculateFn = options.calculate;
        }
        // Call the base rule constructor
        _this = _super.call(this, rootType, name, options) || this;
        // Public read-only properties
        Object.defineProperty(_this, "property", { enumerable: true, value: property });
        // Public settable properties
        _this.defaultIfError = defaultIfError;
        _this.isDefaultValue = !!options.isDefaultValue;
        // Backing fields for properties
        if (calculateFn)
            Object.defineProperty(_this, "_calculateFn", { enumerable: false, value: calculateFn, writable: true });
        // register the rule with the target property
        _this.property.rules.push(_this);
        // mark the property as calculated if the rule runs on property access and is not a default value calculation
        if (!options.isDefaultValue && _this.invocationTypes & rule_invocation_type_1.RuleInvocationType.PropertyGet)
            _this.property.isCalculated = true;
        return _this;
    }
    CalculatedPropertyRule.prototype.register = function () {
        var _this = this;
        _super.prototype.register.call(this);
        if (this.isDefaultValue) {
            // Ensure that a default value rule will run if a calculation that it depends on is changed.
            // A property with a default value rule may have a persisted value, in which case it will
            // not run unless one of its predicates fires a change event. A calculation will not fire
            // a change event the first time it runs if it didn't previously have a value, which may
            // be the case for existing instances if the calculation is never accessed (ex: a hidden field).
            // So, in order to ensure that the default rule's calculated predicates fire a change event,
            // we must ensure that the calculation is accessed when the object is initialized.
            this.rootType.initExisting.subscribe(function (args) {
                // If the property is initialized (i.e. it has an initial persisted value),
                // run the calculation and throw away the result.
                var initialValue = args.entity.__fields__[_this.property.name];
                if (initialValue !== undefined) {
                    try {
                        _this.calculateFn.call(args.entity);
                    }
                    catch (e) {
                    }
                }
            });
        }
    };
    Object.defineProperty(CalculatedPropertyRule.prototype, "calculateFn", {
        get: function () {
            var calculateFn;
            // Convert string functions into compiled functions on first execution
            if (this._calculateFn.constructor === String) {
                // TODO: Calculation expression support
                var calculateExpr = this._calculateFn;
                var calculateCompiledFn = new Function("return " + calculateExpr + ";");
                calculateFn = this._calculateFn = calculateCompiledFn;
            }
            else {
                calculateFn = this._calculateFn;
            }
            return calculateFn;
        },
        enumerable: false,
        configurable: true
    });
    CalculatedPropertyRule.prototype.execute = function (obj) {
        // Calculate the new property value
        var newValue;
        if (this.defaultIfError === undefined) {
            newValue = this.calculateFn.call(obj);
        }
        else {
            try {
                newValue = this.calculateFn.call(obj);
            }
            catch (e) {
                newValue = this.defaultIfError;
            }
        }
        // Exit immediately if the calculated result was undefined
        if (newValue === undefined) {
            return;
        }
        // modify list properties to match the calculated value instead of overwriting the property
        if (this.property.isList) {
            var newList_1 = newValue;
            // ensure the initial calculation of the list does not raise change events
            // defaulting a list property should raise change events
            if (!this.isDefaultValue && !this.property.isInited(obj))
                property_1.Property$init(this.property, obj, newList_1);
            else {
                // compare the new list to the old one to see if changes were made
                var curList = this.property.value(obj);
                if (newList_1.length === curList.length) {
                    var noChanges = true;
                    for (var i = 0; i < newList_1.length; ++i) {
                        if (newList_1[i] !== curList[i]) {
                            noChanges = false;
                            break;
                        }
                    }
                    if (noChanges) {
                        return;
                    }
                }
                // update the current list so observers will receive the change events
                // events will not be raised if this is the initial calculation of the list
                curList.batchUpdate(function (array) {
                    observable_array_1.updateArray(array, newList_1);
                });
            }
        }
        else {
            // Otherwise, just set the property to the new value
            this.property.value(obj, newValue, { calculated: true });
        }
    };
    CalculatedPropertyRule.prototype.toString = function () {
        return "calculation of " + this.property.name;
    };
    return CalculatedPropertyRule;
}(rule_1.Rule));
exports.CalculatedPropertyRule = CalculatedPropertyRule;


/***/ }),

/***/ "../../libs/model.js/lib/condition-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConditionRule = void 0;
var rule_1 = __webpack_require__("../../libs/model.js/lib/rule.js");
var condition_type_1 = __webpack_require__("../../libs/model.js/lib/condition-type.js");
var ConditionRule = /** @class */ (function (_super) {
    __extends(ConditionRule, _super);
    /**
     * Creates a rule that asserts a condition based on a predicate
     * @param rootType The model type the rule is for
     * @param options The options for the rule, of type ConditionRuleOptions
     */
    function ConditionRule(rootType, options) {
        var _this = this;
        // automatically run the condition rule during initialization of new and existing instances
        options.onInit = true;
        // call the base rule constructor
        _this = _super.call(this, rootType, options.name, options) || this;
        // assertion function
        _this.assert = options.assert;
        // message
        _this.message = options.message;
        // condition type
        _this.conditionType = options.conditionType ? (typeof options.conditionType === "string" ?
            condition_type_1.ConditionType.get(options.conditionType) :
            options.conditionType) :
            rule_1.Rule$ensureConditionType(options.name, rootType, options.category || "Error");
        // properties
        _this.properties = options.properties;
        return _this;
    }
    // asserts the condition and adds or removes it from the model if necessary
    ConditionRule.prototype.execute = function (entity) {
        var assert;
        var message;
        if (this.assert) {
            // If an assert function is defined, then use it to determine whether to attach a condition
            assert = this.assert.call(entity);
            message = typeof this.message === "string" ? this.message : this.message.call(entity);
        }
        else if (this.message instanceof Function) {
            message = this.message.call(entity);
            assert = typeof message === "string" && message.trim().length > 0;
        }
        // create or remove the condition if necessary
        if (typeof assert !== "undefined") {
            // pass through "this" so it can add the source when the rule is constructed
            // Add the source to the condition instead of the condition type
            this.conditionType.when(this, assert, entity, message);
        }
    };
    // gets the string representation of the condition rule
    ConditionRule.prototype.toString = function () {
        return typeof this.message === "string" ? this.message : this.conditionType.message;
    };
    return ConditionRule;
}(rule_1.Rule));
exports.ConditionRule = ConditionRule;


/***/ }),

/***/ "../../libs/model.js/lib/condition-target.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ConditionTarget = void 0;
var format_error_1 = __webpack_require__("../../libs/model.js/lib/format-error.js");
/** Represents the association of a condition to a specific target entity. */
var ConditionTarget = /** @class */ (function () {
    /**
    * Creates the association of a condition to a specific target entity.
    * @param condition The condition the target is for.
    * @param target The target entity the condition is associated with.
    * @param properties The set of properties on the target entity the condition is related to.
    */
    function ConditionTarget(condition, target, properties) {
        this.condition = condition;
        this.target = target;
        this.properties = properties;
        // Attach the condition target to the target entity.
        if (this.condition.type !== format_error_1.FormatError.ConditionType) {
            target.meta.setCondition(this);
        }
    }
    return ConditionTarget;
}());
exports.ConditionTarget = ConditionTarget;


/***/ }),

/***/ "../../libs/model.js/lib/condition-type-set.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ConditionTypeSet = void 0;
var observable_array_1 = __webpack_require__("../../libs/model.js/lib/observable-array.js");
var allConditionTypeSets = {};
/** Groups condition types into a set in order to be notified conditions for these types change. */
var ConditionTypeSet = /** @class */ (function () {
    /**
    * Creates a set of condition types.
    * @param name The name of the set
    */
    function ConditionTypeSet(name) {
        if (allConditionTypeSets[name])
            throw new Error("A set with the name '" + name + "' has already been created.");
        this.name = name;
        this.types = observable_array_1.ObservableArray.create();
        this.conditions = observable_array_1.ObservableArray.create();
        allConditionTypeSets[name] = this;
    }
    /**
    * Gets all condition type sets that have been created.
    * @returns Array of all condition type sets.
    * */
    ConditionTypeSet.all = function () {
        var all = [];
        for (var type in allConditionTypeSets.keys) {
            all.push(allConditionTypeSets[type]);
        }
        return all;
    };
    /**
    * Gets the condition type set with the specified name.
    * @param name
    */
    ConditionTypeSet.get = function (name) {
        return allConditionTypeSets[name];
    };
    return ConditionTypeSet;
}());
exports.ConditionTypeSet = ConditionTypeSet;


/***/ }),

/***/ "../../libs/model.js/lib/condition-type.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionConditionType = exports.WarningConditionType = exports.ErrorConditionType = exports.ConditionType = void 0;
var condition_1 = __webpack_require__("../../libs/model.js/lib/condition.js");
var observable_array_1 = __webpack_require__("../../libs/model.js/lib/observable-array.js");
var allConditionTypes = {};
var ConditionType = /** @class */ (function () {
    /**
    * Creates a unique type of model condition.
    * @param code The unique condition type code.
    * @param category The category of the condition type, such as "Error", "Warning", or "Permission".
    * @param message The default message to use when the condition is present.
    * @param sets One or more sets the condition type belongs to.
    */
    function ConditionType(code, category, message, sets) {
        // Ensure unique condition type codes
        if (allConditionTypes[code])
            throw new Error("A condition type with the code \"" + code + "\" has already been created.");
        this.code = code;
        this.category = category;
        this.message = message;
        // this.rules = [];
        this.conditions = observable_array_1.ObservableArray.create();
        this.sets = observable_array_1.ObservableArray.ensureObservable(sets || []);
        // Register with the static dictionary of all condition types
        allConditionTypes[code] = this;
    }
    /**
    * Adds or removes a condition from the model for the specified target if necessary.
    * @param condition Whether or not the condition should be present
    * @param target The target instance
    * @param properties The properties to attach the condition to
    * @param message The condition message (or a function to generate the message)
    */
    ConditionType.prototype.when = function (source, condition, target, message) {
        // get the current condition if it exists
        var conditionTarget = target.meta.getCondition(this);
        // add the condition on the target if it does not exist yet
        if (condition) {
            // if the message is a function, invoke to get the actual message
            message = message instanceof Function ? message(target) : message;
            // create a new condition if one does not exist
            if (!conditionTarget) {
                return new condition_1.Condition(this, message, target, source, source.properties);
            }
            // replace the condition if the message has changed
            else if (message && message !== conditionTarget.condition.message) {
                // destroy the existing condition
                conditionTarget.condition.destroy();
                // create a new condition with the updated message
                return new condition_1.Condition(this, message, target, source, source.properties);
            }
            // otherwise, just return the existing condition
            else {
                return conditionTarget.condition;
            }
        }
        // Destroy the condition if it exists on the target and is no longer valid
        if (conditionTarget != null)
            conditionTarget.condition.destroy();
        // Return null to indicate that no condition was created
        return null;
    };
    /**
        * Gets all condition types that have been created.
        * @returns Array of all condition types.
        * */
    ConditionType.all = function () {
        var all = [];
        for (var type in allConditionTypes.keys) {
            all.push(allConditionTypes[type]);
        }
        return all;
    };
    /**
        * Returns the condition type with the given code, if it exists.
        * @param code The unique code of the condition type to find.
        */
    ConditionType.get = function (code) {
        return allConditionTypes[code];
    };
    ;
    return ConditionType;
}());
exports.ConditionType = ConditionType;
var ErrorConditionType = /** @class */ (function (_super) {
    __extends(ErrorConditionType, _super);
    function ErrorConditionType(code, message, sets) {
        return _super.call(this, code, "Error", message, sets) || this;
    }
    return ErrorConditionType;
}(ConditionType));
exports.ErrorConditionType = ErrorConditionType;
var WarningConditionType = /** @class */ (function (_super) {
    __extends(WarningConditionType, _super);
    function WarningConditionType(code, message, sets) {
        return _super.call(this, code, "Warning", message, sets) || this;
    }
    return WarningConditionType;
}(ConditionType));
exports.WarningConditionType = WarningConditionType;
var PermissionConditionType = /** @class */ (function (_super) {
    __extends(PermissionConditionType, _super);
    function PermissionConditionType(code, message, sets, isAllowed) {
        if (isAllowed === void 0) { isAllowed = true; }
        var _this = _super.call(this, code, "Warning", message, sets) || this;
        _this.isAllowed = !(isAllowed === false);
        return _this;
    }
    return PermissionConditionType;
}(ConditionType));
exports.PermissionConditionType = PermissionConditionType;


/***/ }),

/***/ "../../libs/model.js/lib/condition.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Condition = void 0;
var format_error_1 = __webpack_require__("../../libs/model.js/lib/format-error.js");
var condition_target_1 = __webpack_require__("../../libs/model.js/lib/condition-target.js");
var observable_array_1 = __webpack_require__("../../libs/model.js/lib/observable-array.js");
var Condition = /** @class */ (function () {
    /**
        * Creates a condition of a specific type associated with one or more entities in a model.
        * @param type The type of condition, which usually is an instance of a subclass like Error, Warning or Permission.
        * @param message The optional message to use for the condition, which will default to the condition type message if not specified.
        * @param target The root target entity the condition is associated with.
        * @param properties The set of property paths specifying which properties and entities the condition should be attached to.
        */
    function Condition(type, message, target, source, properties) {
        var _this = this;
        if (properties === void 0) { properties = []; }
        this.type = type;
        this._message = message || (type ? type.message : undefined);
        var targets = this.targets = observable_array_1.ObservableArray.create();
        this.source = source;
        // create targets if a root was specified
        if (target) {
            var _loop_1 = function (p) {
                var path = properties[p];
                var targetInfos = [];
                // build list of objects containing ConditionTarget information
                // we don't want to construct ConditionTargets as we're processing the path because we may not have gathered all targeted properties,
                // and the constructor triggers change on the entity meta's conditions list, which should be in a correct state before publishing the event
                path.each(target, function (entity, property) {
                    if (property !== path.lastProperty)
                        return;
                    // see if a target already exists for the current instance
                    var targetInfo = targetInfos.find(function (t) { return t.entity === entity; });
                    // create the condition target if it does not already exist
                    if (!targetInfo) {
                        targetInfo = { entity: entity, properties: [property] };
                        targetInfos.push(targetInfo);
                    }
                    // otherwise, just ensure it references the current step
                    else if (!targetInfo.properties.includes(property))
                        targetInfo.properties.push(property);
                });
                // construct the ConditionTargets here now that we've gathered all information
                targets.push.apply(targets, targetInfos.map(function (i) { return new condition_target_1.ConditionTarget(_this, i.entity, i.properties); }));
            };
            // process each property path to build up the condition sources
            for (var p = properties.length - 1; p >= 0; p--) {
                _loop_1(p);
            }
        }
        // raise events for the new condition
        if (type !== format_error_1.FormatError.ConditionType) {
            var conditionType = type;
            // raise events on condition targets
            for (var t = targets.length - 1; t >= 0; t--) {
                var conditionTarget = targets[t];
                // type events
                for (var objectType = conditionTarget.target.meta.type; objectType != null; objectType = objectType.baseType) {
                    // (objectType.conditionsChanged as Event<Type, ConditionTargetsChangedEventArgs>).publish(objectType, { conditionTarget: conditionTarget, add: true });
                }
            }
            // Add the condition to the corresponding condition type
            conditionType.conditions.push(this);
            // Add the condition to relevant condition type sets
            if (this.type.sets) {
                for (var s = this.type.sets.length - 1; s >= 0; s--) {
                    this.type.sets[s].conditions.push(this);
                }
            }
        }
    }
    Object.defineProperty(Condition.prototype, "message", {
        get: function () {
            if (typeof (this._message) === "string")
                return this._message;
            else
                return this._message();
        },
        set: function (val) {
            this._message = val;
        },
        enumerable: false,
        configurable: true
    });
    Condition.prototype.destroy = function () {
        /// <summary>Removes the condition targets from all target instances and raises condition change events.</summary>
        // raise events on condition type sets
        if (this.type.sets) {
            for (var s = this.type.sets.length - 1; s >= 0; s--) {
                var set = this.type.sets[s];
                var idx_1 = set.conditions.indexOf(this);
                if (idx_1 >= 0) {
                    set.conditions.splice(idx_1, 1);
                }
            }
        }
        // raise events on condition types
        var idx = this.type.conditions.indexOf(this);
        if (idx >= 0) {
            this.type.conditions.splice(idx, 1);
        }
        for (var t = this.targets.length - 1; t >= 0; t--) {
            var conditionTarget = this.targets[t];
            var objectMeta = conditionTarget.target.meta;
            objectMeta.clearCondition(conditionTarget.condition.type);
            // type events
            for (var objectType = conditionTarget.target.meta.type; objectType != null; objectType = objectType.baseType) {
                // (objectType.conditionsChanged as Event<Type, ConditionTargetsChangedEventArgs>).publish(objectType, { conditionTarget: conditionTarget, add: false, remove: true });
            }
        }
        // remove references to all condition targets
        this.targets.splice(0);
    };
    Condition.prototype.toString = function () {
        return this.message;
    };
    return Condition;
}());
exports.Condition = Condition;


/***/ }),

/***/ "../../libs/model.js/lib/entity-serializer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EntitySerializer = exports.DefaultSerializationSettings = exports.PropertyConverter = exports.IgnoreProperty = void 0;
var type_1 = __webpack_require__("../../libs/model.js/lib/type.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
exports.IgnoreProperty = {
    key: "ignore",
    value: "ignore"
};
/**
 * Allows transformation of the serialized name and value of a model property.
 */
var PropertyConverter = /** @class */ (function () {
    function PropertyConverter() {
    }
    /**
     * @param context The `Entity` containing the specified property.
     * @param prop The property being serialized/deserialized.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    PropertyConverter.prototype.shouldConvert = function (context, prop) {
        return true;
    };
    /**
     * Return `IgnoreProperty` to prevent serialization of the property.
     * @param context The `Entity` containing the specified property.
     * @param prop The current property being serialized.
     * @param value The value of the property on the entity currently being serialized.
     */
    PropertyConverter.prototype.serialize = function (context, value, property, settings) {
        var result = { key: property.name, value: value };
        if (value) {
            if (type_1.isEntityType(property.propertyType)) {
                if (property.isList && Array.isArray(value))
                    result.value = value.map(function (ent) { return ent.serialize(settings); });
                else
                    result.value = value.serialize(settings);
            }
            else if (property.isList)
                result.value = value.slice();
        }
        return result;
    };
    /**
     * Return `IgnoreProperty` to prevent deserialization of the property.
     * @param context The `Entity` containing the specified property.
     * @param prop The current property being deserialized.
     * @param value The value to deserialize.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    PropertyConverter.prototype.deserialize = function (context, value, property) {
        return value;
    };
    return PropertyConverter;
}());
exports.PropertyConverter = PropertyConverter;
exports.DefaultSerializationSettings = {
    force: false,
    useAliases: false
};
var EntitySerializer = /** @class */ (function () {
    function EntitySerializer() {
        this._propertyConverters = [];
        this._propertyInjectors = new Map();
        this._propertyAliases = new Map();
        this._valueResolvers = [];
    }
    /**
     * Property converters should be registered in order of increasing specificity.
     * If two converters would convert a property, only the one registered last will apply.
     */
    EntitySerializer.prototype.registerPropertyConverter = function (converter) {
        this._propertyConverters.unshift(converter);
    };
    /**
     * Property injections will occur when serializing entities of the specified type, or entities which
     * inherit from the specified type. Injected properties will appear before model properties in the serialized
     * output.
     * @param type Either a Type or the fullName of a Type
     * @param injector
     */
    EntitySerializer.prototype.registerPropertyInjector = function (type, injector) {
        var injectors = this._propertyInjectors.get(type) || [];
        injectors.push(injector);
        this._propertyInjectors.set(type, injectors);
    };
    EntitySerializer.prototype.registerPropertyAlias = function (type, alias, propertyName) {
        var aliases = this._propertyAliases.get(type) || {};
        aliases[alias] = propertyName;
        aliases[propertyName] = alias;
        this._propertyAliases.set(type, aliases);
    };
    EntitySerializer.prototype.registerValueResolver = function (resolver) {
        this._valueResolvers.push(resolver);
    };
    /**
     * Returns the property injectors registered for a specific type, including name-based registrations.
     * @param type
     */
    EntitySerializer.prototype.getInjectorsOrDefault = function (type) {
        return (this._propertyInjectors.get(type) || []).concat(this._propertyInjectors.get(type.fullName) || []);
    };
    /**
     * Returns property injectors registered for a type and its base types.
     * @param type
     */
    EntitySerializer.prototype.getPropertyInjectors = function (type) {
        var injectors = [];
        do {
            injectors.push.apply(injectors, this.getInjectorsOrDefault(type));
            type = type.baseType;
        } while (type);
        return injectors;
    };
    EntitySerializer.prototype.serializePropertyValue = function (entity, property, value, settings) {
        var converters = this._propertyConverters.filter(function (c) { return c.shouldConvert(entity, property); });
        var result = (function () {
            if (converters) {
                for (var _i = 0, converters_1 = converters; _i < converters_1.length; _i++) {
                    var converter = converters_1[_i];
                    var res = converter.serialize(entity, value, property, settings);
                    if (!settings.force || res !== exports.IgnoreProperty)
                        return res;
                }
            }
            return EntitySerializer.defaultPropertyConverter.serialize(entity, value, property, settings);
        })();
        if (result && result !== exports.IgnoreProperty && settings.useAliases)
            result.key = this.getPropertyAliases(property.containingType)[property.name] || result.key;
        return result;
    };
    /**
     * Produces a JSON-valid object representation of the entity.
     * @param entity
     */
    EntitySerializer.prototype.serialize = function (entity, settings) {
        var _this = this;
        if (settings === void 0) { settings = exports.DefaultSerializationSettings; }
        var result = {};
        var type = entity.meta.type;
        helpers_1.flatMap(this.getPropertyInjectors(type), function (i) { return i.inject(entity); })
            .concat(type.properties
            .filter(function (p) { return !p.isCalculated && !p.isConstant; })
            .map(function (prop) { return _this.serializePropertyValue(entity, prop, prop.value(entity), settings); }))
            .forEach(function (pair) {
            if (pair && pair !== exports.IgnoreProperty) {
                if (result.hasOwnProperty(pair.key))
                    throw new Error("Property '" + pair.key + "' was encountered twice during serialization. Make sure injected properties do not collide with model properties.");
                result[pair.key] = pair.value;
            }
        });
        return result;
    };
    EntitySerializer.prototype.deserialize = function (instance, data, property, context, constructEntity) {
        var _this = this;
        if (constructEntity === void 0) { constructEntity = true; }
        // Apply custom converters before deserializing
        var converter = this._propertyConverters.find(function (c) { return c.shouldConvert(instance, property); });
        if (converter)
            data = converter.deserialize(instance, data, property);
        if (data === exports.IgnoreProperty)
            return;
        var value;
        var resolveEntity = function (type, state) {
            var entity;
            var id = type.meta.identifier ? state[type.meta.identifier.name] : null;
            if (id)
                entity = type.meta.get(id);
            if (!entity)
                entity = new type(id, state, context);
            return entity;
        };
        // Entities
        if (type_1.isEntityType(property.propertyType)) {
            var ChildEntity_1 = property.propertyType;
            if (!constructEntity)
                value = data;
            // Entity List
            else if (property.isList && Array.isArray(data))
                value = data.map(function (s) { return s instanceof ChildEntity_1 ? s : resolveEntity(ChildEntity_1, s); });
            // Entity
            else if (data instanceof ChildEntity_1)
                value = data;
            else if (data instanceof Object)
                value = resolveEntity(ChildEntity_1, data);
            else if (data === null)
                value = data;
        }
        // Value List
        else if (property.isList && Array.isArray(data))
            value = data.map(function (i) { return _this.deserialize(instance, i, property, context); });
        // Value
        else if (property.format && data && typeof (data) === "string" && data.constructor !== property.propertyType)
            value = property.format.convertFromString(data);
        else
            value = data;
        return value;
    };
    EntitySerializer.prototype.getPropertyAliases = function (type) {
        return Object.assign({}, this._propertyAliases.get(type), this._propertyAliases.get(type.fullName));
    };
    EntitySerializer.prototype.resolveProperty = function (context, propName) {
        var prop = context.meta.type.getProperty(propName);
        if (prop)
            return prop;
        propName = this.getPropertyAliases(context.meta.type)[propName];
        return context.meta.type.getProperty(propName);
    };
    EntitySerializer.prototype.resolveValue = function (context, property, value) {
        for (var _i = 0, _a = this._valueResolvers; _i < _a.length; _i++) {
            var resolve = _a[_i];
            var result = resolve(context, property, value);
            if (result)
                return result;
        }
    };
    EntitySerializer.defaultPropertyConverter = new PropertyConverter();
    return EntitySerializer;
}());
exports.EntitySerializer = EntitySerializer;


/***/ }),

/***/ "../../libs/model.js/lib/entity.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEntity = exports.Entity = void 0;
var events_1 = __webpack_require__("../../libs/model.js/lib/events.js");
var type_1 = __webpack_require__("../../libs/model.js/lib/type.js");
var initilization_context_1 = __webpack_require__("../../libs/model.js/lib/initilization-context.js");
var object_meta_1 = __webpack_require__("../../libs/model.js/lib/object-meta.js");
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
var entity_serializer_1 = __webpack_require__("../../libs/model.js/lib/entity-serializer.js");
var Entity = /** @class */ (function () {
    function Entity(type, id, properties, context) {
        var _this = this;
        if (arguments.length === 0) {
            // TODO: Warn about direct call in dev build?
        }
        else if (Entity.ctorDepth === 0)
            throw new Error("Entity constructor should not be called directly.");
        else {
            Object.defineProperty(this, "_context", { enumerable: false, configurable: false, writable: true, value: null });
            Object.defineProperty(this, "accessed", { enumerable: false, configurable: false, writable: false, value: new events_1.Event() });
            Object.defineProperty(this, "changed", { enumerable: false, configurable: false, writable: false, value: new events_1.Event() });
            var isNew_1 = false;
            if (typeof id === "string")
                type.assertValidId(id);
            else {
                // Was id provided as undefined, or not provided at all?
                if (id !== null && typeof id === "object")
                    properties = id;
                id = type.newId();
                isNew_1 = context ? context.isNewDocument : true;
            }
            // If context was provided, it should be the last argument
            context = arguments[arguments.length - 1];
            if (!(context instanceof initilization_context_1.InitializationContext))
                context = new initilization_context_1.InitializationContext(isNew_1);
            Object.defineProperty(this, "meta", { enumerable: true, configurable: false, writable: false, value: new object_meta_1.ObjectMeta(type, this, id, isNew_1) });
            Object.defineProperty(this, "__fields__", { enumerable: false, configurable: false, writable: false, value: {} });
            Object.defineProperty(this, "__pendingInit__", { enumerable: false, configurable: false, writable: false, value: {} });
            // Register the newly constructed instance
            type.register(this);
            // Initialize existing entity with provided property values
            if (!isNew_1 && properties) {
                // We need to pause processing of callbacks to prevent publishing entity events while still processing the state graph
                context.execute(function () { return _this.init(properties, context); });
            }
            // Raise the initNew or initExisting event on this type and all base types
            this.initialized = new Promise(function (resolve) {
                context.whenReady(function () {
                    // Set values of new entity for provided properties
                    if (isNew_1 && properties)
                        _this.updateWithContext(context, properties);
                    for (var t = type; t; t = t.baseType) {
                        if (isNew_1)
                            t.initNew.publish(t, { entity: _this });
                        else
                            t.initExisting.publish(t, { entity: _this });
                    }
                    context.whenReady(resolve);
                });
            });
        }
    }
    Entity.getSortedPropertyData = function (properties) {
        return helpers_1.entries(properties).sort(function (a, b) {
            return Number(b[1] instanceof Entity) - Number(a[1] instanceof Entity);
        });
    };
    Entity.prototype.init = function (property, context, value) {
        var _a;
        var _this = this;
        if (Entity.ctorDepth === 0) {
            throw new Error("Entity.init() should not be called directly.");
        }
        var properties;
        // Convert property/value pair to a property dictionary
        if (typeof property === "string")
            properties = (_a = {}, _a[property] = value, _a);
        else
            properties = property;
        var initializedProps = new Set();
        var _loop_1 = function (propName, state) {
            var prop = this_1.serializer.resolveProperty(this_1, propName);
            if (prop && !prop.isCalculated && !prop.isConstant) {
                initializedProps.add(prop);
                var valueResolution = context.tryResolveValue(this_1, prop, state);
                if (valueResolution)
                    valueResolution.then(function (asyncState) { return _this.initProp(prop, asyncState, context); });
                else
                    this_1.initProp(prop, state, context);
            }
        };
        var this_1 = this;
        // Initialize the specified properties
        for (var _i = 0, _b = Entity.getSortedPropertyData(properties); _i < _b.length; _i++) {
            var _c = _b[_i], propName = _c[0], state = _c[1];
            _loop_1(propName, state);
        }
        // Pass all unspecified properties through the deserializer to allow initialization logic via converters
        for (var _d = 0, _e = this.meta.type.properties.filter(function (p) { return !initializedProps.has(p); }); _d < _e.length; _d++) {
            var prop = _e[_d];
            var value_1 = this.serializer.deserialize(this, undefined, prop, context);
            if (value_1 !== undefined)
                property_1.Property$init(prop, this, value_1);
        }
    };
    Entity.prototype.initProp = function (prop, state, context) {
        var value;
        value = this.serializer.deserialize(this, state, prop, context);
        if (value !== undefined)
            property_1.Property$init(prop, this, value);
    };
    Entity.prototype.updateWithContext = function (context, state) {
        var _this = this;
        var hadContext = !!this._context;
        // Do not allow reentrant updates of the same entity for a given context
        if (this._context === context)
            return;
        // Don't overwrite existing context
        if (!this._context)
            this._context = context;
        // Ensure provided context waits on the existing context to be ready
        else if (this._context !== context)
            context.wait(this._context.ready);
        this.update(state);
        if (context !== null && !hadContext) {
            context.whenReady(function () {
                _this._context = null;
            });
        }
    };
    Entity.createOrUpdate = function (type, state, context) {
        var id = type_1.getIdFromState(type, state);
        var isNew = !id;
        if (!context)
            context = new initilization_context_1.InitializationContext(isNew);
        // We need to pause processing of callbacks to prevent publishing entity events while still processing
        // the state graph
        var instance = context.execute(function () {
            var instance = id && type.get(id);
            if (instance) {
                // Assign state to the existing object
                instance.updateWithContext(context, state);
            }
            else {
                // Cast the jstype to any so we can call the internal constructor signature that takes a context
                // We don't want to put the context on the public constructor interface
                var Ctor = type.jstype;
                // Construct an instance using the known id if it is present
                instance = (id ? new Ctor(id, state, context) : new Ctor(state, context));
            }
            return instance;
        });
        return instance;
    };
    Entity.prototype.update = function (property, value) {
        var _a;
        var _this = this;
        var properties;
        // Convert property/value pair to a property dictionary
        if (typeof property === "string")
            properties = (_a = {}, _a[property] = value, _a);
        else
            properties = property;
        if (!this._context) {
            var wasNew_1 = this.meta.isNew;
            var context_1 = new initilization_context_1.InitializationContext(true);
            context_1.execute(function () { return _this.updateWithContext(context_1, properties); });
            var markPersistedWhenIdAssigned = function () {
                if (wasNew_1 && !_this.meta.isNew)
                    _this.markPersisted();
            };
            // call markPersistedWhenIdAssigned using whenReady and after the promise resolves to ensure models with no async
            // behavior produce the correct outcome upon returning from update()
            context_1.whenReady(markPersistedWhenIdAssigned);
            return context_1.ready.then(markPersistedWhenIdAssigned);
        }
        var context = this._context;
        var _loop_2 = function (propName, state) {
            var prop = this_2.serializer.resolveProperty(this_2, propName);
            if (prop && !prop.isCalculated && !prop.isConstant) {
                var valueResolution = context.tryResolveValue(this_2, prop, state);
                if (valueResolution)
                    valueResolution.then(function (asyncState) { return _this.setProp(prop, asyncState); });
                else
                    this_2.setProp(prop, state);
            }
        };
        var this_2 = this;
        // Set the specified properties
        for (var _i = 0, _b = Entity.getSortedPropertyData(properties); _i < _b.length; _i++) {
            var _c = _b[_i], propName = _c[0], state = _c[1];
            _loop_2(propName, state);
        }
        return context.ready;
    };
    Entity.prototype.setProp = function (prop, state) {
        var _this = this;
        var value;
        var currentValue = prop.value(this);
        if (type_1.isEntityType(prop.propertyType)) {
            var ChildEntity_1 = prop.propertyType;
            if (prop.isList && Array.isArray(state) && Array.isArray(currentValue)) {
                if (!state.length)
                    currentValue.splice(0);
                else {
                    state.forEach(function (s, idx) {
                        if (!(s instanceof ChildEntity_1))
                            s = _this.serializer.deserialize(_this, s, prop, _this._context, false);
                        // Undefined(IgnoreProperty) got assigned, so do not set the property
                        if (s === undefined)
                            return;
                        // Modifying/replacing existing list item
                        if (idx < currentValue.length) {
                            // If the item is a state object, create/update the entity using the state
                            if (!(s instanceof ChildEntity_1) && typeof s === "object") {
                                var listItem = currentValue[idx];
                                // If the entity is a non-pooled type, update in place
                                // If the entity id matches the id in the state, update in place
                                if (!ChildEntity_1.meta.identifier || type_1.getIdFromState(ChildEntity_1.meta, s) === listItem.meta.id)
                                    listItem.updateWithContext(_this._context, s);
                                else
                                    currentValue.splice(idx, 1, Entity.createOrUpdate(ChildEntity_1.meta, s, _this._context));
                            }
                            else if (s instanceof ChildEntity_1)
                                currentValue.splice(idx, 1, s);
                            else
                                console.warn("Provided state,", s, ", is not valid for type " + ChildEntity_1.meta.fullName + "[].");
                        }
                        // Add a list item
                        else if (s instanceof ChildEntity_1)
                            currentValue.push(s);
                        else
                            currentValue.push(Entity.createOrUpdate(ChildEntity_1.meta, s, _this._context));
                    });
                    // Remove excess items from the list
                    currentValue.splice(state.length);
                }
                // Mark property pendingInit = false, since value is not assigned so the setter is not called
                property_1.Property$pendingInit(this, prop, false);
            }
            else if (state instanceof ChildEntity_1)
                value = state;
            else if (state == null)
                value = null;
            else {
                // Attempt to deserialize the state
                var newState = this.serializer.deserialize(this, state, prop, this._context, false);
                // Undefined(IgnoreProperty) got assigned, so do not set the property
                if (newState === undefined)
                    return;
                if (typeof newState !== "undefined")
                    state = newState;
                // Got null, so assign null to the property
                if (state == null)
                    value = null;
                // Got a valid instance, so use it
                else if (state instanceof ChildEntity_1)
                    value = state;
                // Got something other than an object, so just use it and expect to get a down-stream error
                else if (typeof state !== "object")
                    value = state;
                else if (currentValue && !type_1.getIdFromState(ChildEntity_1.meta, state))
                    currentValue.updateWithContext(this._context, state);
                // Got an object, so attempt to fetch or create and assign the state
                else
                    value = Entity.createOrUpdate(ChildEntity_1.meta, state, this._context);
            }
        }
        else if (prop.isList && Array.isArray(state) && Array.isArray(currentValue)) {
            currentValue.splice.apply(currentValue, __spreadArrays([0, currentValue.length], state.map(function (s) { return _this.serializer.deserialize(_this, s, prop, _this._context); })));
            // Mark property pendingInit = false, since value is not assigned so the setter is not called
            property_1.Property$pendingInit(this, prop, false);
        }
        else
            value = this.serializer.deserialize(this, state, prop, this._context);
        if (value !== undefined)
            try {
                property_1.Property$setter(prop, this, value);
            }
            catch (e) {
                console.warn(e);
            }
    };
    Entity.prototype.get = function (property) {
        return this.meta.type.getProperty(property).value(this);
    };
    Entity.prototype.toString = function (format, formatEval) {
        // Get the entity format to use
        var formatter = null;
        if (format) {
            formatter = this.meta.type.model.getFormat(this.constructor, format, formatEval);
        }
        else {
            formatter = this.meta.type.format;
        }
        // Use the formatter, if available, to create the string representation
        if (formatter) {
            return formatter.convert(this);
        }
        else {
            return this.meta.type.fullName + "|" + this.meta.id;
        }
    };
    Object.defineProperty(Entity.prototype, "serializer", {
        get: function () {
            return this.meta.type.model.serializer;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Produces a JSON-valid object representation of the entity.
     * @param entity
     */
    Entity.prototype.serialize = function (settings) {
        if (settings === void 0) { settings = entity_serializer_1.DefaultSerializationSettings; }
        return this.serializer.serialize(this, settings);
    };
    Entity.prototype.markPersisted = function () {
        if (!this.meta.type.identifier || !this.meta.type.identifier.value(this))
            return;
        var visited = new Set();
        var _persist = function (entity) {
            if (visited.has(entity))
                return;
            visited.add(entity);
            entity.meta.isNew = false;
            // visit reference properties with non-identifying types
            for (var _i = 0, _a = entity.meta.type.properties.filter(function (p) { return type_1.isEntityType(p.propertyType) && !p.propertyType.meta.identifier; }); _i < _a.length; _i++) {
                var property = _a[_i];
                var value = property.value(entity);
                if (Array.isArray(value))
                    value.forEach(function (item) { return _persist(item); });
                else if (value)
                    _persist(value);
            }
        };
        _persist(this);
    };
    Entity.ctorDepth = 0;
    return Entity;
}());
exports.Entity = Entity;
function isEntity(obj) {
    return obj && obj.meta && obj.meta.type && obj.meta.type.jstype && type_1.isEntityType(obj.meta.type.jstype);
}
exports.isEntity = isEntity;


/***/ }),

/***/ "../../libs/model.js/lib/event-scope.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EventScope = exports.EVENT_SCOPE_DEFAULT_SETTINGS = void 0;
var events_1 = __webpack_require__("../../libs/model.js/lib/events.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
exports.EVENT_SCOPE_DEFAULT_SETTINGS = {
    maxExitingTransferCount: 100,
    maxDepth: 1000
};
var __lastEventScopeId = 0;
var EventScope = /** @class */ (function () {
    function EventScope(parent, maxExitingTransferCount, maxDepth, isActive) {
        if (isActive === void 0) { isActive = false; }
        this.current = null;
        this.parent = parent;
        this.current = null;
        this.isActive = isActive;
        this.settings = { maxExitingTransferCount: maxExitingTransferCount, maxDepth: maxDepth };
        this.onError = new events_1.Event();
        this._uid = ++__lastEventScopeId;
        this._depth = parent === null ? 1 : parent._depth + 1;
        this._onExit = new events_1.Event();
    }
    EventScope.create = function (_a) {
        var _b = _a.maxExitingTransferCount, maxExitingTransferCount = _b === void 0 ? exports.EVENT_SCOPE_DEFAULT_SETTINGS.maxExitingTransferCount : _b, _c = _a.maxDepth, maxDepth = _c === void 0 ? exports.EVENT_SCOPE_DEFAULT_SETTINGS.maxDepth : _c;
        return new EventScope(null, maxExitingTransferCount, maxDepth, false);
    };
    /**
     * Creates a new event scope, performs the action, then exits the scope
     * @param callback The action to perform within the new scope
     */
    EventScope.prototype.perform = function (callback) {
        var scope = new EventScope(this.current, this.settings.maxExitingTransferCount, this.settings.maxDepth, true);
        var isDisposing = false;
        try {
            this.current = scope;
            if (scope._depth >= this.settings.maxDepth)
                throw new Error("Exceeded max scope depth.");
            // Invoke the callback
            callback();
            // Dispose of the event scope
            isDisposing = true;
            this.current.dispose({ abort: false });
        }
        catch (e) {
            if (!isDisposing)
                this.current.dispose({ abort: true });
            var errorEvent = this.onError.publish(this, { error: e });
            if (errorEvent === undefined || !errorEvent.isDefaultPrevented)
                throw e;
        }
        finally {
            // Roll back to the closest active scope
            while (this.current && !this.current.isActive) {
                this.current = this.current.parent;
            }
        }
    };
    /**
     * Subscribes to the "exit" event of the current scope, or invokes immediately if there is not a current scope
     * @param handler The event handler to invoke when exited
     */
    EventScope.prototype.onExit = function (handler) {
        if (this.current === null) {
            // Immediately invoke the callback
            handler({ abort: false });
        }
        else if (!this.current.isActive) {
            throw new Error("The current event scope cannot be inactive.");
        }
        else {
            // Subscribe to the exit event
            this.current._onExit.subscribe(handler);
        }
    };
    EventScope.prototype.dispose = function (_a) {
        var _b = _a.abort, abort = _b === void 0 ? false : _b;
        if (!this.isActive) {
            throw new Error("The event scope cannot be exited because it is not active.");
        }
        try {
            if (abort) {
                this._onExit.publish(this, { abort: true });
            }
            else {
                var exitSubscriptions = helpers_1.getEventSubscriptions(this._onExit);
                if (exitSubscriptions && exitSubscriptions.length > 0) {
                    // If there is no parent scope, then go ahead and execute the 'exit' event
                    if (this.parent === null || !this.parent.isActive) {
                        // Record the initial "version" before starting to call subscribers
                        this._exitEventVersion = 0;
                        // Invoke all subscribers
                        this._onExit.publish(this, { abort: false });
                        // Delete the field to indicate that raising the exit event suceeded
                        delete this._exitEventVersion;
                    }
                    else {
                        try {
                            // Attempt to move subscribers to the parent scope
                            this.parent.receiveExitEventSubscribers(exitSubscriptions);
                        }
                        catch (e) {
                            this.dispose({ abort: true });
                            throw e;
                        }
                    }
                }
            }
            // Clear the events to ensure that they aren't inadvertantly raised again through this scope
            this._onExit.clear();
        }
        finally {
            // The event scope is no longer active
            this.isActive = false;
        }
    };
    EventScope.prototype.receiveExitEventSubscribers = function (subscriptions) {
        var _this = this;
        var maxNesting = this.settings.maxExitingTransferCount - 1;
        if (this._exitEventVersion >= maxNesting) {
            throw new Error("Exceeded max scope event transfer.");
        }
        // Move subscribers to the parent scope
        subscriptions.forEach(function (sub) { return _this._onExit.subscribe(sub.handler); });
        if (this._exitEventVersion !== undefined) {
            this._exitEventVersion++;
        }
    };
    EventScope.prototype.toString = function () {
        return "" + (this.parent ? this.parent.toString() + "->" : "") + this._uid;
    };
    return EventScope;
}());
exports.EventScope = EventScope;


/***/ }),

/***/ "../../libs/model.js/lib/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Event = exports.createEventObject = exports.EventObjectImpl = void 0;
var functor_1 = __webpack_require__("../../libs/model.js/lib/functor.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
var EventObjectImpl = /** @class */ (function () {
    function EventObjectImpl() {
        this.isDefaultPrevented = false;
    }
    EventObjectImpl.prototype.preventDefault = function () {
        this.isDefaultPrevented = true;
    };
    return EventObjectImpl;
}());
exports.EventObjectImpl = EventObjectImpl;
function createEventObject(args) {
    var eventObject = new EventObjectImpl();
    for (var prop in args) {
        if (helpers_1.hasOwnProperty(args, prop)) {
            eventObject[prop] = args[prop];
        }
    }
    return eventObject;
}
exports.createEventObject = createEventObject;
var Event = /** @class */ (function () {
    function Event(subscriptionChanged) {
        if (subscriptionChanged) {
            this.subscriptionChanged = subscriptionChanged;
        }
    }
    Event.prototype.publish = function (thisObject, args) {
        if (!this.func) {
            // No subscribers
            return;
        }
        var eventObject = createEventObject(args);
        this.func.call(thisObject, eventObject);
        return eventObject;
    };
    Event.prototype.subscribe = function (handler) {
        if (!this.func) {
            Object.defineProperty(this, "func", { value: functor_1.Functor$create() });
        }
        this.func.add(handler);
        if (this.subscriptionChanged)
            this.subscriptionChanged(this);
    };
    Event.prototype.subscribeOne = function (handler) {
        if (!this.func) {
            Object.defineProperty(this, "func", { value: functor_1.Functor$create() });
        }
        this.func.add(handler, null, true);
        if (this.subscriptionChanged)
            this.subscriptionChanged(this);
    };
    Event.prototype.hasSubscribers = function (handler) {
        if (!this.func) {
            return false;
        }
        var functorItems = (this.func._funcs);
        return handler ? functorItems.some(function (i) { return i.fn === handler; }) : functorItems.length > 0;
    };
    Event.prototype.unsubscribe = function (handler) {
        if (!this.func) {
            // No subscribers
            return;
        }
        this.func.remove(handler);
        if (this.subscriptionChanged)
            this.subscriptionChanged(this);
    };
    Event.prototype.clear = function () {
        if (!this.func) {
            // No subscribers
            return;
        }
        this.func.clear();
        if (this.subscriptionChanged)
            this.subscriptionChanged(this);
    };
    return Event;
}());
exports.Event = Event;


/***/ }),

/***/ "../../libs/model.js/lib/format-error.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.FormatError = void 0;
var condition_type_1 = __webpack_require__("../../libs/model.js/lib/condition-type.js");
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var condition_1 = __webpack_require__("../../libs/model.js/lib/condition.js");
var FormatError = /** @class */ (function () {
    function FormatError(format, message, invalidValue) {
        if (FormatError.ConditionType === null) {
            FormatError.ConditionType = new condition_type_1.ErrorConditionType("FormatError", "The value is not properly formatted.");
        }
        this.format = format;
        this.messageTemplate = message;
        this.invalidValue = invalidValue;
    }
    FormatError.prototype.createCondition = function (target, prop) {
        var _this = this;
        return new condition_1.Condition(FormatError.ConditionType, function () { return _this.messageTemplate.replace("{property}", property_1.evaluateLabel(prop, target)); }, target, this.format, [prop]);
    };
    FormatError.prototype.toString = function () {
        return this.invalidValue;
    };
    FormatError.ConditionType = null;
    return FormatError;
}());
exports.FormatError = FormatError;


/***/ }),

/***/ "../../libs/model.js/lib/format.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFormat = exports.ModelFormat = exports.CustomFormat = exports.Format = exports.getFormatTemplateParser = void 0;
var format_error_1 = __webpack_require__("../../libs/model.js/lib/format-error.js");
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var property_chain_1 = __webpack_require__("../../libs/model.js/lib/property-chain.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
var model_1 = __webpack_require__("../../libs/model.js/lib/model.js");
var globalization_1 = __webpack_require__("../../libs/model.js/lib/globalization.js");
exports.getFormatTemplateParser = function () { return /\[([_a-zA-Z\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u02bb-\u02c1\u02d0-\u02d1\u02e0-\u02e4\u02ee\u0370-\u0373\u0376-\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u064a\u0660-\u0669\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07c0-\u07ea\u07f4-\u07f5\u07fa\u0904-\u0939\u093d\u0950\u0958-\u0961\u0966-\u096f\u0971-\u0972\u097b-\u097f\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09e6-\u09f1\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a66-\u0a6f\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0ae6-\u0aef\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b66-\u0b6f\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0be6-\u0bef\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58-\u0c59\u0c60-\u0c61\u0c66-\u0c6f\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0ce6-\u0cef\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d3d\u0d60-\u0d61\u0d66-\u0d6f\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0ed0-\u0ed9\u0edc-\u0edd\u0f00\u0f20-\u0f29\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8b\u1000-\u102a\u103f-\u1049\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u1090-\u1099\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u17e0-\u17e9\u1810-\u1819\u1820-\u1877\u1880-\u18a8\u18aa\u1900-\u191c\u1946-\u196d\u1970-\u1974\u1980-\u19a9\u19c1-\u19c7\u19d0-\u19d9\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b50-\u1b59\u1b83-\u1ba0\u1bae-\u1bb9\u1c00-\u1c23\u1c40-\u1c49\u1c4d-\u1c7d\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u2094\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183-\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2c6f\u2c71-\u2c7d\u2c80-\u2ce4\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3006\u3031-\u3035\u303b-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31b7\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fc3\ua000-\ua48c\ua500-\ua60c\ua610-\ua62b\ua640-\ua65f\ua662-\ua66e\ua680-\ua697\ua722-\ua788\ua78b-\ua78c\ua7fb-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8d0-\ua8d9\ua900-\ua925\ua930-\ua946\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa50-\uaa59\uac00-\ud7a3\uf900-\ufa2d\ufa30-\ufa6a\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][_.0-9a-zA-Z\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u02bb-\u02c1\u02d0-\u02d1\u02e0-\u02e4\u02ee\u0370-\u0373\u0376-\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u064a\u0660-\u0669\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07c0-\u07ea\u07f4-\u07f5\u07fa\u0904-\u0939\u093d\u0950\u0958-\u0961\u0966-\u096f\u0971-\u0972\u097b-\u097f\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09e6-\u09f1\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a66-\u0a6f\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0ae6-\u0aef\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b66-\u0b6f\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0be6-\u0bef\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58-\u0c59\u0c60-\u0c61\u0c66-\u0c6f\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0ce6-\u0cef\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d3d\u0d60-\u0d61\u0d66-\u0d6f\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0ed0-\u0ed9\u0edc-\u0edd\u0f00\u0f20-\u0f29\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8b\u1000-\u102a\u103f-\u1049\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u1090-\u1099\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u17e0-\u17e9\u1810-\u1819\u1820-\u1877\u1880-\u18a8\u18aa\u1900-\u191c\u1946-\u196d\u1970-\u1974\u1980-\u19a9\u19c1-\u19c7\u19d0-\u19d9\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b50-\u1b59\u1b83-\u1ba0\u1bae-\u1bb9\u1c00-\u1c23\u1c40-\u1c49\u1c4d-\u1c7d\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u2094\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183-\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2c6f\u2c71-\u2c7d\u2c80-\u2ce4\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3006\u3031-\u3035\u303b-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31b7\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fc3\ua000-\ua48c\ua500-\ua60c\ua610-\ua62b\ua640-\ua65f\ua662-\ua66e\ua680-\ua697\ua722-\ua788\ua78b-\ua78c\ua7fb-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8d0-\ua8d9\ua900-\ua925\ua930-\ua946\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa50-\uaa59\uac00-\ud7a3\uf900-\ufa2d\ufa30-\ufa6a\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]*)(:(.+?))?\]/ig; };
var metaPathParser = /^(.*\.|)meta(\..*|)$/;
var Format = /** @class */ (function () {
    function Format(model, specifier, description, nullString, undefinedString) {
        if (description === void 0) { description = null; }
        if (nullString === void 0) { nullString = null; }
        if (undefinedString === void 0) { undefinedString = undefined; }
        if (true) {
            if (!model || !(model instanceof model_1.Model))
                throw new Error("Model must be provided.");
            if (!specifier || typeof specifier !== "string")
                throw new Error("Format specifier string must be provided.");
        }
        this.model = model;
        this.specifier = specifier;
        this.description = description;
        this.nullString = nullString || "";
        this.undefinedString = undefinedString || "";
    }
    Format.prototype.convert = function (val) {
        if (val === undefined) {
            return this.undefinedString;
        }
        if (val === null) {
            return this.nullString;
        }
        if (val instanceof format_error_1.FormatError) {
            return val.invalidValue;
        }
        return this.convertToString(val);
    };
    Format.prototype.convertBack = function (text) {
        if (text === null || text === this.nullString) {
            return null;
        }
        if (text === undefined || text === this.undefinedString) {
            return;
        }
        if (typeof text === "string") {
            text = text.trim();
            if (text.length === 0) {
                return null;
            }
        }
        return this.convertFromString(text);
    };
    Format.prototype.toString = function () {
        return this.specifier;
    };
    Format.create = function (model, options) {
        return new CustomFormat(model, options);
    };
    Format.fromTemplate = function (type, template, formatEval) {
        return new ModelFormat(type, template, formatEval);
    };
    Format.hasTokens = function (template) {
        return exports.getFormatTemplateParser().test(template);
    };
    return Format;
}());
exports.Format = Format;
var CustomFormat = /** @class */ (function (_super) {
    __extends(CustomFormat, _super);
    function CustomFormat(model, options) {
        var _this = _super.call(this, model, options.specifier, options.description, options.nullString, options.undefinedString) || this;
        _this.customConvert = options.convert;
        _this.customConvertBack = options.convertBack;
        _this.paths = options.paths;
        return _this;
    }
    CustomFormat.prototype.convertToString = function (val) {
        if (!this.customConvert) {
            return val;
        }
        return this.customConvert(val);
    };
    CustomFormat.prototype.convertFromString = function (text) {
        if (!this.customConvertBack) {
            return text;
        }
        try {
            return this.customConvertBack(text);
        }
        catch (err) {
            if (err instanceof format_error_1.FormatError) {
                return err;
            }
            var formatError = new format_error_1.FormatError(this, this.description ?
                this.model.getResource("format-with-description").replace("{description}", this.description) :
                this.model.getResource("format-without-description"), text);
            return formatError;
        }
    };
    return CustomFormat;
}(Format));
exports.CustomFormat = CustomFormat;
var ModelFormat = /** @class */ (function (_super) {
    __extends(ModelFormat, _super);
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    function ModelFormat(type, specifier, formatEval) {
        var _this = _super.call(this, type.model, specifier) || this;
        _this.type = type;
        _this.formatEval = formatEval;
        // Compile the model format when the model is ready
        _this.model.ready(function () { return _this.compile(); }, { enqueueWhileProcessing: false });
        return _this;
    }
    ModelFormat.prototype.compile = function () {
        if (!this.tokens) {
            this.paths = [];
            this.tokens = [];
            this.template = this.specifier;
            // Replace escaped \, [ or ] characters with placeholders
            var template = this.template.replace(/\\\\/g, "\u0000").replace(/\\\[/g, "\u0001").replace(/\\\]/g, "\u0002");
            var index = 0;
            var formatTemplateParser = exports.getFormatTemplateParser();
            var match = formatTemplateParser.exec(template);
            // Process each token match
            while (match) {
                var path = match[1];
                var propertyPath = path;
                // See if the path represents a property path in the model
                var propertyDefaultFormat = null;
                try {
                    // Detect property path followed by ".meta..."
                    propertyPath = propertyPath.replace(metaPathParser, "$1");
                    var isMetaPath = propertyPath.length > 0 && propertyPath.length < path.length;
                    var allowFormat = !isMetaPath;
                    if (isMetaPath) {
                        propertyPath = propertyPath.substring(0, propertyPath.length - 1);
                    }
                    // If a property path remains, then attempt to find a default format and paths for the format
                    if (propertyPath) {
                        var property = this.type.getPath(propertyPath);
                        if (property) {
                            // Only allow formats for a property path that is not followed by ".meta..."
                            if (allowFormat) {
                                // Determine the default property format
                                if (property instanceof property_1.Property) {
                                    propertyDefaultFormat = property.format;
                                }
                                else if (property instanceof property_chain_1.PropertyChain) {
                                    var lastProperty = property.lastProperty;
                                    propertyDefaultFormat = lastProperty.format;
                                }
                                // Ensure the target format is compiled so we can collect its paths
                                if (propertyDefaultFormat instanceof ModelFormat)
                                    propertyDefaultFormat.compile();
                                // If the path references one or more entity properties, include paths for the property format. Otherwise, just add the path.
                                if (propertyDefaultFormat && propertyDefaultFormat instanceof Format && propertyDefaultFormat !== this && propertyDefaultFormat.paths.length > 0)
                                    Array.prototype.push.apply(this.paths, propertyDefaultFormat.paths.map(function (p) { return propertyPath + "." + p; }));
                                else
                                    this.paths.push(propertyPath);
                            }
                            // Formats are not allowed, so just add the path
                            else {
                                this.paths.push(propertyPath);
                            }
                        }
                    }
                }
                catch (e) {
                    //
                }
                // Create a token for the current match, including the prefix, path and format
                this.tokens.push({
                    prefix: template.substring(index, formatTemplateParser.lastIndex - match[0].length).replace(/\u0000/g, "\\").replace(/\u0001/g, "[").replace(/\u0002/g, "]"),
                    path: path,
                    format: match[3] ? match[3].replace(/\u0000/g, "\\").replace(/\u0001/g, "[").replace(/\u0002/g, "]") : propertyDefaultFormat
                });
                // Track the last index and find the next match
                index = formatTemplateParser.lastIndex;
                match = formatTemplateParser.exec(template);
            }
            // Capture any trailing literal text as a token without a path
            if (index < template.length) {
                this.tokens.push({
                    prefix: template.substring(index).replace(/\u0000/g, "\\").replace(/\u0001/g, "[").replace(/\u0002/g, "]")
                });
            }
        }
    };
    ModelFormat.prototype.convertToString = function (obj) {
        var _this = this;
        if (obj === null || obj === undefined) {
            return "";
        }
        var convertTokens = function (obj) {
            var result = "";
            for (var index = 0; index < _this.tokens.length; index++) {
                var token = _this.tokens[index];
                if (token.prefix)
                    result = result + token.prefix;
                if (token.path) {
                    var value = helpers_1.evalPath(obj, token.path);
                    if (value === undefined || value === null) {
                        value = "";
                    }
                    else if (token.format) {
                        var format = void 0;
                        if (token.format instanceof Format) {
                            format = token.format;
                        }
                        else if (typeof token.format === "string") {
                            format = token.format = obj.meta.type.model.getFormat(value.constructor, token.format);
                        }
                        value = format.convert(value);
                    }
                    if (_this.formatEval)
                        value = _this.formatEval(value);
                    if (Array.isArray(value))
                        value = value.join(", ");
                    result = result + value;
                }
            }
            return result;
        };
        if (Array.isArray(obj))
            return obj.map(function (item) { return convertTokens(item); }).join(", ");
        else
            return convertTokens(obj);
    };
    ModelFormat.prototype.convertFromString = function () {
        throw new Error("Cannot convert from a format string back to an entity.");
    };
    return ModelFormat;
}(Format));
exports.ModelFormat = ModelFormat;
function createFormat(model, type, format) {
    if (type === Date) {
        // Add support for g and G that are not natively supported by the format and parse methods
        if (format === "g")
            format = globalization_1.expandDateFormat(model.$culture.dateTimeFormat, "d") + " " + globalization_1.expandDateFormat(model.$culture.dateTimeFormat, "t");
        else if (format === "G")
            format = globalization_1.expandDateFormat(model.$culture.dateTimeFormat, "d") + " " + globalization_1.expandDateFormat(model.$culture.dateTimeFormat, "T");
        return Format.create(model, {
            specifier: format,
            description: "",
            paths: [],
            convert: function (value) {
                return globalization_1.formatDate(value, format, model.$culture);
            },
            convertBack: function (str) {
                var date;
                // Time value, set default date to 1/1/1970 to easily compare time values
                if (format === "t") {
                    var timeFormat = globalization_1.expandDateFormat(model.$culture.dateTimeFormat, "d") + " " + globalization_1.expandDateFormat(model.$culture.dateTimeFormat, "t");
                    var startDate = globalization_1.formatDate(new Date(1970, 0, 1), "d", model.$culture);
                    date = globalization_1.parseDate(startDate + " " + str, model.$culture, [timeFormat]);
                }
                else
                    date = globalization_1.parseDate(str, model.$culture, [format]);
                if (date === null)
                    throw new Error("Invalid date format");
                return date;
            }
        });
    }
    else if (type === Number) {
        var isCurrencyFormat = format.match(/[$c]+/i);
        var isPercentageFormat = format.match(/[%p]+/i);
        var isIntegerFormat = format.match(/[dnfg]0/i);
        return Format.create(model, {
            specifier: format,
            description: isCurrencyFormat ? model.getResource("format-currency") : isPercentageFormat ? model.getResource("format-percentage") : isIntegerFormat ? model.getResource("format-integer") : model.getResource("format-decimal"),
            convert: function (val) {
                // Default to browser formatting for general format
                if (format.toLowerCase() === "g")
                    return val.toString();
                // Otherwise, use the localized format
                return globalization_1.formatNumber(val, format, model.$culture);
            },
            convertBack: function (str) {
                var result = globalization_1.parseNumber(str, globalization_1.getNumberStyle(format), model.$culture);
                if (isNaN(result))
                    throw new Error("Invalid format");
                return result;
            }
        });
    }
    else if (type === Boolean) {
        // Format strings used for true, false, and null (or undefined) values
        var trueFormat_1, falseFormat_1, nullFormat_1;
        if (format && format.toLowerCase() === "g") {
            trueFormat_1 = "True";
            falseFormat_1 = "False";
            nullFormat_1 = "";
        }
        else {
            var formats = format.split(";");
            trueFormat_1 = formats.length > 0 ? formats[0] : "";
            falseFormat_1 = formats.length > 1 ? formats[1] : "";
            nullFormat_1 = formats.length > 2 ? formats[2] : "";
        }
        /**
         * Determines if the given string matches the given format option
         * @param str The text to check
         * @param formatValue The true or false format option
         */
        var isFormatMatch_1 = function (str, formatValue) {
            return str.trim().toLowerCase() === formatValue.trim().toLowerCase();
        };
        return Format.create(model, {
            specifier: format,
            convert: function (val) {
                if (val === true) {
                    return trueFormat_1;
                }
                else if (val === false) {
                    return falseFormat_1;
                }
                else {
                    return nullFormat_1;
                }
            },
            convertBack: function (str) {
                if (isFormatMatch_1(str, trueFormat_1))
                    return true;
                else if (isFormatMatch_1(str, falseFormat_1))
                    return false;
                else
                    return null;
            }
        });
    }
    else {
        console.log("WARN: Unable to create format for type '" + helpers_1.getConstructorName(type) + "'.");
    }
}
exports.createFormat = createFormat;


/***/ }),

/***/ "../../libs/model.js/lib/functor.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Functor$clear = exports.Functor$isEmpty = exports.Functor$remove = exports.Functor$add = exports.FunctorItem$new = exports.Functor$create = void 0;
function Functor$create(returns) {
    if (returns === void 0) { returns = false; }
    var funcs = [];
    // TODO: Detect functor invocation resulting in continually adding subscribers
    function Functor$fn() {
        var returnsArray;
        if (returns) {
            returnsArray = [];
        }
        for (var i = 0; i < funcs.length; ++i) {
            var item = funcs[i];
            // Don't re-run one-time subscriptions that have already been applied.
            if (item.applied === true) {
                continue;
            }
            // Ensure that there is either no filter or the filter passes.
            if (!item.filter || item.filter.apply(this, arguments) === true) {
                // If handler is set to execute once,
                // remove the handler before calling.
                if (item.once === true) {
                    // Mark as applied but leave item in array to avoid potential
                    // problems due to re-entry into event invalidating iteration
                    // index. In some cases re-entry would be a red-flag, but for
                    // "global" events, where the context of the event is derived
                    // from the arguments, the event could easily be re-entered
                    // in a different context with different arguments.
                    item.applied = true;
                }
                // Call the handler function.
                var returnValue = item.fn.apply(this, arguments);
                if (returns) {
                    returnsArray.push(returnValue);
                }
            }
        }
        if (returns) {
            return returnsArray;
        }
    }
    ;
    var f = Functor$fn;
    f._funcs = funcs;
    f.add = Functor$add;
    f.remove = Functor$remove;
    f.isEmpty = Functor$isEmpty;
    f.clear = Functor$clear;
    return f;
}
exports.Functor$create = Functor$create;
function FunctorItem$new(fn, filter, once) {
    if (filter === void 0) { filter = null; }
    if (once === void 0) { once = false; }
    var item = { fn: fn };
    if (filter != null) {
        item.filter = filter;
    }
    if (once != null) {
        item.once = once;
    }
    return item;
}
exports.FunctorItem$new = FunctorItem$new;
function Functor$add(fn, filter, once) {
    if (filter === void 0) { filter = null; }
    if (once === void 0) { once = false; }
    var item = FunctorItem$new(fn, filter, once);
    this._funcs.push(item);
}
exports.Functor$add = Functor$add;
function Functor$remove(fn) {
    for (var i = this._funcs.length - 1; i >= 0; --i) {
        if (this._funcs[i].fn === fn) {
            this._funcs.splice(i, 1);
            return true;
        }
    }
    return false;
}
exports.Functor$remove = Functor$remove;
function Functor$isEmpty(args) {
    if (args === void 0) { args = null; }
    return !this._funcs.some(function (item) { return item.applied !== true && (!args || !item.filter || item.filter.apply(this, args)); }, this);
}
exports.Functor$isEmpty = Functor$isEmpty;
function Functor$clear() {
    this._funcs.length = 0;
}
exports.Functor$clear = Functor$clear;


/***/ }),

/***/ "../../libs/model.js/lib/globalization.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*!
 * Based on portions of MicrosoftAjax.debug.js (v3.0.31106.1) from System.Web.Extensions.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CultureInfo = exports.formatNumber = exports._parseNumber = exports.parseNumber = exports.getNumberStyle = exports.formatDate = exports.parseDate = exports.expandDateFormat = void 0;
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
/**
 * Internally used resource strings
 * TODO: Make these localizable resources?
 */
var Res = {
    "format": "One of the identified items was in an invalid format.",
    "formatBadFormatSpecifier": "Format specifier was invalid.",
    "formatInvalidString": "Input string was not in a correct format."
};
/**
 * A class for building a string programmatically
 */
var StringBuilder = /** @class */ (function () {
    function StringBuilder(initialText) {
        this._parts = (typeof (initialText) !== "undefined" && initialText !== null && initialText !== "") ? [initialText.toString()] : [];
        this._value = {};
        this._len = 0;
    }
    StringBuilder.prototype.append = function (text) {
        this._parts.push(text);
        return this;
    };
    StringBuilder.prototype.appendLine = function (text) {
        this._parts.push(((typeof (text) === "undefined") || (text === null) || (text === "")) ? "\r\n" : (text + "\r\n"));
        return this;
    };
    StringBuilder.prototype.clear = function () {
        this._parts = [];
        this._value = {};
        this._len = 0;
    };
    StringBuilder.prototype.isEmpty = function () {
        if (this._parts.length === 0)
            return true;
        return this.toString() === "";
    };
    StringBuilder.prototype.toString = function (separator) {
        separator = separator || "";
        var parts = this._parts;
        if (this._len !== parts.length) {
            this._value = {};
            this._len = parts.length;
        }
        var val = this._value;
        if (typeof (val[separator]) === "undefined") {
            if (separator !== "") {
                for (var i = 0; i < parts.length;) {
                    if ((typeof (parts[i]) === "undefined") || (parts[i] === "") || (parts[i] === null)) {
                        parts.splice(i, 1);
                    }
                    else {
                        i++;
                    }
                }
            }
            val[separator] = this._parts.join(separator);
        }
        return val[separator];
    };
    return StringBuilder;
}());
/**
 * Subclass of error for invalid format strings
 */
var FormatError = /** @class */ (function (_super) {
    __extends(FormatError, _super);
    function FormatError(message) {
        var _this = this;
        var displayMessage = "Sys.FormatException: " + (message || Res.format);
        _this = _super.call(this, displayMessage) || this;
        _this.name = "Sys.FormatException";
        return _this;
    }
    return FormatError;
}(Error));
function date$appendPreOrPostMatch(preMatch, strBuilder) {
    var quoteCount = 0;
    var escaped = false;
    for (var i = 0, il = preMatch.length; i < il; i++) {
        var c = preMatch.charAt(i);
        switch (c) {
            case "'":
                if (escaped)
                    strBuilder.append("'");
                else
                    quoteCount++;
                escaped = false;
                break;
            case "\\":
                if (escaped)
                    strBuilder.append("\\");
                escaped = !escaped;
                break;
            default:
                strBuilder.append(c);
                escaped = false;
                break;
        }
    }
    return quoteCount;
}
function expandDateFormat(dtf, format) {
    if (!format) {
        format = "F";
    }
    var len = format.length;
    if (len === 1) {
        switch (format) {
            case "d":
                return dtf["ShortDatePattern"];
            case "D":
                return dtf["LongDatePattern"];
            case "t":
                return dtf["ShortTimePattern"];
            case "T":
                return dtf["LongTimePattern"];
            case "f":
                return dtf["LongDatePattern"] + " " + dtf["ShortTimePattern"];
            case "F":
                return dtf["FullDateTimePattern"];
            case "g":
                return dtf["ShortDatePattern"] + " " + dtf["ShortTimePattern"];
            case "G":
                return dtf["ShortDatePattern"] + " " + dtf["LongTimePattern"];
            case "M":
            case "m":
                return dtf["MonthDayPattern"];
            case "s":
                return dtf["SortableDateTimePattern"];
            case "Y":
            case "y":
                return dtf["YearMonthPattern"];
            default:
                throw new FormatError(Res.formatInvalidString);
        }
    }
    else if ((len === 2) && (format.charAt(0) === "%")) {
        format = format.charAt(1);
    }
    return format;
}
exports.expandDateFormat = expandDateFormat;
function expandYear(dtf, year) {
    var now = new Date();
    var era = getEra(now);
    if (year < 100) {
        var curr = getEraYear(now, dtf, era);
        year += curr - (curr % 100);
        if (year > dtf.Calendar.TwoDigitYearMax) {
            year -= 100;
        }
    }
    return year;
}
function getEra(date, eras) {
    if (!eras)
        return 0;
    var start;
    var ticks = date.getTime();
    for (var i = 0, l = eras.length; i < l; i += 4) {
        start = eras[i + 2];
        if ((start === null) || (ticks >= start)) {
            return i;
        }
    }
    return 0;
}
function getEraYear(date, dtf, era, sortable) {
    var year = date.getFullYear();
    if (!sortable && dtf.Eras) {
        year -= dtf.Eras[era + 3];
    }
    return year;
}
function getDateParseRegExp(dtf, format) {
    // Get or initialize the regex cache
    var cache;
    if (!(cache = dtf._parseRegExp)) {
        cache = dtf._parseRegExp = {};
    }
    // Return a cached format if available
    if (cache[format]) {
        return cache[format];
    }
    var expFormat = expandDateFormat(dtf, format);
    // eslint-disable-next-line no-useless-escape
    expFormat = expFormat.replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1");
    var regexp = new StringBuilder("^");
    var groups = [];
    var index = 0;
    var quoteCount = 0;
    var tokenRegExp = getDateTokenRegExp();
    var match;
    while ((match = tokenRegExp.exec(expFormat)) !== null) {
        var preMatch = expFormat.slice(index, match.index);
        index = tokenRegExp.lastIndex;
        quoteCount += date$appendPreOrPostMatch(preMatch, regexp);
        if ((quoteCount % 2) === 1) {
            regexp.append(match[0]);
            continue;
        }
        switch (match[0]) {
            case "dddd":
            case "ddd":
            case "MMMM":
            case "MMM":
            case "gg":
            case "g":
                regexp.append("(\\D+)");
                break;
            case "tt":
            case "t":
                regexp.append("(\\D*)");
                break;
            case "yyyy":
                regexp.append("(\\d{4})");
                break;
            case "fff":
                regexp.append("(\\d{3})");
                break;
            case "ff":
                regexp.append("(\\d{2})");
                break;
            case "f":
                regexp.append("(\\d)");
                break;
            case "dd":
            case "d":
            case "MM":
            case "M":
            case "yy":
            case "y":
            case "HH":
            case "H":
            case "hh":
            case "h":
            case "mm":
            case "m":
            case "ss":
            case "s":
                regexp.append("(\\d\\d?)");
                break;
            case "zzz":
                regexp.append("([+-]?\\d\\d?:\\d{2})");
                break;
            case "zz":
            case "z":
                regexp.append("([+-]?\\d\\d?)");
                break;
            case "/":
                regexp.append("(\\" + dtf.DateSeparator + ")");
                break;
        }
        groups.push(match[0]);
    }
    date$appendPreOrPostMatch(expFormat.slice(index), regexp);
    regexp.append("$");
    var regexpStr = regexp.toString().replace(/\s+/g, "\\s+");
    var parseRegExp = { regExp: regexpStr, groups: groups };
    cache[format] = parseRegExp;
    return parseRegExp;
}
;
function getDateTokenRegExp() {
    return /\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g;
}
/**
 * Parses the given text as a date
 * @param value The text to parse
 * @param cultureInfo The culture
 * @param formats An optional list of formats to use
 */
function parseDate(value, cultureInfo, formats) {
    var formatsSpecified = false;
    // Try to parse using format strings if specified
    if (formats) {
        for (var i = 0; i < formats.length; i++) {
            var format = formats[i];
            if (format) {
                formatsSpecified = true;
                var date = parseDateExact(value, format, cultureInfo);
                if (date)
                    return date;
            }
        }
    }
    // Use the culture's date/time formats if formats were not specified
    if (!formatsSpecified) {
        formats = cultureInfo._getDateTimeFormats();
        for (var i = 0; i < formats.length; i++) {
            var date = parseDateExact(value, formats[i], cultureInfo);
            if (date)
                return date;
        }
    }
    return null;
}
exports.parseDate = parseDate;
function parseDateExact(value, format, cultureInfo) {
    value = value.trim();
    var dtf = cultureInfo.dateTimeFormat;
    var parseInfo = getDateParseRegExp(dtf, format);
    var match = new RegExp(parseInfo.regExp).exec(value);
    if (match === null)
        return null;
    var groups = parseInfo.groups;
    var era = null;
    var year = null;
    var month = null;
    var date = null;
    var weekDay = null;
    var hour = 0;
    var hourOffset;
    var min = 0;
    var sec = 0;
    var msec = 0;
    var tzMinOffset = null;
    var pmHour = false;
    for (var j = 0, jl = groups.length; j < jl; j++) {
        var matchGroup = match[j + 1];
        if (matchGroup) {
            switch (groups[j]) {
                case "dd":
                case "d":
                    date = parseInt(matchGroup, 10);
                    if ((date < 1) || (date > 31))
                        return null;
                    break;
                case "MMMM":
                    month = cultureInfo._getMonthIndex(matchGroup);
                    if ((month < 0) || (month > 11))
                        return null;
                    break;
                case "MMM":
                    month = cultureInfo._getMonthIndex(matchGroup, true);
                    if ((month < 0) || (month > 11))
                        return null;
                    break;
                case "M":
                case "MM":
                    month = parseInt(matchGroup, 10) - 1;
                    if ((month < 0) || (month > 11))
                        return null;
                    break;
                case "y":
                case "yy":
                    year = expandYear(dtf, parseInt(matchGroup, 10));
                    if ((year < 0) || (year > 9999))
                        return null;
                    break;
                case "yyyy":
                    year = parseInt(matchGroup, 10);
                    if ((year < 0) || (year > 9999))
                        return null;
                    break;
                case "h":
                case "hh":
                    hour = parseInt(matchGroup, 10);
                    if (hour === 12)
                        hour = 0;
                    if ((hour < 0) || (hour > 11))
                        return null;
                    break;
                case "H":
                case "HH":
                    hour = parseInt(matchGroup, 10);
                    if ((hour < 0) || (hour > 23))
                        return null;
                    break;
                case "m":
                case "mm":
                    min = parseInt(matchGroup, 10);
                    if ((min < 0) || (min > 59))
                        return null;
                    break;
                case "s":
                case "ss":
                    sec = parseInt(matchGroup, 10);
                    if ((sec < 0) || (sec > 59))
                        return null;
                    break;
                case "tt":
                case "t":
                    var upperToken = matchGroup.toUpperCase();
                    pmHour = (upperToken === dtf.PMDesignator.toUpperCase());
                    if (!pmHour && (upperToken !== dtf.AMDesignator.toUpperCase()))
                        return null;
                    break;
                case "f":
                    msec = parseInt(matchGroup, 10) * 100;
                    if ((msec < 0) || (msec > 999))
                        return null;
                    break;
                case "ff":
                    msec = parseInt(matchGroup, 10) * 10;
                    if ((msec < 0) || (msec > 999))
                        return null;
                    break;
                case "fff":
                    msec = parseInt(matchGroup, 10);
                    if ((msec < 0) || (msec > 999))
                        return null;
                    break;
                case "dddd":
                    weekDay = cultureInfo._getDayIndex(matchGroup);
                    if ((weekDay < 0) || (weekDay > 6))
                        return null;
                    break;
                case "ddd":
                    weekDay = cultureInfo._getDayIndex(matchGroup, true);
                    if ((weekDay < 0) || (weekDay > 6))
                        return null;
                    break;
                case "zzz":
                    var offsets = matchGroup.split(/:/);
                    if (offsets.length !== 2)
                        return null;
                    hourOffset = parseInt(offsets[0], 10);
                    if ((hourOffset < -12) || (hourOffset > 13))
                        return null;
                    var minOffset = parseInt(offsets[1], 10);
                    if ((minOffset < 0) || (minOffset > 59))
                        return null;
                    tzMinOffset = (hourOffset * 60) + (matchGroup.startsWith("-") ? -minOffset : minOffset);
                    break;
                case "z":
                case "zz":
                    hourOffset = parseInt(matchGroup, 10);
                    if ((hourOffset < -12) || (hourOffset > 13))
                        return null;
                    tzMinOffset = hourOffset * 60;
                    break;
                case "g":
                case "gg":
                    var eraName = matchGroup;
                    if (!eraName || !dtf.Eras)
                        return null;
                    eraName = eraName.toLowerCase().trim();
                    for (var i = 0, l = dtf.Eras.length; i < l; i += 4) {
                        if (eraName === dtf.Eras[i + 1].toLowerCase()) {
                            era = i;
                            break;
                        }
                    }
                    if (era === null)
                        return null;
                    break;
            }
        }
    }
    var result = new Date();
    var defaultYear;
    var convert = dtf.Calendar.convert;
    // If none are specified, set to todays date to 1/1/1970
    if (year == null && month == null && date == null) {
        year = 1970;
        month = 0;
        date = 1;
    }
    else {
        if (convert) {
            defaultYear = convert.fromGregorian(result)[0];
        }
        else {
            defaultYear = result.getFullYear();
        }
        if (year === null) {
            year = defaultYear;
        }
        else if (dtf.Eras) {
            year += dtf.Eras[(era || 0) + 3];
        }
        if (month === null) {
            month = 0;
        }
        if (date === null) {
            date = 1;
        }
    }
    if (convert) {
        result = convert.toGregorian(year, month, date);
        if (result === null)
            return null;
    }
    else {
        result.setFullYear(year, month, date);
        if (result.getDate() !== date)
            return null;
        if ((weekDay !== null) && (result.getDay() !== weekDay)) {
            return null;
        }
    }
    if (pmHour && (hour < 12)) {
        hour += 12;
    }
    result.setHours(hour, min, sec, msec);
    if (tzMinOffset !== null) {
        var adjustedMin = result.getMinutes() - (tzMinOffset + result.getTimezoneOffset());
        result.setHours(result.getHours() + parseInt((adjustedMin / 60).toString(), 10), adjustedMin % 60);
    }
    return result;
}
function addLeadingZero(num) {
    if (num < 10) {
        return "0" + num;
    }
    return num.toString();
}
function addLeadingZeros(num) {
    if (num < 10) {
        return "00" + num;
    }
    if (num < 100) {
        return "0" + num;
    }
    return num.toString();
}
function padYear(year) {
    if (year < 10) {
        return "000" + year;
    }
    else if (year < 100) {
        return "00" + year;
    }
    else if (year < 1000) {
        return "0" + year;
    }
    return year.toString();
}
/**
 * Formats a date as text using the given format string and culture
 * @param date The date to format
 * @param format The format specifier
 * @param cultureInfo The culture
 */
function formatDate(date, format, cultureInfo) {
    if (!date)
        return null;
    var dtf = cultureInfo.dateTimeFormat;
    var convert = dtf.Calendar.convert;
    if (!format || !format.length || (format === "i")) {
        if (cultureInfo && cultureInfo.name.length) {
            if (convert) {
                return formatDate(date, dtf.FullDateTimePattern, cultureInfo);
            }
            else {
                var eraDate = new Date(date.getTime());
                var era = getEra(date, dtf.Eras);
                eraDate.setFullYear(getEraYear(date, dtf, era));
                return eraDate.toLocaleString();
            }
        }
        else {
            return date.toString();
        }
    }
    var eras = dtf.Eras;
    var sortable = (format === "s");
    format = expandDateFormat(dtf, format);
    var ret = new StringBuilder();
    var hour;
    var foundDay;
    var checkedDay;
    var dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g;
    var hasDay = function hasDay() {
        if (foundDay || checkedDay) {
            return foundDay;
        }
        foundDay = dayPartRegExp.test(format);
        checkedDay = true;
        return foundDay;
    };
    var quoteCount = 0;
    var tokenRegExp = getDateTokenRegExp();
    var converted;
    if (!sortable && convert) {
        converted = convert.fromGregorian(date);
    }
    for (;;) {
        var index = tokenRegExp.lastIndex;
        var ar = tokenRegExp.exec(format);
        var preMatch = format.slice(index, ar ? ar.index : format.length);
        quoteCount += date$appendPreOrPostMatch(preMatch, ret);
        if (!ar)
            break;
        if ((quoteCount % 2) === 1) {
            ret.append(ar[0]);
            continue;
        }
        var getDatePart = function getDatePart(date, part) {
            if (converted) {
                return converted[part];
            }
            switch (part) {
                case 0: return date.getFullYear();
                case 1: return date.getMonth();
                case 2: return date.getDate();
            }
        };
        switch (ar[0]) {
            case "dddd":
                ret.append(dtf.DayNames[date.getDay()]);
                break;
            case "ddd":
                ret.append(dtf.AbbreviatedDayNames[date.getDay()]);
                break;
            case "dd":
                foundDay = true;
                ret.append(addLeadingZero(getDatePart(date, 2)));
                break;
            case "d":
                foundDay = true;
                ret.append(getDatePart(date, 2).toString());
                break;
            case "MMMM":
                ret.append((dtf.MonthGenitiveNames && hasDay())
                    ? dtf.MonthGenitiveNames[getDatePart(date, 1)]
                    : dtf.MonthNames[getDatePart(date, 1)]);
                break;
            case "MMM":
                ret.append((dtf.AbbreviatedMonthGenitiveNames && hasDay())
                    ? dtf.AbbreviatedMonthGenitiveNames[getDatePart(date, 1)]
                    : dtf.AbbreviatedMonthNames[getDatePart(date, 1)]);
                break;
            case "MM":
                ret.append(addLeadingZero(getDatePart(date, 1) + 1));
                break;
            case "M":
                ret.append((getDatePart(date, 1) + 1).toString());
                break;
            case "yyyy":
                ret.append(padYear(converted ? converted[0] : getEraYear(date, dtf, getEra(date, eras), sortable)));
                break;
            case "yy":
                ret.append(addLeadingZero((converted ? converted[0] : getEraYear(date, dtf, getEra(date, eras), sortable)) % 100));
                break;
            case "y":
                ret.append(((converted ? converted[0] : getEraYear(date, dtf, getEra(date, eras), sortable)) % 100).toString());
                break;
            case "hh":
                hour = date.getHours() % 12;
                if (hour === 0)
                    hour = 12;
                ret.append(addLeadingZero(hour));
                break;
            case "h":
                hour = date.getHours() % 12;
                if (hour === 0)
                    hour = 12;
                ret.append(hour.toString());
                break;
            case "HH":
                ret.append(addLeadingZero(date.getHours()));
                break;
            case "H":
                ret.append(date.getHours().toString());
                break;
            case "mm":
                ret.append(addLeadingZero(date.getMinutes()));
                break;
            case "m":
                ret.append(date.getMinutes().toString());
                break;
            case "ss":
                ret.append(addLeadingZero(date.getSeconds()));
                break;
            case "s":
                ret.append(date.getSeconds().toString());
                break;
            case "tt":
                ret.append((date.getHours() < 12) ? dtf.AMDesignator : dtf.PMDesignator);
                break;
            case "t":
                ret.append(((date.getHours() < 12) ? dtf.AMDesignator : dtf.PMDesignator).charAt(0));
                break;
            case "f":
                ret.append(addLeadingZeros(date.getMilliseconds()).charAt(0));
                break;
            case "ff":
                ret.append(addLeadingZeros(date.getMilliseconds()).substr(0, 2));
                break;
            case "fff":
                ret.append(addLeadingZeros(date.getMilliseconds()));
                break;
            case "z":
                hour = date.getTimezoneOffset() / 60;
                ret.append(((hour <= 0) ? "+" : "-") + Math.floor(Math.abs(hour)));
                break;
            case "zz":
                hour = date.getTimezoneOffset() / 60;
                ret.append(((hour <= 0) ? "+" : "-") + addLeadingZero(Math.floor(Math.abs(hour))));
                break;
            case "zzz":
                hour = date.getTimezoneOffset() / 60;
                ret.append(((hour <= 0) ? "+" : "-") + addLeadingZero(Math.floor(Math.abs(hour))) +
                    ":" + addLeadingZero(Math.abs(date.getTimezoneOffset() % 60)));
                break;
            case "g":
            case "gg":
                if (dtf.Eras) {
                    ret.append(dtf.Eras[getEra(date, eras) + 1]);
                }
                break;
            case "/":
                ret.append(dtf.DateSeparator);
                break;
        }
    }
    return ret.toString();
}
exports.formatDate = formatDate;
function getNumberStyle(format) {
    format = format || "";
    if (format.match(/[$c]+/i))
        return "Currency";
    if (format.match(/[%p]+/i))
        return "Percent";
    if (format.match(/[dnfg]0/i))
        return "Integer";
    return "Number";
}
exports.getNumberStyle = getNumberStyle;
function parseNumber(value, style, cultureInfo) {
    // Handle use of () to denote negative numbers
    var sign = 1;
    if (value.match(/^\(.*\)$/)) {
        value = value.substring(1, value.length - 1);
        sign = -1;
    }
    var result;
    // Remove currency symbols before parsing
    if (style === "Currency") {
        result = _parseNumber(value.replace(cultureInfo.numberFormat.CurrencySymbol, ""), cultureInfo) * sign;
        // if there is a decimal place, check the precision isnt greater than allowed for currency.
        // Floating points in js can be skewed under certain circumstances, we are just checking the decimals instead of multiplying results.
        var resultvalue = result.toString();
        if (resultvalue.indexOf(".") > -1 && (resultvalue.length - (resultvalue.indexOf(".") + 1)) > cultureInfo.numberFormat.CurrencyDecimalDigits) {
            result = NaN;
        }
    }
    // Remove percentage symbols before parsing and divide by 100
    else if (style === "Percent")
        result = _parseNumber(value.replace(cultureInfo.numberFormat.PercentSymbol, ""), cultureInfo) / 100 * sign;
    // Ensure integers are actual whole numbers
    else if (style === "Integer" && !isInteger(_parseNumber(value, cultureInfo)))
        result = NaN;
    // Just parse a simple number
    else
        result = _parseNumber(value, cultureInfo) * sign;
    return result;
}
exports.parseNumber = parseNumber;
function isInteger(obj) {
    return typeof (obj) === "number" && !isNaN(obj) && /^-?[0-9]{1,10}$/.test(obj.toString()) && (obj >= -2147483648 && obj <= 2147483647);
}
/**
 * Parses the given text as a number
 * @param value The text to parse
 * @param cultureInfo The culture
 */
function _parseNumber(value, cultureInfo) {
    value = value.trim();
    if (value.match(/^[+-]?infinity$/i)) {
        return parseFloat(value);
    }
    if (value.match(/^0x[a-f0-9]+$/i)) {
        return parseInt(value);
    }
    var numFormat = cultureInfo.numberFormat;
    var signInfo = parseNumberNegativePattern(value, numFormat, numFormat.NumberNegativePattern);
    var sign = signInfo[0];
    var num = signInfo[1];
    if ((sign === "") && (numFormat.NumberNegativePattern !== 1)) {
        signInfo = parseNumberNegativePattern(value, numFormat, 1);
        sign = signInfo[0];
        num = signInfo[1];
    }
    if (sign === "")
        sign = "+";
    var exponent;
    var intAndFraction;
    var exponentPos = num.indexOf("e");
    if (exponentPos < 0)
        exponentPos = num.indexOf("E");
    if (exponentPos < 0) {
        intAndFraction = num;
        exponent = null;
    }
    else {
        intAndFraction = num.substr(0, exponentPos);
        exponent = num.substr(exponentPos + 1);
    }
    var integer;
    var fraction;
    var decimalPos = intAndFraction.indexOf(numFormat.NumberDecimalSeparator);
    if (decimalPos < 0) {
        integer = intAndFraction;
        fraction = null;
    }
    else {
        integer = intAndFraction.substr(0, decimalPos);
        fraction = intAndFraction.substr(decimalPos + numFormat.NumberDecimalSeparator.length);
    }
    integer = integer.split(numFormat.NumberGroupSeparator).join("");
    var altNumGroupSeparator = numFormat.NumberGroupSeparator.replace(/\u00A0/g, " ");
    if (numFormat.NumberGroupSeparator !== altNumGroupSeparator) {
        integer = integer.split(altNumGroupSeparator).join("");
    }
    var p = sign + integer;
    if (fraction !== null) {
        p += "." + fraction;
    }
    if (exponent !== null) {
        var expSignInfo = parseNumberNegativePattern(exponent, numFormat, 1);
        if (expSignInfo[0] === "") {
            expSignInfo[0] = "+";
        }
        p += "e" + expSignInfo[0] + expSignInfo[1];
    }
    if (p.match(/^[+-]?\d*\.?\d*(e[+-]?\d+)?$/)) {
        return parseFloat(p);
    }
    return Number.NaN;
}
exports._parseNumber = _parseNumber;
;
function parseNumberNegativePattern(value, numberFormatInfo, numberNegativePattern) {
    var neg = numberFormatInfo.NegativeSign;
    var pos = numberFormatInfo.PositiveSign;
    switch (numberNegativePattern) {
        case 4:
            neg = " " + neg;
            pos = " " + pos;
        // eslint-disable-next-line no-fallthrough
        case 3:
            if (value.endsWith(neg)) {
                return ["-", value.substr(0, value.length - neg.length)];
            }
            else if (value.endsWith(pos)) {
                return ["+", value.substr(0, value.length - pos.length)];
            }
            break;
        case 2:
            neg += " ";
            pos += " ";
        // eslint-disable-next-line no-fallthrough
        case 1:
            if (value.startsWith(neg)) {
                return ["-", value.substr(neg.length)];
            }
            else if (value.startsWith(pos)) {
                return ["+", value.substr(pos.length)];
            }
            break;
        case 0:
            if (value.startsWith("(") && value.endsWith(")")) {
                return ["-", value.substr(1, value.length - 2)];
            }
            break;
    }
    return ["", value];
}
;
function zeroPad(str, count, left) {
    for (var l = str.length; l < count; l++) {
        str = (left ? ("0" + str) : (str + "0"));
    }
    return str;
}
function expandNumber(number, precision, groupSizes, sep, decimalChar) {
    var curSize = groupSizes[0];
    var curGroupIndex = 1;
    var factor = Math.pow(10, precision);
    var rounded = (Math.round(number * factor) / factor);
    if (!isFinite(rounded)) {
        rounded = number;
    }
    number = rounded;
    var numberString = number.toString();
    var right = "";
    var exponent;
    var split = numberString.split(/e/i);
    numberString = split[0];
    exponent = (split.length > 1 ? parseInt(split[1]) : 0);
    split = numberString.split(".");
    numberString = split[0];
    right = split.length > 1 ? split[1] : "";
    if (exponent > 0) {
        right = zeroPad(right, exponent, false);
        numberString += right.slice(0, exponent);
        right = right.substr(exponent);
    }
    else if (exponent < 0) {
        exponent = -exponent;
        numberString = zeroPad(numberString, exponent + 1, true);
        right = numberString.slice(-exponent, numberString.length) + right;
        numberString = numberString.slice(0, -exponent);
    }
    if (precision > 0) {
        if (right.length > precision) {
            right = right.slice(0, precision);
        }
        else {
            right = zeroPad(right, precision, false);
        }
        right = decimalChar + right;
    }
    else {
        right = "";
    }
    var stringIndex = numberString.length - 1;
    var ret = "";
    while (stringIndex >= 0) {
        if (curSize === 0 || curSize > stringIndex) {
            if (ret.length > 0)
                return numberString.slice(0, stringIndex + 1) + sep + ret + right;
            else
                return numberString.slice(0, stringIndex + 1) + right;
        }
        if (ret.length > 0)
            ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1) + sep + ret;
        else
            ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1);
        stringIndex -= curSize;
        if (curGroupIndex < groupSizes.length) {
            curSize = groupSizes[curGroupIndex];
            curGroupIndex++;
        }
    }
    return numberString.slice(0, stringIndex + 1) + sep + ret + right;
}
/**
 * Formats a number as text using the given format string and culture
 * @param number The number to format
 * @param format The format specifier
 * @param cultureInfo The culture
 */
function formatNumber(number, format, cultureInfo) {
    if (typeof number !== "number" || isNaN(number))
        return null;
    if (!format || (format.length === 0) || (format === "i")) {
        if (cultureInfo && (cultureInfo.name.length > 0)) {
            return number.toLocaleString();
        }
        else {
            return number.toString();
        }
    }
    var _percentPositivePattern = ["n %", "n%", "%n"];
    var _percentNegativePattern = ["-n %", "-n%", "-%n"];
    var _numberNegativePattern = ["(n)", "-n", "- n", "n-", "n -"];
    var _currencyPositivePattern = ["$n", "n$", "$ n", "n $"];
    var _currencyNegativePattern = ["($n)", "-$n", "$-n", "$n-", "(n$)", "-n$", "n-$", "n$-", "-n $", "-$ n", "n $-", "$ n-", "$ -n", "n- $", "($ n)", "(n $)"];
    var nf = cultureInfo.numberFormat;
    var num = Math.abs(number);
    if (!format)
        format = "D";
    var precision = -1;
    if (format.length > 1)
        precision = parseInt(format.slice(1), 10);
    var pattern;
    switch (format.charAt(0)) {
        case "d":
        case "D":
            pattern = "n";
            if (precision !== -1) {
                num = zeroPad("" + num, precision, true);
            }
            if (number < 0)
                num = -num;
            break;
        case "c":
        case "C":
            if (number < 0)
                pattern = _currencyNegativePattern[nf.CurrencyNegativePattern];
            else
                pattern = _currencyPositivePattern[nf.CurrencyPositivePattern];
            if (precision === -1)
                precision = nf.CurrencyDecimalDigits;
            num = expandNumber(Math.abs(number), precision, nf.CurrencyGroupSizes, nf.CurrencyGroupSeparator, nf.CurrencyDecimalSeparator);
            break;
        case "n":
        case "N":
            if (number < 0)
                pattern = _numberNegativePattern[nf.NumberNegativePattern];
            else
                pattern = "n";
            if (precision === -1)
                precision = nf.NumberDecimalDigits;
            num = expandNumber(Math.abs(number), precision, nf.NumberGroupSizes, nf.NumberGroupSeparator, nf.NumberDecimalSeparator);
            break;
        case "p":
        case "P":
            if (number < 0)
                pattern = _percentNegativePattern[nf.PercentNegativePattern];
            else
                pattern = _percentPositivePattern[nf.PercentPositivePattern];
            if (precision === -1)
                precision = nf.PercentDecimalDigits;
            num = expandNumber(Math.abs(number) * 100, precision, nf.PercentGroupSizes, nf.PercentGroupSeparator, nf.PercentDecimalSeparator);
            break;
        default:
            throw new FormatError(Res.formatBadFormatSpecifier);
    }
    var regex = /n|\$|-|%/g;
    var ret = "";
    for (;;) {
        var index = regex.lastIndex;
        var ar = regex.exec(pattern);
        ret += pattern.slice(index, ar ? ar.index : pattern.length);
        if (!ar)
            break;
        switch (ar[0]) {
            case "n":
                ret += num;
                break;
            case "$":
                ret += nf.CurrencySymbol;
                break;
            case "-":
                if (/[1-9]/.test(num.toString())) {
                    ret += nf.NegativeSign;
                }
                break;
            case "%":
                ret += nf.PercentSymbol;
                break;
        }
    }
    return ret;
}
exports.formatNumber = formatNumber;
function toUpper(value) {
    return value.split("\u00A0").join(" ").toUpperCase();
}
function toUpperArray(arr) {
    var result = [];
    for (var i = 0; i < arr.length; i++) {
        var value = arr[i];
        result[i] = toUpper(value);
    }
    return result;
}
var invariantCultureInfo = {
    name: "",
    numberFormat: {
        CurrencyDecimalDigits: 2,
        CurrencyDecimalSeparator: ".",
        CurrencyGroupSizes: [3],
        NumberGroupSizes: [3],
        PercentGroupSizes: [3],
        CurrencyGroupSeparator: ",",
        CurrencySymbol: "\u00A4",
        NaNSymbol: "NaN",
        CurrencyNegativePattern: 0,
        NumberNegativePattern: 1,
        PercentPositivePattern: 0,
        PercentNegativePattern: 0,
        NegativeInfinitySymbol: "-Infinity",
        NegativeSign: "-",
        NumberDecimalDigits: 2,
        NumberDecimalSeparator: ".",
        NumberGroupSeparator: ",",
        CurrencyPositivePattern: 0,
        PositiveInfinitySymbol: "Infinity",
        PositiveSign: "+",
        PercentDecimalDigits: 2,
        PercentDecimalSeparator: ".",
        PercentGroupSeparator: ",",
        PercentSymbol: "%",
        PerMilleSymbol: "\u2030",
        NativeDigits: ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
        DigitSubstitution: 1
    },
    dateTimeFormat: {
        AMDesignator: "AM",
        Calendar: { MinSupportedDateTime: "@-62135568000000@", MaxSupportedDateTime: "@253402300799999@", AlgorithmType: 1, CalendarType: 1, Eras: [1], TwoDigitYearMax: 2029 },
        DateSeparator: "/",
        FirstDayOfWeek: 0,
        CalendarWeekRule: 0,
        FullDateTimePattern: "dddd, dd MMMM yyyy HH:mm:ss",
        LongDatePattern: "dddd, dd MMMM yyyy",
        LongTimePattern: "HH:mm:ss",
        MonthDayPattern: "MMMM dd",
        PMDesignator: "PM",
        RFC1123Pattern: "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'",
        ShortDatePattern: "MM/dd/yyyy",
        ShortTimePattern: "h:mm tt",
        SortableDateTimePattern: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
        TimeSeparator: ":",
        UniversalSortableDateTimePattern: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
        YearMonthPattern: "yyyy MMMM",
        AbbreviatedDayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        ShortestDayNames: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        DayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        AbbreviatedMonthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""],
        MonthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
        NativeCalendarName: "Gregorian Calendar",
        AbbreviatedMonthGenitiveNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""],
        MonthGenitiveNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""]
    },
    eras: [1, "A.D.", null, 0]
};
var CultureInfo = /** @class */ (function () {
    function CultureInfo(name, numberFormat, dateTimeFormat) {
        this.name = name;
        this.numberFormat = numberFormat;
        this.dateTimeFormat = dateTimeFormat;
    }
    CultureInfo.parse = function (value) {
        var dtf = value.dateTimeFormat;
        if (dtf && !dtf.Eras) {
            dtf.Eras = value.eras;
        }
        return new CultureInfo(value.name, value.numberFormat, dtf);
    };
    CultureInfo.setup = function (cultureInfo) {
        if (cultureInfo === void 0) { cultureInfo = null; }
        if (cultureInfo != null && typeof cultureInfo === "object") {
            CultureInfo.CurrentCulture = CultureInfo.parse(cultureInfo);
        }
        else if (!CultureInfo.CurrentCulture) {
            // Set up default culture
            var defaultCulture = CultureInfo._defaultCulture;
            if (!CultureInfo._defaultCulture) {
                var cultureInfoObject = helpers_1.clone(invariantCultureInfo);
                cultureInfoObject.name = "en-US";
                cultureInfoObject.numberFormat.CurrencySymbol = "$";
                var dtf = cultureInfoObject.dateTimeFormat;
                dtf.FullDateTimePattern = "dddd, MMMM dd, yyyy h:mm:ss tt";
                dtf.LongDatePattern = "dddd, MMMM dd, yyyy";
                dtf.LongTimePattern = "h:mm:ss tt";
                dtf.ShortDatePattern = "M/d/yyyy";
                dtf.ShortTimePattern = "h:mm tt";
                dtf.YearMonthPattern = "MMMM, yyyy";
                defaultCulture = CultureInfo.parse(cultureInfoObject);
                CultureInfo._defaultCulture = defaultCulture;
            }
            CultureInfo.CurrentCulture = defaultCulture;
        }
    };
    CultureInfo.prototype._getDateTimeFormats = function () {
        var formats = this._dateTimeFormats;
        if (!formats) {
            var dtf = this.dateTimeFormat;
            this._dateTimeFormats = formats = [
                dtf["MonthDayPattern"],
                dtf["YearMonthPattern"],
                dtf["ShortDatePattern"],
                dtf["ShortTimePattern"],
                dtf["LongDatePattern"],
                dtf["LongTimePattern"],
                dtf["FullDateTimePattern"],
                dtf["RFC1123Pattern"],
                dtf["SortableDateTimePattern"],
                dtf["UniversalSortableDateTimePattern"]
            ];
        }
        return formats;
    };
    CultureInfo.prototype._getMonthIndex = function (value, abbr) {
        // Get or create the cache of upper-case month names
        var upperMonths = abbr ? this._upperAbbrMonths : this._upperMonths;
        if (!upperMonths) {
            if (abbr)
                upperMonths = this._upperAbbrMonths = toUpperArray(this.dateTimeFormat.AbbreviatedMonthNames);
            else
                upperMonths = this._upperMonths = toUpperArray(this.dateTimeFormat.MonthNames);
        }
        // Convert the month name to upper-case and get its index in the list
        value = toUpper(value);
        var i = upperMonths.indexOf(value);
        if (i < 0) {
            // Get or create the cache of upper-case genitive month names
            var upperMonthsGenitive = abbr ? this._upperAbbrMonthsGenitive : this._upperMonthsGenitive;
            if (!upperMonthsGenitive) {
                if (abbr)
                    upperMonthsGenitive = this._upperAbbrMonthsGenitive = toUpperArray(this.dateTimeFormat.AbbreviatedMonthGenitiveNames);
                else
                    upperMonthsGenitive = this._upperMonthsGenitive = toUpperArray(this.dateTimeFormat.MonthGenitiveNames);
            }
            // Check the list of genitive month names
            i = upperMonthsGenitive.indexOf(value);
        }
        return i;
    };
    CultureInfo.prototype._getDayIndex = function (value, abbr) {
        // Get or create the cache of upper-case day names
        var upperDays = abbr ? this._upperAbbrDays : this._upperDays;
        if (!upperDays) {
            if (abbr)
                upperDays = this._upperAbbrDays = toUpperArray(this.dateTimeFormat.AbbreviatedDayNames);
            else
                upperDays = this._upperDays = toUpperArray(this.dateTimeFormat.DayNames);
        }
        // Convert the day name to upper-case and get its index in the list
        value = toUpper(value);
        return upperDays.indexOf(value);
    };
    return CultureInfo;
}());
exports.CultureInfo = CultureInfo;
CultureInfo.InvariantCulture = CultureInfo.parse(invariantCultureInfo);


/***/ }),

/***/ "../../libs/model.js/lib/helpers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.entries = exports.flatMap = exports.clone = exports.mixin = exports.getEventSubscriptions = exports.merge = exports.hasOwnProperty = exports.toTitleCase = exports.randomText = exports.randomInt = exports.isType = exports.getDefaultValue = exports.isNumber = exports.getConstructorName = exports.getTypeName = exports.parseFunctionName = exports.replaceTokens = exports.evalPath = exports.navigateAttribute = exports.ensureNamespace = exports.getGlobalObject = void 0;
function getGlobalObject() {
    if (typeof window === "object" && Object.prototype.toString.call(window) === "[object Window]") {
        return window;
    }
    else if (typeof global === "object") {
        return global;
    }
    else {
        return null;
    }
}
exports.getGlobalObject = getGlobalObject;
function ensureNamespace(name, parentNamespace) {
    var result;
    var nsTokens;
    var target = parentNamespace;
    if (typeof target === "string") {
        nsTokens = target.split(".");
        target = getGlobalObject();
        nsTokens.forEach(function (token) {
            target = target[token];
            if (target === undefined) {
                throw new Error("Parent namespace \"" + parentNamespace + "\" could not be found.");
            }
        });
    }
    else if (target === undefined || target === null) {
        target = getGlobalObject();
    }
    // create the namespace object if it doesn't exist, otherwise return the existing namespace
    if (!(name in target)) {
        result = target[name] = {};
        return result;
    }
    else {
        return target[name];
    }
}
exports.ensureNamespace = ensureNamespace;
function navigateAttribute(obj, attr, callback, thisPtr) {
    if (thisPtr === void 0) { thisPtr = null; }
    for (var val = obj[attr]; val != null; val = val[attr]) {
        if (callback.call(thisPtr || obj, val) === false) {
            return;
        }
    }
}
exports.navigateAttribute = navigateAttribute;
function isObject(obj) {
    return getTypeName(obj) === "object" || (obj && obj instanceof Object);
}
// If a getter method matching the given property name is found on the target it is invoked and returns the
// value, unless the the value is undefined, in which case null is returned instead.  This is done so that
// calling code can interpret a return value of undefined to mean that the property it requested does not exist.
function getValue(target, property) {
    var value;
    // the see if there is an explicit getter function for the property
    var getter = target["get_" + property];
    if (getter) {
        value = getter.call(target);
        if (value === undefined) {
            value = null;
        }
    }
    // otherwise search for the property
    else {
        if ((isObject(target) && property in target) ||
            Object.prototype.hasOwnProperty.call(target, property) ||
            (target.constructor === String && /^[0-9]+$/.test(property) && parseInt(property, 10) < target.length)) {
            value = target[property];
            if (value === undefined) {
                value = null;
            }
        }
        else if (/\./.test(property)) {
            // TODO: Warn about passing multi-hop path to `getValue()`
            // logWarning("Possible incorrect usage of \"getValue()\", the path \"" + property + "\" does not exist on the target and appears to represent a multi-hop path.");
        }
    }
    return value;
}
function evalPath(obj, path, nullValue, undefinedValue) {
    if (nullValue === void 0) { nullValue = null; }
    if (undefinedValue === void 0) { undefinedValue = undefined; }
    var value = obj;
    var steps = path.split(".");
    for (var i = 0; i < steps.length; ++i) {
        var name_1 = steps[i];
        var source = value;
        value = getValue(source, name_1);
        if (value === null) {
            return nullValue;
        }
        if (value === undefined) {
            return undefinedValue;
        }
    }
    return value;
}
exports.evalPath = evalPath;
/**
 * Replace tokens (ex: {0}) in the given string
 * @param template The template string
 * @param params The replacement parameters
 */
function replaceTokens(template, params) {
    if (params) {
        return template.replace(/{([^}]+)}/g, function (match, key) {
            return hasOwnProperty(params, key) ? params[key] : match;
        });
    }
    return template;
}
exports.replaceTokens = replaceTokens;
var fnRegex = /function\s*([\w_$]*)/i;
function parseFunctionName(fn) {
    var fnMatch = fnRegex.exec(fn.toString());
    return fnMatch ? (fnMatch[1] || "{anonymous}") : "{anonymous}";
}
exports.parseFunctionName = parseFunctionName;
var typeNameExpr = /\s([a-z|A-Z]+)/;
function getTypeName(obj) {
    if (obj === undefined)
        return "undefined";
    if (obj === null)
        return "null";
    return Object.prototype.toString.call(obj).match(typeNameExpr)[1].toLowerCase();
}
exports.getTypeName = getTypeName;
function getConstructorName(ctor) {
    // Handle value types explicitly
    if (ctor === String)
        return "String";
    if (ctor === Number)
        return "Number";
    if (ctor === Date)
        return "Date";
    if (ctor === Boolean)
        return "Boolean";
    // Try to use function name
    if (typeof ctor === "function" && ctor.name) {
        return ctor.name;
    }
    // Fall back to the low-level 'toString' on the prototype
    return getTypeName(ctor.prototype);
}
exports.getConstructorName = getConstructorName;
function isNumber(obj) {
    return getTypeName(obj) === "number" && !isNaN(obj);
}
exports.isNumber = isNumber;
function getDefaultValue(isList, jstype) {
    if (isList)
        return [];
    if (jstype === Boolean)
        return false;
    if (jstype === Number)
        return 0;
    return null;
}
exports.getDefaultValue = getDefaultValue;
function isType(obj, test) {
    if (test === void 0) { test = null; }
    if (test) {
        return test(obj);
    }
    else {
        // Do nothing, assume object is of the type
        return true;
    }
}
exports.isType = isType;
function randomInt(min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 9; }
    var rand = Math.random();
    return rand === 1 ? max : Math.floor(rand * (max - min + 1)) + min;
}
exports.randomInt = randomInt;
function randomText(len, includeLetters, includeDigits) {
    if (includeLetters === void 0) { includeLetters = true; }
    if (includeDigits === void 0) { includeDigits = true; }
    if (!includeLetters && !includeDigits) {
        return;
    }
    var result = "";
    for (var i = 0; i < len; i++) {
        var min = includeLetters ? 0 : 26;
        var max = includeDigits ? 35 : 25;
        var rand = randomInt(min, max);
        var charCode;
        if (rand <= 25) {
            // Alpha: add 97 for 'a'
            charCode = rand + 97;
        }
        else {
            // Num: start at 0 and add 48 for 0
            charCode = (rand - 26) + 48;
        }
        result += String.fromCharCode(charCode);
    }
    return result;
}
exports.randomText = randomText;
function toTitleCase(input) {
    // https://stackoverflow.com/questions/196972/convert-string-to-title-case-with-javascript/6475125#6475125
    var i, j, str, lowers, uppers;
    str = input.replace(/([^\W_]+[^\s-]*) */g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
    // Certain minor words should be left lowercase unless
    // they are the first or last words in the string
    lowers = ["A", "An", "The", "And", "But", "Or", "For", "Nor", "As", "At",
        "By", "For", "From", "In", "Into", "Near", "Of", "On", "Onto",
        "To", "With"];
    for (i = 0, j = lowers.length; i < j; i++) {
        str = str.replace(new RegExp("\\s" + lowers[i] + "\\s", "g"), function (txt) {
            return txt.toLowerCase();
        });
    }
    // Certain words such as initialisms or acronyms should be left uppercase
    uppers = ["Id", "Tv"];
    for (i = 0, j = uppers.length; i < j; i++) {
        str = str.replace(new RegExp("\\b" + uppers[i] + "\\b", "g"), uppers[i].toUpperCase());
    }
    return str;
}
exports.toTitleCase = toTitleCase;
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
exports.hasOwnProperty = hasOwnProperty;
function merge(obj1) {
    var objs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objs[_i - 1] = arguments[_i];
    }
    var target = {};
    for (var arg in obj1) {
        if (hasOwnProperty(obj1, arg)) {
            target[arg] = obj1[arg];
        }
    }
    for (var i = 0; i < objs.length; i++) {
        var obj = objs[i];
        for (var arg in obj) {
            if (hasOwnProperty(obj, arg)) {
                target[arg] = obj[arg];
            }
        }
    }
    return target;
}
exports.merge = merge;
function getEventSubscriptions(event) {
    var func = event.func;
    if (func) {
        var funcs = func._funcs;
        if (funcs.length > 0) {
            var subs = funcs.map(function (f) { return { handler: f.fn, isExecuted: f.applied, isOnce: f.once }; });
            return subs;
        }
        else {
            return null;
        }
    }
}
exports.getEventSubscriptions = getEventSubscriptions;
function mixin(ctor, methods) {
    for (var key in methods) {
        if (hasOwnProperty(methods, key) && methods[key] instanceof Function) {
            ctor.prototype[key] = methods[key];
        }
    }
}
exports.mixin = mixin;
/**
 * Recursively clone an object and its children
 * @param value The object to clone
 */
function clone(obj) {
    var result = {};
    for (var prop in obj) {
        if (hasOwnProperty(obj, prop)) {
            var value = obj[prop];
            result[prop] = value instanceof Array ? (value.length === 1 ? [value[0]] : Array.apply(null, value)) : typeof value === "object" ? clone(value) : value;
        }
    }
    return result;
}
exports.clone = clone;
/**
 * Helper alternative to Array.prototype.flatMap
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap#Alternative
 * @param input The input array
 * @param callback A function that returns an array of outputs for each input
 */
function flatMap(input, callback) {
    return input.reduce(function (arr, i) { return arr.concat(callback(i)); }, []);
}
exports.flatMap = flatMap;
/**
 * Helper alternative to Object.entries
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries#Polyfill
 * @param input The input array
 */
function entries(obj) {
    // eslint-disable-next-line one-var
    var ownProps = Object.keys(obj), i = ownProps.length, resArray = new Array(i); // preallocate the Array
    while (i--)
        resArray[i] = [ownProps[i], obj[ownProps[i]]];
    return resArray;
}
exports.entries = entries;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../../node_modules/.pnpm/webpack@4.46.0_webpack-cli@3.3.12/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../libs/model.js/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
// Core model
__exportStar(__webpack_require__("../../libs/model.js/lib/model.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/type.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/property.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/property-chain.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/property-path.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/entity.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/object-meta.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/format.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/observable-array.js"), exports);
// Conditions, etc.
__exportStar(__webpack_require__("../../libs/model.js/lib/condition-target.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/condition-type-set.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/condition-type.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/condition.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/format-error.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/string-format-rule.js"), exports);
// Rules engine and various rule types
__exportStar(__webpack_require__("../../libs/model.js/lib/rule.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/rule-invocation-type.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/condition-rule.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/validation-rule.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/allowed-values-rule.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/calculated-property-rule.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/required-rule.js"), exports);
// Serialization
__exportStar(__webpack_require__("../../libs/model.js/lib/entity-serializer.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/initilization-context.js"), exports);
// Globalization & Localization
__exportStar(__webpack_require__("../../libs/model.js/lib/globalization.js"), exports);
__exportStar(__webpack_require__("../../libs/model.js/lib/resource.js"), exports);
// Internal helpers, etc.
// export * from "./event-scope";
// export * from "./events";
// export * from "./functor";
// export * from "./helpers";


/***/ }),

/***/ "../../libs/model.js/lib/initilization-context.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InitializationContext = void 0;
var InitializationContext = /** @class */ (function () {
    function InitializationContext(newDocument) {
        this.newDocument = false;
        this.tasks = new Set();
        this.waiting = [];
        this.newDocument = newDocument;
    }
    /**
     * Prevents any waiting callbacks from being executed before the specified action completes.
     * @returns The return value of `action`.
     */
    InitializationContext.prototype.execute = function (action) {
        // create a promise which will never actually be resolved, but it will prevent the waiting queue from being processed
        var marker = new Promise(function () { });
        this.tasks.add(marker);
        var result = action();
        this.tasks.delete(marker);
        this.processWaitingQueue();
        return result;
    };
    InitializationContext.prototype.wait = function (task) {
        var _this = this;
        this.tasks.add(task);
        task.then(function () {
            // process the queue asynchronously to allow additional tasks to be queued as a result of this one
            Promise.resolve().then(function () {
                _this.tasks.delete(task);
                _this.processWaitingQueue();
            });
        });
    };
    Object.defineProperty(InitializationContext.prototype, "canProcessQueue", {
        get: function () {
            return this.tasks.size === 0;
        },
        enumerable: false,
        configurable: true
    });
    InitializationContext.prototype.processWaitingQueue = function () {
        if (this.canProcessQueue) {
            while (this.waiting.length > 0 && this.canProcessQueue) {
                var done = this.waiting.shift();
                done();
            }
        }
    };
    InitializationContext.prototype.whenReady = function (callback) {
        if (this.canProcessQueue)
            callback();
        else
            this.waiting.push(callback);
    };
    InitializationContext.prototype.tryResolveValue = function (instance, property, value) {
        var task = instance.serializer.resolveValue(instance, property, value);
        if (task)
            this.wait(task);
        return task;
    };
    Object.defineProperty(InitializationContext.prototype, "isNewDocument", {
        get: function () {
            return this.newDocument;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(InitializationContext.prototype, "ready", {
        get: function () {
            var _this = this;
            return new Promise(function (resolve) { return _this.whenReady(resolve); });
        },
        enumerable: false,
        configurable: true
    });
    return InitializationContext;
}());
exports.InitializationContext = InitializationContext;


/***/ }),

/***/ "../../libs/model.js/lib/list-length-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListLengthRule = void 0;
var validation_rule_1 = __webpack_require__("../../libs/model.js/lib/validation-rule.js");
var ListLengthRule = /** @class */ (function (_super) {
    __extends(ListLengthRule, _super);
    function ListLengthRule(rootType, options) {
        var _this = this;
        // ensure the rule name is specified
        options.name = options.name || "ListLength";
        options.message = function () {
            var range = {};
            if (options.min && options.min instanceof Function) {
                try {
                    range.min = options.min.call(this);
                }
                catch (e) {
                    // Silently ignore min errors
                }
            }
            else if (typeof (options.min) === "number") {
                range.min = options.min;
            }
            if (options.max && options.max instanceof Function) {
                try {
                    range.max = options.max.call(this);
                }
                catch (e) {
                    // Silently ignore max errors
                }
            }
            else if (typeof (options.min) === "number") {
                range.min = options.min;
            }
            var val = options.property.value(this);
            if (!val) {
                return null;
            }
            if ((range.min == null || val.length >= range.min) && (range.max == null || val.length <= range.max)) {
                // Value is within range
                return null;
            }
            if (range.min != null && range.max != null)
                return rootType.model.getResource("listlength-between").replace("{min}", range.min.toString()).replace("{max}", range.max.toString());
            if (range.min != null)
                return rootType.model.getResource("listlength-at-least").replace("{min}", range.min.toString());
            else
                return rootType.model.getResource("listlength-at-most").replace("{max}", range.max.toString());
        };
        // call the base type constructor
        _this = _super.call(this, rootType, options) || this;
        return _this;
    }
    return ListLengthRule;
}(validation_rule_1.ValidationRule));
exports.ListLengthRule = ListLengthRule;


/***/ }),

/***/ "../../libs/model.js/lib/model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.normalize = exports.ModelSettings = exports.createModel = exports.Model = void 0;
var events_1 = __webpack_require__("../../libs/model.js/lib/events.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
var type_1 = __webpack_require__("../../libs/model.js/lib/type.js");
var format_1 = __webpack_require__("../../libs/model.js/lib/format.js");
var entity_serializer_1 = __webpack_require__("../../libs/model.js/lib/entity-serializer.js");
var resource_1 = __webpack_require__("../../libs/model.js/lib/resource.js");
var globalization_1 = __webpack_require__("../../libs/model.js/lib/globalization.js");
var event_scope_1 = __webpack_require__("../../libs/model.js/lib/event-scope.js");
var valueTypes = { string: String, number: Number, date: Date, boolean: Boolean };
var Model = /** @class */ (function () {
    function Model(options, config) {
        this._readyProcessing = false;
        this.serializer = new entity_serializer_1.EntitySerializer();
        this.types = {};
        this.settings = new ModelSettings(config);
        this.entityRegistered = new events_1.Event();
        this.afterPropertySet = new events_1.Event();
        this.listChanged = new events_1.Event();
        this.eventScope = event_scope_1.EventScope.create(this.settings.eventScopeSettings);
        Object.defineProperty(this, "_formats", { enumerable: false, configurable: false, writable: true, value: {} });
        if (options) {
            this.extend(options);
        }
    }
    /**
     * Sets the default locale to use when a model's locale is not explicitly set
     * @param locale The default locale
     */
    Model.setDefaultLocale = function (locale) {
        resource_1.setDefaultLocale(locale);
    };
    /**
     * Defines global resource messages for the given locale
     * @param locale The locale to set messages for
     * @param resources The resources messages
     */
    Model.defineResources = function (locale, resources) {
        resource_1.defineResources(locale, resources);
    };
    Model.getResource = function (name, arg2, arg3) {
        var locale;
        var params;
        if (arguments.length === 2) {
            if (typeof arg2 === "string") {
                locale = arg2;
                params = null;
            }
            else if (typeof arg2 === "object") {
                locale = null;
                params = arg2;
            }
        }
        else if (arguments.length >= 3) {
            locale = arg2;
            params = arg3;
        }
        var resource = resource_1.getResource(name, locale);
        if (params)
            return helpers_1.replaceTokens(resource, params);
        return resource;
    };
    /**
     * Gets the resource with the specified name
     * @param name The resource name/key
     * @param params The parameters to use for string format substitution
     */
    Model.prototype.getResource = function (name, params) {
        if (params === void 0) { params = null; }
        var resource = resource_1.getResource(name, this.$resources, this.$locale);
        if (params)
            return helpers_1.replaceTokens(resource, params);
        return resource;
    };
    Model.prototype.resourceExists = function (name) {
        return resource_1.resourceExists(name, this.$resources, this.$locale);
    };
    /**
     * Formats a date as text using the given format string
     * @param date The date to format
     * @param format The format specifier
     */
    Model.prototype.formatDate = function (date, format) {
        return globalization_1.formatDate(date, format, this.$culture);
    };
    /**
     * Parses a date from text
     * @param text The text to parse
     */
    Model.prototype.parseDate = function (text, formats) {
        return globalization_1.parseDate(text, this.$culture, formats);
    };
    /**
     * Expands a date/time format string, which may be a predefined short format, into the equivalent full format strin
     * @param format The format string
     */
    Model.prototype.expandDateFormat = function (format) {
        return globalization_1.expandDateFormat(this.$culture.dateTimeFormat, format);
    };
    /**
     * Formats a number as text using the given format string
     * @param number The number to format
     * @param format The format specifier
     */
    Model.prototype.formatNumber = function (number, format) {
        return globalization_1.formatNumber(number, format, this.$culture);
    };
    /**
     * Parses a number from text
     * @param text The text to parse
     */
    Model.prototype.parseNumber = function (text, format) {
        return globalization_1.parseNumber(text, globalization_1.getNumberStyle(format), this.$culture);
    };
    /**
     * Extends the model with the specified type information.
     * @param options The set of model types to add and/or extend.
     */
    Model.prototype.extend = function (options) {
        var _this = this;
        // Use prepare() to defer property path resolution while the model is being extended
        this.prepare(function () {
            // Namespace
            if (options.$namespace) {
                // TODO: Guard against namespace being set after types have been created
                var $namespace = options.$namespace;
                if (!_this.$namespace) {
                    Object.defineProperty(_this, "$namespace", { configurable: false, enumerable: true, value: $namespace, writable: false });
                }
                else if ($namespace !== _this.$namespace) {
                    throw new Error("Cannot redefine namespace for model.");
                }
            }
            // Locale
            if (options.$locale && typeof options.$locale === "string") {
                // TODO: Guard against locale being set after types have been created
                var $locale = options.$locale;
                if (!_this.$locale) {
                    Object.defineProperty(_this, "$locale", { configurable: false, enumerable: true, value: $locale, writable: false });
                }
                else if ($locale !== _this.$locale) {
                    throw new Error("Cannot redefine locale for model.");
                }
            }
            // Resources
            if (options.$resources && typeof options.$resources === "object") {
                // TODO: Guard against resources being set after types have been created
                var $resources = options.$resources;
                if (!_this.$resources) {
                    Object.defineProperty(_this, "$resources", { configurable: false, enumerable: true, value: $resources, writable: false });
                }
                else if ($resources !== _this.$resources) {
                    throw new Error("Cannot redefine resources for model.");
                }
            }
            // Culture
            if (options.$culture) {
                var $culture = void 0;
                // TODO: Guard against culture being set after types have been created
                if (typeof options.$culture === "object") {
                    $culture = options.$culture;
                }
                else if (typeof options.$culture === "string") {
                    globalization_1.CultureInfo.setup();
                    if (globalization_1.CultureInfo.CurrentCulture.name === options.$culture) {
                        $culture = globalization_1.CultureInfo.CurrentCulture;
                    }
                    if (!$culture) {
                        throw new Error("Could not find culture '" + options.$culture + "'.");
                    }
                }
                if ($culture) {
                    if (!_this.$culture) {
                        Object.defineProperty(_this, "$culture", { configurable: false, enumerable: true, value: $culture, writable: false });
                    }
                    else if ($culture !== _this.$culture) {
                        throw new Error("Cannot redefine culture for model.");
                    }
                }
            }
            var typesToCreate = Object.keys(options).filter(function (typeName) { return !typeName.startsWith("$"); });
            var typesToInitialize = [];
            // Create New Types
            while (typesToCreate.length > 0) {
                var typeName = typesToCreate.splice(0, 1)[0];
                for (var typeNameIdx = -1, pos = typeName.length - 1, i = typeName.lastIndexOf(".", pos); i > 0; pos = i - 1, i = typeName.lastIndexOf(".", pos)) {
                    var typeNamespace = typeName.substring(0, i);
                    var typeNamespaceIdx = typesToCreate.indexOf(typeNamespace);
                    if (typeNamespaceIdx > typeNameIdx) {
                        if (true) {
                            console.warn("Type '" + typeNamespace + "' should be created before type '" + typeName + "'.");
                        }
                        // Remove the current  type's "namespace" type and re-add the current type to the list
                        typesToCreate.splice(typeNamespaceIdx, 1);
                        typesToCreate.splice(0, 0, typeName);
                        typeNameIdx++;
                        // Resume the loop using the new namespace type (resetting index variables isn't necessary)
                        typeName = typeNamespace;
                    }
                }
                var typeOptions = options[typeName];
                var type = _this.types[typeName];
                typesToInitialize.push(typeName);
                if (!type) {
                    var baseType = null;
                    if (typeOptions.$extends) {
                        baseType = _this.types[typeOptions.$extends];
                        if (!baseType) {
                            throw new Error("Base type '" + typeOptions.$extends + "' for type '" + typeName + "' wasn't found.");
                        }
                    }
                    var format = typeOptions.$format;
                    type = new type_1.Type(_this, typeName, baseType, format);
                    _this.types[typeName] = type;
                }
            }
            // Extend Types
            for (var _i = 0, typesToInitialize_1 = typesToInitialize; _i < typesToInitialize_1.length; _i++) {
                var typeName = typesToInitialize_1[_i];
                var typeOptions = options[typeName];
                _this.types[typeName].extend(typeOptions);
            }
        });
    };
    /**
     * Prepares the model by invoking and extension function, which tracking the model
     * ready state to allow use of the @ready promise to defer property path resolution.
     * @param extend The function extending the model
     */
    Model.prototype.prepare = function (extend) {
        // Create a model initialization scope
        if (!this._readyCallbacks) {
            this._readyProcessing = false;
            // Create an array to track model initialization callbacks
            Object.defineProperty(this, "_readyCallbacks", { enumerable: false, configurable: true, writable: true, value: [] });
            // Extend the model
            extend();
            // Complete pending model initialization steps
            this._readyProcessing = true;
            for (var _i = 0, _a = this._readyCallbacks; _i < _a.length; _i++) {
                var init = _a[_i];
                init();
            }
            this._readyProcessing = false;
            delete this._readyCallbacks;
        }
        // Leverage the current model initialization scope
        else
            extend();
    };
    /**
     * Execute a function when the model is ready.
     * @param init The function to invoke when the model is ready.
     * @param enqueueWhileProcessing Determines whether the callback should be added to the queue while the queue is being processed.
     */
    Model.prototype.ready = function (callback, _a) {
        var _b = (_a === void 0 ? {} : _a).enqueueWhileProcessing, enqueueWhileProcessing = _b === void 0 ? true : _b;
        if (this._readyCallbacks && (!this._readyProcessing || enqueueWhileProcessing))
            this._readyCallbacks.push(callback);
        else
            callback();
    };
    /**
     * Gets the format for the specified property type and format string.
     * @param type The type the format is for
     * @param format The format template or specifier
     */
    Model.prototype.getFormat = function (type, format, formatEval) {
        // Return null if a format specifier was not provided
        if (!format) {
            return null;
        }
        // Get the format cache for the type
        var formats;
        if (type_1.isEntityType(type)) {
            formats = type.meta._formats;
        }
        else {
            formats = this._formats[type.name];
            if (!formats)
                formats = this._formats[type.name] = {};
        }
        // First see if the requested format is cached
        var f = formats[format];
        if (f) {
            return f;
        }
        // Otherwise, create and cache the format
        if (type_1.isEntityType(type)) {
            return (formats[format] = format_1.Format.fromTemplate(type.meta, format, formatEval));
        }
        else {
            // otherwise, call the format provider to create a new format
            return (formats[format] = format_1.createFormat(this, type, format));
        }
    };
    /**
     * Gets the javascript property type with the specified name.
     * @param type
     */
    Model.prototype.getJsType = function (type) {
        var jstype = type.toLowerCase() === "object" ? Object : valueTypes[type.toLowerCase()];
        if (!jstype) {
            var modelType = this.types[type];
            return modelType ? modelType.jstype : null;
        }
        return jstype;
    };
    return Model;
}());
exports.Model = Model;
// eslint-disable-next-line no-redeclare
function createModel(options, config) {
    return new Promise(function (resolve) {
        var model = new Model(options, config);
        model.ready(function () {
            resolve(model);
        });
    });
}
exports.createModel = createModel;
var ModelSettings = /** @class */ (function () {
    function ModelSettings(config) {
        // There is a slight speed cost to creating own properties,
        // which may be noticeable with very large object counts.
        this.createOwnProperties = false;
        this.autogeneratePropertyLabels = true;
        // Don't pollute the window object by default
        this.useGlobalObject = false;
        // Use sane defaults for event scope settings, i.e. "non-exiting" scope detection
        this.eventScopeSettings = event_scope_1.EVENT_SCOPE_DEFAULT_SETTINGS;
        this.createOwnProperties = config && !!config.createOwnProperties;
        if (config && config.autogeneratePropertyLabels === false)
            this.autogeneratePropertyLabels = false;
        this.useGlobalObject = config && !!config.useGlobalObject;
        this.eventScopeSettings = {
            maxExitingTransferCount: (config && typeof config.maxExitingEventScopeTransferCount === "number" ? config.maxExitingEventScopeTransferCount : null) || event_scope_1.EVENT_SCOPE_DEFAULT_SETTINGS.maxExitingTransferCount,
            maxDepth: (config && typeof config.maxEventScopeDepth === "number" ? config.maxEventScopeDepth : null) || event_scope_1.EVENT_SCOPE_DEFAULT_SETTINGS.maxDepth
        };
    }
    return ModelSettings;
}());
exports.ModelSettings = ModelSettings;
// eslint-disable-next-line no-redeclare
function normalize(val, format) {
    if (!val && val !== false)
        return val;
    if (val.constructor.name === "Date") {
        var dateFormat = typeof format === "string" ? format : format.specifier;
        if (dateFormat === "t") {
            // Set the date of the dateTime to January 1st, 1970
            var newDate = new Date(val.valueOf());
            newDate.setFullYear(1970);
            newDate.setMonth(0);
            newDate.setDate(1);
            return newDate;
        }
        else if (dateFormat === "d") {
            // Set the time of the dateTime to 12AM
            return new Date(val.getFullYear(), val.getMonth(), val.getDate());
        }
    }
    return val;
}
exports.normalize = normalize;


/***/ }),

/***/ "../../libs/model.js/lib/object-meta.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectMeta = void 0;
var condition_type_1 = __webpack_require__("../../libs/model.js/lib/condition-type.js");
var observable_array_1 = __webpack_require__("../../libs/model.js/lib/observable-array.js");
var format_error_1 = __webpack_require__("../../libs/model.js/lib/format-error.js");
var ObjectMeta = /** @class */ (function () {
    function ObjectMeta(type, entity, id, isNew) {
        Object.defineProperty(this, "type", { enumerable: true, configurable: false, writable: false, value: type });
        Object.defineProperty(this, "entity", { enumerable: true, configurable: false, writable: false, value: entity });
        Object.defineProperty(this, "id", { enumerable: true, configurable: false, writable: true, value: id });
        Object.defineProperty(this, "isNew", { enumerable: true, configurable: false, writable: true, value: isNew });
        Object.defineProperty(this, "conditions", { enumerable: true, configurable: false, writable: true, value: observable_array_1.ObservableArray.create() });
        Object.defineProperty(this, "__pendingInvocation__", { enumerable: false, configurable: false, writable: false, value: [] });
    }
    /**
     * Gets the condition target with the specified condition type
     * @param conditionType The type of condition to retrieve
     */
    ObjectMeta.prototype.getCondition = function (conditionType) {
        return this.conditions.filter(function (c) { return c.condition.type === conditionType; })[0];
    };
    /**
     * Stores the condition target for the current instance
     * @param conditionTarget The condition target to store
     */
    ObjectMeta.prototype.setCondition = function (conditionTarget) {
        if (conditionTarget.condition.type !== format_error_1.FormatError.ConditionType) {
            this.conditions.push(conditionTarget);
        }
    };
    /**
     * Clears the condition for the current instance with the specified condition type
     * @param conditionType The type of condition to clear
     */
    ObjectMeta.prototype.clearCondition = function (conditionType) {
        for (var i = 0; i < this.conditions.length; i++) {
            var conditionTarget = this.conditions[i];
            if (conditionTarget.condition.type === conditionType) {
                this.conditions.splice(i--, 1);
            }
        }
    };
    /**
     * Determines if the set of permissions are allowed for the current instance
     * @param codes The permission condition type code(s)
     */
    ObjectMeta.prototype.isAllowed = function () {
        var codes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            codes[_i] = arguments[_i];
        }
        // ensure each condition type is allowed for the current instance
        for (var c = codes.length - 1; c >= 0; c--) {
            var code = codes[c];
            var conditionType = condition_type_1.ConditionType.get(code);
            // return undefined if the condition type does not exist
            if (conditionType === undefined) {
                return undefined;
            }
            // throw an exception if the condition type is not a permission
            if (!(conditionType instanceof condition_type_1.PermissionConditionType)) {
                throw new Error("Condition type \"" + code + "\" should be a Permission.");
            }
            // return false if a condition of the current type exists and is a deny permission or does not exist and is a grant permission
            if (this.getCondition(conditionType) ? !conditionType.isAllowed : conditionType.isAllowed) {
                return false;
            }
        }
        return true;
    };
    return ObjectMeta;
}());
exports.ObjectMeta = ObjectMeta;


/***/ }),

/***/ "../../libs/model.js/lib/observable-array.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateArray = exports.ArrayObserver = exports.ObservableArray$unshift = exports.ObservableArray$splice = exports.ObservableArray$sort = exports.ObservableArray$shift = exports.ObservableArray$reverse = exports.ObservableArray$push = exports.ObservableArray$pop = exports.ObservableArray$fill = exports.ObservableArray$copyWithin = exports.ObservableArray$batchUpdate = exports.ObservableArray$overrideNativeMethods = exports.ObservableArrayImplementation = exports.ArrayChangeType = exports.ObservableArray = void 0;
var events_1 = __webpack_require__("../../libs/model.js/lib/events.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
// eslint-disable-next-line import/export, no-redeclare, @typescript-eslint/no-unused-vars
var ObservableArray = /** @class */ (function () {
    function ObservableArray() {
    }
    /**
     * Returns a value indicating whether the given array is observable
     * @param array The array to check for observability
     */
    ObservableArray.isObservableArray = function (array) {
        return helpers_1.hasOwnProperty(array, "__aob__") && array.__aob__.constructor === ArrayObserver;
    };
    /**
     * Makes the given array observable, if not already
     * @param array The array to make observable
     */
    ObservableArray.ensureObservable = function (array) {
        // Check to see if the array is already an observable list
        if (ObservableArray.isObservableArray(array)) {
            return array;
        }
        if (helpers_1.hasOwnProperty(array, "__aob__")) {
            // TODO: Warn about invalid '__aob__' property?
            return;
        }
        Object.defineProperty(array, "__aob__", {
            configurable: false,
            enumerable: false,
            value: new ArrayObserver(array),
            writable: false
        });
        Object.defineProperty(array, "changed", {
            configurable: false,
            enumerable: true,
            get: function () {
                return this.__aob__.changed;
            }
        });
        array["batchUpdate"] = ObservableArray$batchUpdate;
        ObservableArray$overrideNativeMethods.call(array);
        return array;
    };
    /**
     * Creates a new observable array
     * @param items The initial array items
     */
    ObservableArray.create = function (items) {
        if (items === void 0) { items = []; }
        var array;
        if (items instanceof ObservableArray)
            array = items;
        else
            array = new (ObservableArrayImplementation.bind.apply(ObservableArrayImplementation, __spreadArrays([void 0], items)))();
        ObservableArray.ensureObservable(array);
        return array;
    };
    return ObservableArray;
}());
exports.ObservableArray = ObservableArray;
var ArrayChangeType;
(function (ArrayChangeType) {
    ArrayChangeType[ArrayChangeType["add"] = 1] = "add";
    ArrayChangeType[ArrayChangeType["remove"] = 2] = "remove";
    ArrayChangeType[ArrayChangeType["replace"] = 4] = "replace";
    ArrayChangeType[ArrayChangeType["reorder"] = 8] = "reorder";
})(ArrayChangeType = exports.ArrayChangeType || (exports.ArrayChangeType = {}));
var ObservableArrayImplementation = /** @class */ (function (_super) {
    __extends(ObservableArrayImplementation, _super);
    /**
     * Creates a new observable array
     * @param items The array of initial items
     */
    function ObservableArrayImplementation() {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var _this = _super.apply(this, items) || this;
        Object.defineProperty(_this, "__aob__", {
            configurable: false,
            enumerable: false,
            value: new ArrayObserver(_this),
            writable: false
        });
        Object.defineProperty(_this, "changed", {
            get: function () {
                return this.__aob__.changed;
            }
        });
        if (_this.constructor !== ObservableArrayImplementation) {
            _this["batchUpdate"] = (function (fn) { ObservableArray$batchUpdate.call(this, fn); });
            ObservableArray$overrideNativeMethods.call(_this);
        }
        return _this;
    }
    Object.defineProperty(ObservableArrayImplementation.prototype, "changed", {
        /** Expose the changed event */
        get: function () {
            return this.__aob__.changed;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Begin queueing changes to the array, make changes in the given callback function, then stop queueing and raise events
     */
    ObservableArrayImplementation.prototype.batchUpdate = function (fn, additionalArgs) {
        if (additionalArgs === void 0) { additionalArgs = null; }
        ObservableArray$batchUpdate.call(this, fn, additionalArgs);
    };
    /**
     * The copyWithin() method shallow copies part of an array to another location in the same array and returns it, without modifying its size.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin
     * @param target Zero based index at which to copy the sequence to. If negative, target will be counted from the end. If target is at or greater than arr.length, nothing will be copied. If target is positioned after start, the copied sequence will be trimmed to fit arr.length.
     * @param start Zero based index at which to start copying elements from. If negative, start will be counted from the end. If start is omitted, copyWithin will copy from the start (defaults to 0).
     * @param end Zero based index at which to end copying elements from. copyWithin copies up to but not including end. If negative, end will be counted from the end. If end is omitted, copyWithin will copy until the end (default to arr.length).
     * @returns The modified array.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ObservableArrayImplementation.prototype.copyWithin = function (target, start, end) {
        return ObservableArray$copyWithin.apply(this, arguments);
    };
    /**
     * The fill() method fills all the elements of an array from a start index to an end index with a static value. The end index is not included.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
     * @param value Value to fill an array.
     * @param start Start index, defaults to 0.
     * @param end End index, defaults to this.length.
     * @returns The modified array.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ObservableArrayImplementation.prototype.fill = function (value, start, end) {
        return ObservableArray$fill.apply(this, arguments);
    };
    /**
     * The pop() method removes the last element from an array and returns that element. This method changes the length of the array.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop
     * @returns The removed element from the array; undefined if the array is empty.
     */
    ObservableArrayImplementation.prototype.pop = function () {
        return ObservableArray$pop.apply(this, arguments);
    };
    /**
     * The push() method adds one or more elements to the end of an array and returns the new length of the array.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push
     * @param items The elements to add to the end of the array.
     * @returns The new length property of the object upon which the method was called.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ObservableArrayImplementation.prototype.push = function () {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i] = arguments[_i];
        }
        return ObservableArray$push.apply(this, arguments);
    };
    /**
     * The reverse() method reverses an array in place. The first array element becomes the last, and the last array element becomes the first.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse
     * @returns The reversed array.
     */
    ObservableArrayImplementation.prototype.reverse = function () {
        return ObservableArray$reverse.apply(this, arguments);
    };
    /**
     * The shift() method removes the first element from an array and returns that removed element. This method changes the length of the array.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift
     * @returns The removed element from the array; undefined if the array is empty.
     */
    ObservableArrayImplementation.prototype.shift = function () {
        return ObservableArray$shift.apply(this, arguments);
    };
    /**
     * The sort() method sorts the elements of an array in place and returns the array. Javascript sort algorithm on V8 is now stable. The default sort order is according to string Unicode code points.
     * The time and space complexity of the sort cannot be guaranteed as it is implementation dependent.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
     * @param compareFunction Specifies a function that defines the sort order. If omitted, the array is sorted according to each character's Unicode code point value, according to the string conversion of each element.
     * @returns The sorted array. Note that the array is sorted in place, and no copy is made.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ObservableArrayImplementation.prototype.sort = function (compareFunction) {
        return ObservableArray$sort.apply(this, arguments);
    };
    /**
     * The splice() method changes the contents of an array by removing existing elements and/or adding new elements.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
     * @param start  Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.
     * @param deleteCount An integer indicating the number of old array elements to remove. If deleteCount is omitted, or if its value is larger than array.length - start (that is, if it is greater than the number of elements left in the array, starting at start), then all of the elements from start through the end of the array will be deleted. If deleteCount is 0 or negative, no elements are removed. In this case, you should specify at least one new element (see below).
     * @param items The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.
     * @returns An array containing the deleted elements. If only one element is removed, an array of one element is returned. If no elements are removed, an empty array is returned.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ObservableArrayImplementation.prototype.splice = function (start, deleteCount) {
        var items = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            items[_i - 2] = arguments[_i];
        }
        return ObservableArray$splice.apply(this, arguments);
    };
    /**
     * The unshift() method adds one or more elements to the beginning of an array and returns the new length of the array.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift
     * @param items The elements to add to the front of the array.
     * @returns The new length property of the object upon which the method was called.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ObservableArrayImplementation.prototype.unshift = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        return ObservableArray$unshift.apply(this, arguments);
    };
    return ObservableArrayImplementation;
}(Array));
exports.ObservableArrayImplementation = ObservableArrayImplementation;
/**
 * Override's native Array methods that manipulate the array
 * @param array The array to extend
 */
function ObservableArray$overrideNativeMethods() {
    this["copyWithin"] = ObservableArray$copyWithin;
    this["fill"] = ObservableArray$fill;
    this["pop"] = ObservableArray$pop;
    this["push"] = ObservableArray$push;
    this["reverse"] = ObservableArray$reverse;
    this["shift"] = ObservableArray$shift;
    this["sort"] = ObservableArray$sort;
    this["splice"] = ObservableArray$splice;
    this["unshift"] = ObservableArray$unshift;
}
exports.ObservableArray$overrideNativeMethods = ObservableArray$overrideNativeMethods;
/**
 * Begin queueing changes to the array, make changes in the given callback function, then stop queueing and raise events
 */
function ObservableArray$batchUpdate(fn, additionalArgs) {
    if (additionalArgs === void 0) { additionalArgs = null; }
    this.__aob__.startQueueingChanges();
    try {
        fn(this);
        this.__aob__.stopQueueingChanges(true, additionalArgs);
    }
    finally {
        if (this.__aob__._isQueuingChanges) {
            this.__aob__.stopQueueingChanges(false, additionalArgs);
        }
    }
}
exports.ObservableArray$batchUpdate = ObservableArray$batchUpdate;
/**
 * The copyWithin() method shallow copies part of an array to another location in the same array and returns it, without modifying its size.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin
 * @param array The observable array
 * @param target Zero based index at which to copy the sequence to. If negative, target will be counted from the end. If target is at or greater than arr.length, nothing will be copied. If target is positioned after start, the copied sequence will be trimmed to fit arr.length.
 * @param start Zero based index at which to start copying elements from. If negative, start will be counted from the end. If start is omitted, copyWithin will copy from the start (defaults to 0).
 * @param end Zero based index at which to end copying elements from. copyWithin copies up to but not including end. If negative, end will be counted from the end. If end is omitted, copyWithin will copy until the end (default to arr.length).
 */
function ObservableArray$copyWithin(target, start, end) {
    Array.prototype.copyWithin.apply(this, arguments);
    // TODO: Warn about non-observable manipulation of observable array?
    this.__aob__.raiseEvents({ type: ArrayChangeType.replace, startIndex: start, endIndex: end });
    return this;
}
exports.ObservableArray$copyWithin = ObservableArray$copyWithin;
/**
 * The fill() method fills all the elements of an array from a start index to an end index with a static value. The end index is not included.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill
 * @param array The observable array
 * @param value Value to fill an array.
 * @param start Start index, defaults to 0.
 * @param end End index, defaults to this.length.
 */
function ObservableArray$fill(value, start, end) {
    Array.prototype.fill.apply(this, arguments);
    // TODO: Warn about non-observable manipulation of observable array?
    this.__aob__.raiseEvents({ type: ArrayChangeType.replace, startIndex: start, endIndex: end });
    return this;
}
exports.ObservableArray$fill = ObservableArray$fill;
/**
 * The pop() method removes the last element from an array and returns that element. This method changes the length of the array.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop
 * @param array The observable array
 * @returns The removed element from the array; undefined if the array is empty.
 */
function ObservableArray$pop() {
    var originalLength = this.length;
    var removed = Array.prototype.pop.apply(this, arguments);
    if (this.length !== originalLength) {
        var removedIndex = originalLength - 1;
        this.__aob__.raiseEvents({ type: ArrayChangeType.remove, startIndex: removedIndex, endIndex: removedIndex, items: [removed] });
    }
    return removed;
}
exports.ObservableArray$pop = ObservableArray$pop;
/**
 * The push() method adds one or more elements to the end of an array and returns the new length of the array.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push
 * @param array The observable array
 * @param items The elements to add to the end of the array.
 * @returns The new length property of the object upon which the method was called.
 */
function ObservableArray$push() {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
    }
    // BUG: Babel's handling of rest arguments seems to be thrown off by 1 (due to the "this" argument?) - cognitoforms/model.js:#5
    items = Array.prototype.slice.call(arguments);
    var originalLength = this.length;
    var newLength = Array.prototype.push.apply(this, arguments);
    if (newLength > 0) {
        this.__aob__.raiseEvents({ type: ArrayChangeType.add, startIndex: originalLength, endIndex: originalLength + (newLength - originalLength) - 1, items: items });
    }
    return newLength;
}
exports.ObservableArray$push = ObservableArray$push;
/**
 * The reverse() method reverses an array in place. The first array element becomes the last, and the last array element becomes the first.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse
 * @param array The observable array
 * @returns The reversed array.
 */
function ObservableArray$reverse() {
    Array.prototype.reverse.apply(this, arguments);
    // TODO: Warn about non-observable manipulation of observable array?
    this.__aob__.raiseEvents({ type: ArrayChangeType.reorder, startIndex: 0, endIndex: this.length - 1 });
    return this;
}
exports.ObservableArray$reverse = ObservableArray$reverse;
/**
 * The shift() method removes the first element from an array and returns that removed element. This method changes the length of the array.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift
 * @param array The observable array
 * @returns The removed element from the array; undefined if the array is empty.
 */
function ObservableArray$shift() {
    var originalLength = this.length;
    var removed = Array.prototype.shift.apply(this, arguments);
    if (this.length !== originalLength) {
        this.__aob__.raiseEvents({ type: ArrayChangeType.remove, startIndex: 0, endIndex: 0, items: [removed] });
    }
    return removed;
}
exports.ObservableArray$shift = ObservableArray$shift;
/**
 * The sort() method sorts the elements of an array in place and returns the array. Javascript sort algorithm on V8 is now stable. The default sort order is according to string Unicode code points.
 * The time and space complexity of the sort cannot be guaranteed as it is implementation dependent.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
 * @param array The observable array
 * @param compareFunction Specifies a function that defines the sort order. If omitted, the array is sorted according to each character's Unicode code point value, according to the string conversion of each element.
 * @returns The sorted array. Note that the array is sorted in place, and no copy is made.
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function ObservableArray$sort(compareFunction) {
    Array.prototype.sort.apply(this, arguments);
    // TODO: Warn about non-observable manipulation of observable array?
    this.__aob__.raiseEvents({ type: ArrayChangeType.reorder, startIndex: 0, endIndex: this.length - 1 });
    return this;
}
exports.ObservableArray$sort = ObservableArray$sort;
/**
 * The splice() method changes the contents of an array by removing existing elements and/or adding new elements.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
 * @param array The observable array
 * @param start  Index at which to start changing the array (with origin 0). If greater than the length of the array, actual starting index will be set to the length of the array. If negative, will begin that many elements from the end of the array (with origin -1) and will be set to 0 if absolute value is greater than the length of the array.
 * @param deleteCount An integer indicating the number of old array elements to remove. If deleteCount is omitted, or if its value is larger than array.length - start (that is, if it is greater than the number of elements left in the array, starting at start), then all of the elements from start through the end of the array will be deleted. If deleteCount is 0 or negative, no elements are removed. In this case, you should specify at least one new element (see below).
 * @param items The elements to add to the array, beginning at the start index. If you don't specify any elements, splice() will only remove elements from the array.
 * @returns An array containing the deleted elements. If only one element is removed, an array of one element is returned. If no elements are removed, an empty array is returned.
 */
function ObservableArray$splice(start, deleteCount) {
    var items = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        items[_i - 2] = arguments[_i];
    }
    // BUG: Babel's handling of rest arguments seems to be thrown off by 1 (due to the "this" argument?) - cognitoforms/model.js:#5
    items = Array.prototype.slice.call(arguments, 2);
    var removed = Array.prototype.splice.apply(this, arguments);
    if (removed.length > 0 || items.length > 0) {
        var changeEvents = [];
        if (removed.length > 0) {
            changeEvents.push({ type: ArrayChangeType.remove, startIndex: start, endIndex: start + removed.length - 1, items: removed });
        }
        if (items.length > 0) {
            changeEvents.push({ type: ArrayChangeType.add, startIndex: start, endIndex: start + items.length - 1, items: items });
        }
        this.__aob__.raiseEvents(changeEvents);
    }
    return removed;
}
exports.ObservableArray$splice = ObservableArray$splice;
/**
 * The unshift() method adds one or more elements to the beginning of an array and returns the new length of the array.
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift
 * @param array The observable array
 * @param items The elements to add to the front of the array.
 * @returns The new length property of the object upon which the method was called.
 */
function ObservableArray$unshift() {
    var items = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
    }
    // BUG: Babel's handling of rest arguments seems to be thrown off by 1 (due to the "this" argument?) - cognitoforms/model.js:#5
    items = Array.prototype.slice.call(arguments);
    var originalLength = this.length;
    var newLength = Array.prototype.unshift.apply(this, arguments);
    if (newLength !== originalLength) {
        this.__aob__.raiseEvents({ type: ArrayChangeType.add, startIndex: 0, endIndex: items.length - 1, items: items });
    }
    return newLength;
}
exports.ObservableArray$unshift = ObservableArray$unshift;
var ArrayObserver = /** @class */ (function () {
    function ArrayObserver(array) {
        this.array = array;
        this.changed = new events_1.Event();
        this._isQueuingChanges = false;
    }
    ArrayObserver.prototype.raiseEvents = function (changes, additionalArgs) {
        if (this._isQueuingChanges) {
            if (!this._queuedChanges) {
                this._queuedChanges = [];
            }
            if (Array.isArray(changes)) {
                Array.prototype.push.apply(this._queuedChanges, changes);
            }
            else {
                this._queuedChanges.push(changes);
            }
        }
        else if (Array.isArray(changes)) {
            if (changes.length)
                this.changed.publish(this.array, { changes: changes, additionalArgs: additionalArgs });
        }
        else {
            this.changed.publish(this.array, { changes: [changes], additionalArgs: additionalArgs });
        }
    };
    ArrayObserver.prototype.startQueueingChanges = function () {
        this._isQueuingChanges = true;
        if (!this._queuedChanges) {
            this._queuedChanges = [];
        }
    };
    ArrayObserver.prototype.stopQueueingChanges = function (raiseEvents, additionalArgs) {
        if (additionalArgs === void 0) { additionalArgs = null; }
        this._isQueuingChanges = false;
        if (raiseEvents) {
            this.raiseEvents(this._queuedChanges, additionalArgs);
            delete this._queuedChanges;
        }
    };
    return ArrayObserver;
}());
exports.ArrayObserver = ArrayObserver;
function callSplice(arr, index, removeCount, addItems) {
    if (removeCount || addItems.length > 0) {
        var addItemsArgs = [index, removeCount].concat(addItems);
        arr.splice.apply(arr, addItemsArgs);
    }
}
function updateArray(array, values) {
    var pointer = 0;
    var srcSeek = 0;
    var tgtSeek = 0;
    while (srcSeek < array.length) {
        if (array[srcSeek] === values[tgtSeek]) {
            if (pointer === srcSeek && pointer === tgtSeek) {
                // items match, so advance
                pointer = srcSeek = tgtSeek = pointer + 1;
            }
            else {
                // remove range from source and add range from target
                callSplice(array, pointer, srcSeek - pointer, values.slice(pointer, tgtSeek));
                // reset to index follow target seek location since arrays match up to that point
                pointer = srcSeek = tgtSeek = tgtSeek + 1;
            }
        }
        else if (tgtSeek >= values.length) {
            // reached the end of the target array, so advance the src pointer and test again
            tgtSeek = pointer;
            srcSeek += 1;
        }
        else {
            // advance to the next target item to test
            tgtSeek += 1;
        }
    }
    callSplice(array, pointer, srcSeek - pointer, values.slice(pointer, Math.max(tgtSeek, values.length)));
}
exports.updateArray = updateArray;


/***/ }),

/***/ "../../libs/model.js/lib/property-chain.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyChain = void 0;
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var events_1 = __webpack_require__("../../libs/model.js/lib/events.js");
var format_1 = __webpack_require__("../../libs/model.js/lib/format.js");
/**
 * Encapsulates the logic required to work with a chain of properties and
 * a root object, allowing interaction with the chain as if it were a
 * single property of the root object.
 */
var PropertyChain = /** @class */ (function () {
    function PropertyChain(rootType, path) {
        var _this = this;
        this.rootType = rootType;
        // replace "." in type casts so that they do not interfere with splitting path
        path = path.replace(/<[^>]*>/ig, function (e) { return e.replace(/\./ig, function () { return "$_$"; }); });
        var currentType = rootType;
        this.properties = path.split(".").map(function (step) {
            var property;
            // Regex pattern matches all letters and digits that are valid for javascript identifiers, including  "_"
            var parsed = step.match(/^([_0-9a-zA-Z\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u02bb-\u02c1\u02d0-\u02d1\u02e0-\u02e4\u02ee\u0370-\u0373\u0376-\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u064a\u0660-\u0669\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07c0-\u07ea\u07f4-\u07f5\u07fa\u0904-\u0939\u093d\u0950\u0958-\u0961\u0966-\u096f\u0971-\u0972\u097b-\u097f\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09e6-\u09f1\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a66-\u0a6f\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0ae6-\u0aef\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b66-\u0b6f\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0be6-\u0bef\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58-\u0c59\u0c60-\u0c61\u0c66-\u0c6f\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0ce6-\u0cef\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d3d\u0d60-\u0d61\u0d66-\u0d6f\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0ed0-\u0ed9\u0edc-\u0edd\u0f00\u0f20-\u0f29\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8b\u1000-\u102a\u103f-\u1049\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u1090-\u1099\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u17e0-\u17e9\u1810-\u1819\u1820-\u1877\u1880-\u18a8\u18aa\u1900-\u191c\u1946-\u196d\u1970-\u1974\u1980-\u19a9\u19c1-\u19c7\u19d0-\u19d9\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b50-\u1b59\u1b83-\u1ba0\u1bae-\u1bb9\u1c00-\u1c23\u1c40-\u1c49\u1c4d-\u1c7d\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u2094\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183-\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2c6f\u2c71-\u2c7d\u2c80-\u2ce4\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3006\u3031-\u3035\u303b-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31b7\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fc3\ua000-\ua48c\ua500-\ua60c\ua610-\ua62b\ua640-\ua65f\ua662-\ua66e\ua680-\ua697\ua722-\ua788\ua78b-\ua78c\ua7fb-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8d0-\ua8d9\ua900-\ua925\ua930-\ua946\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa50-\uaa59\uac00-\ud7a3\uf900-\ufa2d\ufa30-\ufa6a\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]+)(<([_$0-9a-zA-Z\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u02bb-\u02c1\u02d0-\u02d1\u02e0-\u02e4\u02ee\u0370-\u0373\u0376-\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0523\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0621-\u064a\u0660-\u0669\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07c0-\u07ea\u07f4-\u07f5\u07fa\u0904-\u0939\u093d\u0950\u0958-\u0961\u0966-\u096f\u0971-\u0972\u097b-\u097f\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09e6-\u09f1\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a66-\u0a6f\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0ae6-\u0aef\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b66-\u0b6f\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0be6-\u0bef\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58-\u0c59\u0c60-\u0c61\u0c66-\u0c6f\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0ce6-\u0cef\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d28\u0d2a-\u0d39\u0d3d\u0d60-\u0d61\u0d66-\u0d6f\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e87-\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa-\u0eab\u0ead-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0ed0-\u0ed9\u0edc-\u0edd\u0f00\u0f20-\u0f29\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8b\u1000-\u102a\u103f-\u1049\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u1090-\u1099\u10a0-\u10c5\u10d0-\u10fa\u10fc\u1100-\u1159\u115f-\u11a2\u11a8-\u11f9\u1200-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u1676\u1681-\u169a\u16a0-\u16ea\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u17e0-\u17e9\u1810-\u1819\u1820-\u1877\u1880-\u18a8\u18aa\u1900-\u191c\u1946-\u196d\u1970-\u1974\u1980-\u19a9\u19c1-\u19c7\u19d0-\u19d9\u1a00-\u1a16\u1b05-\u1b33\u1b45-\u1b4b\u1b50-\u1b59\u1b83-\u1ba0\u1bae-\u1bb9\u1c00-\u1c23\u1c40-\u1c49\u1c4d-\u1c7d\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u2094\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183-\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2c6f\u2c71-\u2c7d\u2c80-\u2ce4\u2d00-\u2d25\u2d30-\u2d65\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3006\u3031-\u3035\u303b-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31b7\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fc3\ua000-\ua48c\ua500-\ua60c\ua610-\ua62b\ua640-\ua65f\ua662-\ua66e\ua680-\ua697\ua722-\ua788\ua78b-\ua78c\ua7fb-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8d0-\ua8d9\ua900-\ua925\ua930-\ua946\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa50-\uaa59\uac00-\ud7a3\uf900-\ufa2d\ufa30-\ufa6a\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc$]+)>)?$/i);
            if (parsed) {
                property = currentType.getProperty(parsed[1]);
            }
            // Invalid property
            if (!property) {
                throw new Error("Path '" + path + "' references unknown property '" + step + "' on type '" + currentType + "'.");
            }
            // Get the current type of the step
            currentType = property.propertyType.meta;
            if (parsed[3]) {
                currentType = rootType.model.types[parsed[3]];
            }
            // Return the property
            return property;
        });
        // create the accessed event and automatically subscribe to property accesses along the path when the event is used
        this.accessed = new events_1.Event(function (event) {
            if (event.hasSubscribers() && !_this.stepAccessed) {
                _this.stepAccessed = [];
                _this.properties.forEach(function (property, index, props) {
                    var handler;
                    var priorProp = index > 0 ? props[index - 1] : null;
                    handler = function (args) {
                        _this.rootType.known().forEach(function (known) {
                            if (_this.testConnection(known, args.entity, priorProp)) {
                                _this.accessed.publish(known, {
                                    entity: known,
                                    property: args.property,
                                    value: args.value
                                });
                            }
                        });
                    };
                    _this.stepAccessed[index] = handler;
                    property.accessed.subscribe(handler);
                });
            }
            else if (!event.hasSubscribers() && _this.stepAccessed) {
                _this.properties.forEach(function (property, index) { return property.accessed.unsubscribe(_this.stepAccessed[index]); });
                _this.stepAccessed = null;
            }
        });
        // create the changed event and automatically subscribe to property changes along the path when the event is used
        this.changed = new events_1.Event(function (event) {
            if (event.hasSubscribers() && !_this.stepChanged) {
                _this.stepChanged = [];
                _this.properties.forEach(function (property, index, props) {
                    var handler;
                    var priorProp = index > 0 ? props[index - 1] : null;
                    handler = function (args) {
                        if (priorProp) {
                            _this.rootType.known().forEach(function (known) {
                                if (_this.testConnection(known, args.entity, priorProp)) {
                                    _this.changed.publish(known, {
                                        entity: known,
                                        property: args.property,
                                        oldValue: args.oldValue,
                                        newValue: args.newValue
                                    });
                                }
                            });
                        }
                        else {
                            _this.changed.publish(args.entity, {
                                entity: args.entity,
                                property: args.property,
                                oldValue: args.oldValue,
                                newValue: args.newValue
                            });
                        }
                    };
                    _this.stepChanged[index] = handler;
                    property.changed.subscribe(handler);
                });
            }
            else if (!event.hasSubscribers() && _this.stepChanged) {
                _this.properties.forEach(function (property, index) { return property.changed.unsubscribe(_this.stepChanged[index]); });
                _this.stepChanged = null;
            }
        });
        // calculate the path
        this.path = getPropertyChainPathFromIndex(this, 0);
    }
    PropertyChain.prototype.equals = function (prop) {
        if (prop === null || prop === undefined) {
            return;
        }
        if (prop instanceof property_1.Property) {
            return this.properties.length === 1 && this.properties[0] === prop;
        }
        if (prop instanceof PropertyChain) {
            if (prop.properties.length !== this.properties.length) {
                return false;
            }
            for (var i = 0; i < this.properties.length; i++) {
                if (!this.properties[i].equals(prop.properties[i])) {
                    return false;
                }
            }
            return true;
        }
    };
    /**
     * Iterates over all objects along a property chain starting with the root object (obj).
     * This is analogous to the Array forEach function. The callback may return a Boolean
     * value to indicate whether or not to continue iterating.
     * @param obj The root object (of type `IEntity`) to use in iterating over the chain.
     * @param callback The function to invoke at each iteration step.  May return a Boolean value to indicate whether or not to continue iterating.
     * @param filter An optional property filter, if specified, only iterates over the results of this property.
     */
    PropertyChain.prototype.each = function (obj, callback, filter /*, target: IEntity, p: number, lastProp: IProperty */) {
        if (filter === void 0) { filter = null; }
        if (obj == null)
            throw new Error("Argument 'obj' cannot be null or undefined.");
        if (callback == null)
            throw new Error("Argument 'callback' cannot be null or undefined.");
        if (typeof (callback) !== "function")
            throw new Error("Argument 'callback' must be of type function: " + callback + ".");
        // invoke callback on obj first
        var target = arguments[3] || obj;
        var lastProp = arguments[5] || null;
        for (var p = arguments[4] || 0; p < this.properties.length; p++) {
            var prop = this.properties[p];
            var isLastProperty = p === this.properties.length - 1;
            var canSkipRemainingProps = isLastProperty || (filter && lastProp === filter);
            var enableCallback = (!filter || lastProp === filter);
            // if the target is a list, invoke the callback once per item in the list
            if (target instanceof Array) {
                for (var i = 0; i < target.length; ++i) {
                    if (enableCallback && callback(target[i], prop) === false) {
                        return false;
                    }
                    if (!canSkipRemainingProps) {
                        var targetValue = prop.value(target[i]);
                        // continue along the chain for this list item
                        if (!targetValue || PropertyChain.prototype.each.call(this, obj, callback, filter, targetValue, p + 1, prop) === false) {
                            return false;
                        }
                    }
                }
                // subsequent properties already visited in preceding loop
                return true;
            }
            else {
                // take into account any chain filters along the way
                if (enableCallback && callback(target, prop) === false) {
                    return false;
                }
            }
            // if a property filter is used and was just evaluated, stop early
            if (canSkipRemainingProps) {
                break;
            }
            // move to next property in the chain
            target = target.__fields__[prop.name];
            // break early if the target is undefined
            if (target === undefined || target === null) {
                break;
            }
            lastProp = prop;
        }
        return true;
    };
    Object.defineProperty(PropertyChain.prototype, "containingType", {
        get: function () {
            return this.rootType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "firstProperty", {
        get: function () {
            return this.properties[0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "lastProperty", {
        get: function () {
            return this.properties[this.properties.length - 1];
        },
        enumerable: false,
        configurable: true
    });
    PropertyChain.prototype.toPropertyArray = function () {
        return this.properties.slice();
    };
    PropertyChain.prototype.getLastTarget = function (obj) {
        for (var p = 0; p < this.properties.length - 1; p++) {
            var prop = this.properties[p];
            // exit early on null or undefined
            if (!obj === undefined || obj === null)
                return obj;
            obj = prop.value(obj);
        }
        return obj;
    };
    PropertyChain.prototype.canSetValue = function (obj, value) {
        return this.lastProperty.canSetValue(this.getLastTarget(obj), value);
    };
    // Determines if this property chain connects two objects.
    PropertyChain.prototype.testConnection = function (fromRoot, toObj, viaProperty) {
        var connected = false;
        // perform simple comparison if no property is defined
        if (!viaProperty) {
            return fromRoot === toObj;
        }
        this.each(fromRoot, function (target) {
            if (target === toObj) {
                connected = true;
                return false;
            }
        }, viaProperty);
        return connected;
    };
    Object.defineProperty(PropertyChain.prototype, "propertyType", {
        get: function () {
            return this.lastProperty.propertyType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "format", {
        get: function () {
            return this.lastProperty.format;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "isList", {
        get: function () {
            return this.lastProperty.isList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "isCalculated", {
        get: function () {
            return this.lastProperty.isCalculated;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "label", {
        get: function () {
            return this.lastProperty.label;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "labelSource", {
        get: function () {
            return this.lastProperty.labelSource;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "labelIsFormat", {
        get: function () {
            return format_1.Format.hasTokens(this.label);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "helptext", {
        get: function () {
            return this.lastProperty.helptext;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "helptextIsFormat", {
        get: function () {
            return format_1.Format.hasTokens(this.helptext);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PropertyChain.prototype, "name", {
        get: function () {
            return this.lastProperty.name;
        },
        enumerable: false,
        configurable: true
    });
    PropertyChain.prototype.value = function (obj, val, additionalArgs) {
        if (obj === void 0) { obj = null; }
        if (val === void 0) { val = null; }
        if (additionalArgs === void 0) { additionalArgs = null; }
        var lastTarget = this.getLastTarget(obj);
        var lastProp = this.lastProperty;
        if (arguments.length > 1) {
            lastProp.value(lastTarget, val, additionalArgs);
        }
        else if (lastTarget) {
            return lastProp.value(lastTarget);
        }
    };
    PropertyChain.prototype.toString = function () {
        var path = this.properties.map(function (e) { return e.name; }).join(".");
        return "this<" + this.rootType + ">." + path;
    };
    return PropertyChain;
}());
exports.PropertyChain = PropertyChain;
function getPropertyChainPathFromIndex(chain, startIndex) {
    var steps = [];
    var props = chain.toPropertyArray();
    var previousStepType;
    props.slice(startIndex).forEach(function (p, i) {
        if (i !== 0) {
            if (p.containingType !== previousStepType && p.containingType.isSubclassOf(previousStepType)) {
                steps[steps.length - 1] = steps[steps.length - 1] + "<" + p.containingType.fullName + ">";
            }
        }
        steps.push(p.name);
        previousStepType = p.propertyType.meta;
    });
    return steps.join(".");
}


/***/ }),

/***/ "../../libs/model.js/lib/property-path.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });


/***/ }),

/***/ "../../libs/model.js/lib/property.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Property$setter = exports.Property$init = exports.Property$pendingInit = exports.Property$generateOwnProperty = exports.Property$generatePrototypeProperty = exports.Property$generateStaticProperty = exports.Property$generateShortcuts = exports.Property$format = exports.evaluateLabel = exports.getLabelSourceType = exports.getLabelFormat = exports.isPropertyOptions = exports.isPropertyBooleanFunction = exports.isPropertyBooleanFunctionAndOptions = exports.isPropertyValueFunction = exports.Property = void 0;
var events_1 = __webpack_require__("../../libs/model.js/lib/events.js");
var format_1 = __webpack_require__("../../libs/model.js/lib/format.js");
var type_1 = __webpack_require__("../../libs/model.js/lib/type.js");
var property_chain_1 = __webpack_require__("../../libs/model.js/lib/property-chain.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
var observable_array_1 = __webpack_require__("../../libs/model.js/lib/observable-array.js");
var rule_1 = __webpack_require__("../../libs/model.js/lib/rule.js");
var calculated_property_rule_1 = __webpack_require__("../../libs/model.js/lib/calculated-property-rule.js");
var string_format_rule_1 = __webpack_require__("../../libs/model.js/lib/string-format-rule.js");
var validation_rule_1 = __webpack_require__("../../libs/model.js/lib/validation-rule.js");
var allowed_values_rule_1 = __webpack_require__("../../libs/model.js/lib/allowed-values-rule.js");
var required_rule_1 = __webpack_require__("../../libs/model.js/lib/required-rule.js");
var range_rule_1 = __webpack_require__("../../libs/model.js/lib/range-rule.js");
var string_length_rule_1 = __webpack_require__("../../libs/model.js/lib/string-length-rule.js");
var list_length_rule_1 = __webpack_require__("../../libs/model.js/lib/list-length-rule.js");
var initilization_context_1 = __webpack_require__("../../libs/model.js/lib/initilization-context.js");
var condition_type_1 = __webpack_require__("../../libs/model.js/lib/condition-type.js");
var Property = /** @class */ (function () {
    function Property(containingType, name, propertyType, isIdentifier, isList, options) {
        this.containingType = containingType;
        this.name = name;
        this.propertyType = propertyType;
        this.isIdentifier = isIdentifier;
        this.isList = isList;
        this.required = false;
        this.rules = [];
        this.getter = Property$makeGetter(this, Property$getter);
        this.setter = Property$makeSetter(this, Property$setter);
        this.changed = new events_1.Event();
        this.accessed = new events_1.Event();
        // Apply property options
        if (options)
            this.extend(options);
    }
    Object.defineProperty(Property.prototype, "isConstant", {
        get: function () {
            return this.constant !== null && this.constant !== undefined;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Property.prototype, "labelIsFormat", {
        get: function () {
            return format_1.Format.hasTokens(this.label);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Property.prototype, "helptextIsFormat", {
        get: function () {
            return format_1.Format.hasTokens(this.helptext);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Property.prototype, "path", {
        get: function () {
            return this.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Property.prototype, "firstProperty", {
        get: function () {
            return this;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Property.prototype, "lastProperty", {
        get: function () {
            return this;
        },
        enumerable: false,
        configurable: true
    });
    Property.prototype.getLastTarget = function (obj) {
        return obj;
    };
    Object.defineProperty(Property.prototype, "defaultValue", {
        get: function () {
            if (this._defaultValue !== undefined) {
                // clone array and date defaults since they are mutable javascript types
                return this._defaultValue instanceof Array ? this._defaultValue.slice() :
                    this._defaultValue instanceof Date ? new Date(+this._defaultValue) :
                        // TODO: Implement TimeSpan class/type?
                        // this._defaultValue instanceof TimeSpan ? new TimeSpan(this._defaultValue.totalMilliseconds) :
                        this._defaultValue;
            }
            else
                return helpers_1.getDefaultValue(this.isList, this.propertyType);
        },
        enumerable: false,
        configurable: true
    });
    Property.prototype.extend = function (options, targetType) {
        var _this = this;
        if (!targetType)
            targetType = this.containingType;
        // Utility function to convert a path string into a resolved array of Property and PropertyChain instances
        function resolveDependsOn(property, rule, dependsOn) {
            // return an empty dependency array if no path was specified
            if (!dependsOn)
                return [];
            // throw an exception if dependsOn is not a string
            if (typeof (dependsOn) !== "string")
                throw new Error("Invalid dependsOn property for '" + rule + "' rule on '" + property + ".");
            // get the property paths for the specified dependency string
            return targetType.getPaths(dependsOn);
        }
        // Use prepare() to defer property path resolution while the model is being extended
        targetType.model.prepare(function () {
            options = __assign({}, options);
            // Label
            if (options.label)
                _this.label = options.label;
            else if (targetType.model.settings.autogeneratePropertyLabels && !_this.label)
                _this.label = _this.name.replace(/(^[a-z]+|[A-Z]{2,}(?=[A-Z][a-z]|$)|[A-Z][a-z]*)/g, " $1").trim();
            // Label Source
            if (options.labelSource) {
                if (typeof (options.labelSource) !== "string")
                    throw new Error("Invalid labelSource property for '" + _this + ".");
                targetType.model.ready(function () {
                    _this.labelSource = targetType.getPath(options.labelSource);
                });
            }
            // Helptext
            _this.helptext = options.helptext;
            // Format
            if (options.format) {
                // Specifier
                if (typeof (options.format) === "string") {
                    var format = options.format;
                    _this.format = targetType.model.getFormat(_this.propertyType, format);
                }
                // Format
                else if (options.format instanceof format_1.Format) {
                    // TODO: convert description/expression/reformat into a Format object
                    _this.format = options.format;
                }
                // String Format
                else if (helpers_1.isType(options.format, function (f) { return helpers_1.getTypeName(f) === "object" && f.expression; })) {
                    var format_2 = options.format;
                    targetType.model.ready(function () {
                        new string_format_rule_1.StringFormatRule(targetType, {
                            property: _this,
                            description: format_2.description,
                            message: format_2.message,
                            expression: format_2.expression,
                            reformat: format_2.reformat
                        })
                            .register();
                    });
                }
                // Error
                else {
                    throw new Error("Invalid 'format' option for '" + _this + "'.");
                }
            }
            // Constant
            if (options.constant !== null && options.constant !== undefined) {
                targetType.model.ready(function () {
                    // Lazily obtain the constant to ensure all types/rules associated with the constant value have been loaded and initialized
                    _this.constant = function () { return targetType.model.serializer.deserialize(null, options.constant, _this, new initilization_context_1.InitializationContext(true)); };
                });
            }
            // Get
            if (options.get) {
                if (typeof (options.get) === "function") {
                    options.get = { function: options.get, dependsOn: "" };
                }
                if (isPropertyOptions(options.get)) {
                    var getOptions_1 = options.get;
                    if (typeof (getOptions_1.function) !== "function") {
                        throw new Error("Invalid property 'get' function of type '" + helpers_1.getTypeName(getOptions_1.function) + "'.");
                    }
                    targetType.model.ready(function () {
                        new calculated_property_rule_1.CalculatedPropertyRule(targetType, null, {
                            property: _this,
                            calculate: getOptions_1.function,
                            onChangeOf: resolveDependsOn(_this, "get", getOptions_1.dependsOn)
                        }).register();
                    });
                }
                else {
                    throw new Error("Invalid property 'get' option of type '" + helpers_1.getTypeName(options.get) + "'.");
                }
            }
            // Set
            if (typeof options.set === "function") {
                var property_1 = _this;
                new rule_1.Rule(targetType, null, {
                    onInit: true,
                    onChangeOf: [_this],
                    execute: function () {
                        options.set.call(this, property_1.value(this));
                    }
                }).register();
            }
            // Init
            if (options.init !== undefined) {
                var initFn = void 0;
                if (isPropertyValueFunction(options.init))
                    initFn = options.init;
                else
                    throw new Error("Invalid property 'init' option of type '" + helpers_1.getTypeName(options.init) + "'.");
                _this.initializer = initFn;
            }
            // Default
            if (options.default !== undefined) {
                if (isPropertyValueFunction(options.default)) {
                    // Always generate a rule for default function
                    options.default = { function: options.default, dependsOn: "" };
                }
                else if (isPropertyOptions(options.default)) {
                    // Use default object as specified
                }
                else if (options.default === null || type_1.isValue(options.default) || type_1.isValueArray(options.default)) {
                    // Constant
                    var defaultConstant_1 = options.default;
                    // Cannot set default constant value for entity-typed property
                    if (type_1.isEntityType(_this.propertyType)) {
                        throw new Error("Cannot set a constant default value for a property of type '" + _this.propertyType.meta.fullName + "'.");
                    }
                    // Verify that the constant value is of the proper built-in type
                    if (options.default !== null && type_1.isValue(options.default)) {
                        var defaultOptionTypeName = helpers_1.getTypeName(defaultConstant_1);
                        var propertyTypeName = helpers_1.getConstructorName(_this.propertyType).toLowerCase();
                        if (defaultOptionTypeName !== propertyTypeName) {
                            throw new Error("Cannot set a default value of type '" + defaultOptionTypeName + "' for a property of type '" + propertyTypeName + "'.");
                        }
                    }
                    // If extending baseType property specifically for a child type, use a rule
                    if (_this.containingType === targetType)
                        _this._defaultValue = defaultConstant_1;
                    else
                        options.default = { function: function () { return defaultConstant_1; }, dependsOn: "" };
                }
                else {
                    throw new Error("Invalid property 'default' option of type '" + helpers_1.getTypeName(options.default) + "'.");
                }
                if (isPropertyOptions(options.default)) {
                    var defaultOptions_1 = options.default;
                    if (typeof (options.default.function) !== "function") {
                        throw new Error("Invalid property 'default' function of type '" + helpers_1.getTypeName(options.default.function) + "'.");
                    }
                    var defaultFn_1 = options.default.function;
                    targetType.model.ready(function () {
                        new calculated_property_rule_1.CalculatedPropertyRule(targetType, null, {
                            property: _this,
                            calculate: defaultFn_1,
                            onChangeOf: resolveDependsOn(_this, "default", defaultOptions_1.dependsOn),
                            isDefaultValue: true
                        }).register();
                    });
                }
            }
            // Allowed Values
            if (options.allowedValues) {
                if (typeof (options.allowedValues) === "function") {
                    var originalAllowedValues_1 = options.allowedValues;
                    var allowedValuesFunction = function () { return originalAllowedValues_1.call(this); };
                    options.get = { function: allowedValuesFunction, dependsOn: "" };
                }
                if (isPropertyOptions(options.allowedValues)) {
                    var allowedValuesOptions_1 = options.allowedValues;
                    if (typeof (options.allowedValues.function) !== "function") {
                        throw new Error("Invalid property 'allowedValues' function of type '" + helpers_1.getTypeName(options.allowedValues.function) + "'.");
                    }
                    targetType.model.ready(function () {
                        (new allowed_values_rule_1.AllowedValuesRule(targetType, {
                            property: _this,
                            source: allowedValuesOptions_1.function,
                            ignoreValidation: allowedValuesOptions_1.ignoreValidation,
                            preventInvalidValues: allowedValuesOptions_1.preventInvalidValues,
                            onChangeOf: resolveDependsOn(_this, "allowedValues", allowedValuesOptions_1.dependsOn)
                        })).register();
                    });
                }
                else {
                    throw new Error("Invalid property 'get' option of type '" + helpers_1.getTypeName(options.get) + "'.");
                }
            }
            // Range
            if (options.range) {
                var min_1;
                if (options.range.min != null) {
                    if (isPropertyValueFunction(options.range.min)) {
                        min_1 = options.range.min;
                    }
                    else if (type_1.isValue(options.range.min)) {
                        var minConstant_1 = options.range.min;
                        min_1 = function () { return minConstant_1; };
                    }
                    else {
                        throw new Error("Invalid property 'range.min' option of type '" + helpers_1.getTypeName(options.range.min) + "'.");
                    }
                }
                var max_1;
                if (options.range.max != null) {
                    if (isPropertyValueFunction(options.range.max)) {
                        max_1 = options.range.max;
                    }
                    else if (type_1.isValue(options.range.max)) {
                        var maxConstant_1 = options.range.max;
                        max_1 = function () { return maxConstant_1; };
                    }
                    else {
                        throw new Error("Invalid property 'range.max' option of type '" + helpers_1.getTypeName(options.range.max) + "'.");
                    }
                }
                targetType.model.ready(function () {
                    var onChangeOf = resolveDependsOn(_this, "range", options.range.dependsOn);
                    new range_rule_1.RangeRule(targetType, { property: _this, onChangeOf: onChangeOf, min: min_1, max: max_1 }).register();
                });
            }
            // Length
            if (options.length) {
                var min_2;
                if (options.length.min != null) {
                    if (isPropertyValueFunction(options.length.min)) {
                        min_2 = options.length.min;
                    }
                    else if (type_1.isValue(options.length.min, Number)) {
                        var minConstant_2 = options.length.min;
                        min_2 = function () { return minConstant_2; };
                    }
                    else {
                        throw new Error("Invalid property 'length.min' option of type '" + helpers_1.getTypeName(options.length.min) + "'.");
                    }
                }
                var max_2;
                if (options.length.max != null) {
                    if (isPropertyValueFunction(options.length.max)) {
                        max_2 = options.length.max;
                    }
                    else if (type_1.isValue(options.length.max, Number)) {
                        var maxConstant_2 = options.length.max;
                        max_2 = function () { return maxConstant_2; };
                    }
                    else {
                        throw new Error("Invalid property 'length.max' option of type '" + helpers_1.getTypeName(options.length.max) + "'.");
                    }
                }
                targetType.model.ready(function () {
                    var onChangeOf = resolveDependsOn(_this, "length", options.length.dependsOn);
                    if (_this.isList) {
                        new list_length_rule_1.ListLengthRule(targetType, { property: _this, onChangeOf: onChangeOf, min: min_2, max: max_2 }).register();
                    }
                    else {
                        new string_length_rule_1.StringLengthRule(targetType, { property: _this, onChangeOf: onChangeOf, min: min_2, max: max_2 }).register();
                    }
                });
            }
            // Required
            if (options.required) {
                var requiredOptions = options.required;
                // Store required options on property so that they can be referenced externally
                _this.required = requiredOptions;
                // Always Required
                if (typeof (options.required) === "boolean") {
                    if (options.required) {
                        targetType.model.ready(function () {
                            var requiredRule = new required_rule_1.RequiredRule(targetType, { property: _this });
                            requiredRule.register();
                        });
                    }
                }
                // Conditionally Required
                else {
                    var requiredFn_1;
                    var requiredMessage_1;
                    var requiredDependsOn_1;
                    if (isPropertyOptions(options.required)) {
                        requiredFn_1 = options.required.function;
                        requiredMessage_1 = options.required.message;
                        requiredDependsOn_1 = options.required.dependsOn;
                    }
                    else {
                        requiredFn_1 = options.required;
                    }
                    targetType.model.ready(function () {
                        (new required_rule_1.RequiredRule(targetType, {
                            property: _this,
                            when: requiredFn_1,
                            message: requiredMessage_1,
                            onChangeOf: requiredDependsOn_1 ? resolveDependsOn(_this, "required", requiredDependsOn_1) : null
                        })).register();
                    });
                }
            }
            // Error
            if (options.error) {
                (Array.isArray(options.error) ? options.error : [options.error]).forEach(function (errorOptions) {
                    var errorFn = errorOptions.function;
                    if (errorOptions.resource)
                        errorFn = function () {
                            return errorOptions.function.call(this) ? targetType.model.getResource(errorOptions.resource) : null;
                        };
                    var errorDependsOn = errorOptions.dependsOn;
                    if (typeof (errorFn) !== "function") {
                        throw new Error("Invalid property 'error' function of type '" + helpers_1.getTypeName(errorOptions.function) + "'.");
                    }
                    var conditionType;
                    if (errorOptions.code)
                        conditionType = condition_type_1.ConditionType.get(errorOptions.code) || new condition_type_1.ErrorConditionType(errorOptions.code, "error");
                    targetType.model.ready(function () {
                        (new validation_rule_1.ValidationRule(targetType, {
                            property: _this,
                            properties: errorOptions.properties ? helpers_1.flatMap(errorOptions.properties, function (p) { return targetType.getPaths(p); }) : null,
                            onChangeOf: resolveDependsOn(_this, "", errorDependsOn),
                            message: errorFn,
                            conditionType: conditionType
                        })).register();
                    });
                });
            }
        });
    };
    Property.prototype.equals = function (prop) {
        if (prop === null || prop === undefined) {
            return;
        }
        if (prop instanceof property_chain_1.PropertyChain) {
            return prop.equals(this);
        }
        if (prop instanceof Property) {
            return this === prop;
        }
    };
    Property.prototype.each = function (obj, callback, filter) {
        if (filter === void 0) { filter = null; }
        if (!filter || filter === this)
            callback(obj, this);
    };
    Property.prototype.toString = function () {
        return "this<" + this.containingType + ">." + this.name;
    };
    Property.prototype.canSetValue = function (obj, val) {
        // NOTE: only allow values of the correct data type to be set in the model
        if (val === undefined) {
            // TODO: Warn about setting value to undefined?
            // logWarning("You should not set property values to undefined, use null instead: property = ." + this._name + ".");
            // console.warn(`You should not set property values to undefined, use null instead: property = ${this.name}.`);
            return true;
        }
        if (val === null) {
            return true;
        }
        // for entities check base types as well
        if (val.constructor && val.constructor.meta) {
            for (var valType = val.constructor.meta; valType; valType = valType.baseType) {
                if (valType.jstype === this.propertyType) {
                    return true;
                }
            }
            return false;
        }
        // Data types
        else {
            var valObjectType = val.constructor;
            // "Normalize" data type in case it came from another frame as well as ensure that the types are the same
            switch (helpers_1.getTypeName(val)) {
                case "string":
                    valObjectType = String;
                    break;
                case "number":
                    valObjectType = Number;
                    break;
                case "boolean":
                    valObjectType = Boolean;
                    break;
                case "date":
                    valObjectType = Date;
                    break;
                case "array":
                    valObjectType = Array;
                    break;
            }
            // value property type check
            return valObjectType === this.propertyType ||
                // entity array type check
                (valObjectType === Array && this.isList && (!this.propertyType || val.every(function (child) {
                    if (type_1.isEntityType(this.propertyType)) {
                        if (child.constructor && child.constructor.meta) {
                            for (var childType = child.constructor.meta; childType; childType = childType.baseType) {
                                if (childType.jstype === this.propertyType) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    else {
                        var itemObjectType = child.constructor;
                        // "Normalize" data type in case it came from another frame as well as ensure that the types are the same
                        switch (helpers_1.getTypeName(child)) {
                            case "string":
                                itemObjectType = String;
                                break;
                            case "number":
                                itemObjectType = Number;
                                break;
                            case "boolean":
                                itemObjectType = Boolean;
                                break;
                            case "date":
                                itemObjectType = Date;
                                break;
                            case "array":
                                itemObjectType = Array;
                                break;
                        }
                        return itemObjectType === this.propertyType;
                    }
                }, this)));
        }
    };
    Property.prototype.value = function (obj, val, additionalArgs) {
        if (obj === void 0) { obj = null; }
        if (val === void 0) { val = null; }
        if (additionalArgs === void 0) { additionalArgs = null; }
        if (obj === undefined || obj === null) {
            throw new Error("Cannot " + (arguments.length > 1 ? "set" : "get") + " value for property \"" + this.name + "\" on type \"" + this.containingType + "\": target is null or undefined.");
        }
        if (arguments.length > 1) {
            Property$setter(this, obj, val, additionalArgs);
        }
        else {
            return Property$getter(this, obj);
        }
    };
    Property.prototype.isInited = function (obj) {
        // If the backing field has been created, the property is initialized
        return obj.__fields__.hasOwnProperty(this.name);
    };
    return Property;
}());
exports.Property = Property;
function isPropertyValueFunction(obj) {
    return typeof (obj) === "function";
}
exports.isPropertyValueFunction = isPropertyValueFunction;
function isPropertyBooleanFunctionAndOptions(obj) {
    return typeof (obj) === "object";
}
exports.isPropertyBooleanFunctionAndOptions = isPropertyBooleanFunctionAndOptions;
function isPropertyBooleanFunction(obj) {
    return typeof (obj) === "function";
}
exports.isPropertyBooleanFunction = isPropertyBooleanFunction;
function isPropertyOptions(obj, check) {
    if (check === void 0) { check = null; }
    return helpers_1.isType(obj, function (d) { return helpers_1.getTypeName(d) === "object" && (!check || check(d)); });
}
exports.isPropertyOptions = isPropertyOptions;
/**
 * Gets a format object for the given property's label, if it is dynamic (i.e. contains format tokens)
 */
function getLabelFormat(property) {
    if (property.label && property.labelIsFormat) {
        var labelSourceType = getLabelSourceType(property);
        return labelSourceType.model.getFormat(labelSourceType.jstype, property.label);
    }
}
exports.getLabelFormat = getLabelFormat;
/**
 * Gets the model type of the source object that should be used to evaluate the
 * property's label, if it is dynamic (i.e. contains format tokens)
 */
function getLabelSourceType(property) {
    // If a label source is specified, then determine it's model type
    if (property.labelSource) {
        var labelSourceType = property.labelSource.propertyType;
        if (type_1.isEntityType(labelSourceType))
            return labelSourceType.meta;
    }
    return property.containingType;
}
exports.getLabelSourceType = getLabelSourceType;
/**
 * Evaluates the given property's label, using the given entity as context if the label is dynamic (i.e. contains format tokens)
 */
function evaluateLabel(property, entity) {
    if (property.labelIsFormat) {
        var labelFormat = getLabelFormat(property);
        var labelFormatInstance = entity;
        if (property.labelSource) {
            labelFormatInstance = property.labelSource.value(entity);
        }
        return labelFormat.convert(labelFormatInstance);
    }
    else {
        return property.label;
    }
}
exports.evaluateLabel = evaluateLabel;
function Property$format(prop, val) {
    if (prop.format) {
        return prop.format.convert(val);
    }
}
exports.Property$format = Property$format;
// export function Property$equals(prop1: Property | IPropertyChain, prop2: Property | IPropertyChain): boolean {
// 	if (prop1 === null || prop1 === undefined || prop2 === null || prop2 === undefined) {
// 		return;
// 	}
// 	if (PropertyChain$isPropertyChain(prop1)) {
// 		return (prop1 as PropertyChain).equals(prop2);
// 	}
// 	if (PropertyChain$isPropertyChain(prop2)) {
// 		return (prop2 as PropertyChain).equals(prop1);
// 	}
// 	if (Property$isProperty(prop1) && Property$isProperty(prop2)) {
// 		return prop1 === prop2;
// 	}
// }
function Property$generateShortcuts(property, target, overwrite) {
    if (overwrite === void 0) { overwrite = null; }
    var shortcutName = "$" + property.name;
    if (!(Object.prototype.hasOwnProperty.call(target, shortcutName)) || overwrite) {
        target[shortcutName] = property;
    }
}
exports.Property$generateShortcuts = Property$generateShortcuts;
function Property$generateStaticProperty(property, target) {
    Object.defineProperty(target, property.name, {
        configurable: false,
        enumerable: true,
        get: property.getter,
        set: property.setter
    });
}
exports.Property$generateStaticProperty = Property$generateStaticProperty;
function Property$generatePrototypeProperty(property, target) {
    Object.defineProperty(target, property.name, {
        configurable: false,
        enumerable: true,
        get: property.getter,
        set: property.setter
    });
}
exports.Property$generatePrototypeProperty = Property$generatePrototypeProperty;
function Property$generateOwnProperty(property, obj) {
    Object.defineProperty(obj, property.name, {
        configurable: false,
        enumerable: true,
        get: property.getter,
        set: property.setter
    });
}
exports.Property$generateOwnProperty = Property$generateOwnProperty;
function Property$pendingInit(obj, prop, value) {
    if (value === void 0) { value = null; }
    var pendingInit;
    if (Object.prototype.hasOwnProperty.call(obj, "__pendingInit__")) {
        pendingInit = obj.__pendingInit__;
    }
    else {
        Object.defineProperty(obj, "__pendingInit__", { enumerable: false, value: (pendingInit = {}), writable: true });
    }
    if (arguments.length > 2) {
        if (value === false) {
            delete pendingInit[prop.name];
        }
        else {
            pendingInit[prop.name] = value;
        }
    }
    else {
        var currentValue = obj.__fields__[prop.name];
        return currentValue === undefined || pendingInit[prop.name] === true;
    }
}
exports.Property$pendingInit = Property$pendingInit;
function Property$subArrayEvents(obj, property, array) {
    array.changed.subscribe(function (args) {
        Property$pendingInit(obj, property, false);
        // Don't raise a no-op list change event
        if (!args.changes.length)
            return;
        // NOTE: oldValue is not currently implemented for lists
        var eventArgs = { entity: obj, property: property, newValue: array };
        // Assign additional collection change event arguments to the property change event
        var additionalArgs = __assign({ changes: args.changes, collectionChanged: true }, args.additionalArgs);
        property.containingType.model.listChanged.publish(obj, helpers_1.merge(eventArgs, additionalArgs));
        property.changed.publish(obj, helpers_1.merge(eventArgs, additionalArgs));
        obj.changed.publish(obj, helpers_1.merge(eventArgs, additionalArgs));
    });
}
function Property$getInitialValue(property) {
    // Constant
    if (property.isConstant)
        return typeof property.constant === "function" ? (property.constant = property.constant()) : property.constant;
    var val = property.defaultValue;
    if (Array.isArray(val)) {
        val = observable_array_1.ObservableArray.ensureObservable(val);
        // Override the default toString on arrays so that we get a comma-delimited list
        // TODO: Implement toString on observable list?
        // val.toString = Property$_arrayToString.bind(val);
    }
    return val;
}
function Property$init(property, obj, val) {
    Property$pendingInit(obj, property, false);
    Object.defineProperty(obj.__fields__, property.name, { value: val, writable: true });
    if (Array.isArray(val)) {
        Property$subArrayEvents(obj, property, observable_array_1.ObservableArray.ensureObservable(val));
    }
    // TODO: Implement observable?
    obj.changed.publish(obj, { entity: obj, property: property, newValue: val });
}
exports.Property$init = Property$init;
function Property$ensureInited(property, obj) {
    // Determine if the property has been initialized with a value and initialize the property if necessary
    if (!obj.__fields__.hasOwnProperty(property.name)) {
        Property$pendingInit(obj, property, true);
        // Do not initialize calculated properties. Calculated properties should be initialized using a property get rule.
        if (!property.isCalculated) {
            var setPendingInit = !property.isConstant;
            Property$init(property, obj, Property$getInitialValue(property));
            if (property.initializer) {
                obj.update(property.name, property.initializer.call(obj));
                setPendingInit = false;
            }
            // Mark the property as pending initialization if the property value may need to
            // be established by a default calculation rule, or some other external logic.
            // This is not relevant if it is a constant or its value is established via an initilizer.
            if (setPendingInit)
                Property$pendingInit(obj, property, true);
        }
    }
}
function Property$getter(property, obj) {
    // Ensure that the property has an initial (possibly default) value
    Property$ensureInited(property, obj);
    // Raise access events
    property.accessed.publish(obj, { entity: obj, property: property, value: obj.__fields__[property.name] });
    obj.accessed.publish(obj, { entity: obj, property: property });
    // Return the property value
    return obj.__fields__[property.name];
}
function Property$setter(property, obj, val, additionalArgs) {
    if (additionalArgs === void 0) { additionalArgs = null; }
    // Ensure that the property has an initial (possibly default) value
    Property$ensureInited(property, obj);
    var old = obj.__fields__[property.name];
    if (Property$shouldSetValue(property, obj, old, val)) {
        Property$setValue(property, obj, old, val, additionalArgs);
    }
    else {
        // Set pendingInit to false here, since the setter is not called since the value is not changing
        Property$pendingInit(obj, property, false);
    }
}
exports.Property$setter = Property$setter;
function Property$shouldSetValue(property, obj, old, val) {
    if (!property.canSetValue(obj, val)) {
        throw new Error("Cannot set " + property.name + "=" + (val === undefined ? "<undefined>" : val) + " for instance " + obj.meta.type.fullName + "|" + obj.meta.id + ": a value of type " + (type_1.isEntityType(property.propertyType) ? property.propertyType.meta.fullName : helpers_1.parseFunctionName(property.propertyType)) + " was expected.");
    }
    for (var _i = 0, _a = property.rules; _i < _a.length; _i++) {
        var rule = _a[_i];
        if (rule instanceof allowed_values_rule_1.AllowedValuesRule && rule.preventInvalidValues && !rule.values(obj).includes(val) && val !== null && val !== undefined) {
            throw new Error("Cannot set " + property.name + ", \"" + val + "\" is not an allowed value.");
        }
    }
    // Update lists as batch remove/add operations
    if (property.isConstant) {
        throw new Error("Constant properties cannot be modified.");
    }
    else {
        // compare values so that this check is accurate for primitives
        var oldValue = (old === undefined || old === null) ? old : old.valueOf();
        var newValue = (val === undefined || val === null) ? val : val.valueOf();
        // Do nothing if the new value is the same as the old value. Account for NaN numbers, which are
        // not equivalent (even to themselves). Although isNaN returns true for non-Number values, we won't
        // get this far for Number properties unless the value is actually of type Number (a number or NaN).
        return (oldValue !== newValue && !(property.propertyType === Number && isNaN(oldValue) && isNaN(newValue)));
    }
}
function Property$setValue(property, obj, currentValue, newValue, additionalArgs) {
    if (additionalArgs === void 0) { additionalArgs = null; }
    // Update lists as batch remove/add operations
    if (property.isList) {
        var currentArray = currentValue;
        currentArray.batchUpdate(function (array) {
            observable_array_1.updateArray(array, newValue);
        }, additionalArgs);
        // Set pendingInit to false here, since an array change event will not be raised if there are no changes
        // (ex: array was previously an empty array and newValue is also an empty array).
        Property$pendingInit(obj, property, false);
    }
    else {
        var oldValue = currentValue;
        // Set or create the backing field value
        if (Object.prototype.hasOwnProperty.call(obj.__fields__, property.name)) {
            obj.__fields__[property.name] = newValue;
        }
        else {
            Object.defineProperty(obj.__fields__, property.name, { value: newValue, writable: true });
        }
        if (property.isIdentifier && newValue && newValue !== obj.meta.id) {
            // If the identifier property is set or changed, then change the object's id and re-pool with the new id
            obj.meta.type.changeObjectId(obj.meta.id, newValue);
        }
        Property$pendingInit(obj, property, false);
        // Do not raise change if the property has not been initialized.
        if (oldValue !== undefined) {
            var eventArgs = { entity: obj, property: property, newValue: newValue, oldValue: oldValue };
            property.containingType.model.afterPropertySet.publish(obj, helpers_1.merge(eventArgs, additionalArgs));
            property.changed.publish(obj, helpers_1.merge(eventArgs, additionalArgs));
            obj.changed.publish(obj, helpers_1.merge(eventArgs, additionalArgs));
        }
    }
}
function Property$makeGetter(property, getter) {
    return function (additionalArgs) {
        if (additionalArgs === void 0) { additionalArgs = null; }
        // ensure the property is initialized
        return getter(property, this, additionalArgs);
    };
}
function Property$makeSetter(prop, setter, skipTypeCheck) {
    // TODO: Is setter "__notifies" needed?
    // setter.__notifies = true;
    if (skipTypeCheck === void 0) { skipTypeCheck = false; }
    return function (val, additionalArgs) {
        if (additionalArgs === void 0) { additionalArgs = null; }
        setter(prop, this, val, additionalArgs, skipTypeCheck);
    };
}


/***/ }),

/***/ "../../libs/model.js/lib/range-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RangeRule = void 0;
var validation_rule_1 = __webpack_require__("../../libs/model.js/lib/validation-rule.js");
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var model_1 = __webpack_require__("../../libs/model.js/lib/model.js");
/**
 * A rule that validates that a property value is within a specific range
 */
var RangeRule = /** @class */ (function (_super) {
    __extends(RangeRule, _super);
    /**
     * Creates a rule that validates a property value is within a specific range
     * @param rootType The model type the rule is for
     * @param options The options for the rule
     */
    function RangeRule(rootType, options) {
        var _this = this;
        // ensure the rule name is specified
        options.name = options.name || "Range";
        options.message = function () {
            var format = options.property.format;
            var val = model_1.normalize(options.property.value(this), format);
            if (val == null) {
                return null;
            }
            var range = {};
            if (options.min && options.min instanceof Function) {
                try {
                    range.min = model_1.normalize(options.min.call(this), format);
                }
                catch (e) {
                    // Silently ignore min errors
                }
            }
            if (options.max && options.max instanceof Function) {
                try {
                    range.max = model_1.normalize(options.max.call(this), format);
                }
                catch (e) {
                    // Silently ignore max errors
                }
            }
            if ((range.min == null || val >= range.min) && (range.max == null || val <= range.max)) {
                // Value is within range
                return null;
            }
            var hasMin = range.min || range.min === 0;
            var hasMax = range.max || range.max === 0;
            if (hasMin && hasMax)
                return rootType.model.getResource("range-between").replace("{min}", property_1.Property$format(options.property, range.min) || range.min).replace("{max}", property_1.Property$format(options.property, range.max) || range.max);
            if (options.property.propertyType === Date) {
                if (hasMin)
                    return rootType.model.getResource("range-on-or-after").replace("{min}", property_1.Property$format(options.property, range.min) || range.min);
                else
                    return rootType.model.getResource("range-on-or-before").replace("{max}", property_1.Property$format(options.property, range.max) || range.max);
            }
            if (hasMin)
                return rootType.model.getResource("range-at-least").replace("{min}", property_1.Property$format(options.property, range.min) || range.min);
            else
                return rootType.model.getResource("range-at-most").replace("{max}", property_1.Property$format(options.property, range.max) || range.max);
        };
        // call the base type constructor
        _this = _super.call(this, rootType, options) || this;
        return _this;
    }
    // get the string representation of the rule
    RangeRule.prototype.toString = function () {
        return this.property.containingType.fullName + "." + this.property.name + " in range, min: , max: ";
    };
    return RangeRule;
}(validation_rule_1.ValidationRule));
exports.RangeRule = RangeRule;


/***/ }),

/***/ "../../libs/model.js/lib/required-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequiredRule = void 0;
var validation_rule_1 = __webpack_require__("../../libs/model.js/lib/validation-rule.js");
/**
 * A rule that validates that a property has a value
 */
var RequiredRule = /** @class */ (function (_super) {
    __extends(RequiredRule, _super);
    /**
     * Creates a rule that validates that a property has a value.
     * @param rootType The model type the rule is for
     * @param options The options for the rule
     */
    function RequiredRule(rootType, options) {
        var _this = this;
        // ensure the rule name is specified
        options.name = options.name || "Required";
        if (typeof options.message === "function") {
            if (options.when) {
                var messageFn_1 = options.message;
                options.message = function () {
                    if (options.when && !options.when.call(this))
                        return null;
                    return messageFn_1.call(this);
                };
            }
        }
        else {
            // ensure the error message is specified
            options.message = options.message || function () { return rootType.model.getResource("required"); };
            if (options.isValid) {
                if (options.when) {
                    var isValidFn_1 = options.isValid;
                    options.isValid = function () {
                        if (options.when && !options.when.call(this)) {
                            // Valid whether or not there is a value, since requiredness is not in effect
                            return true;
                        }
                        return isValidFn_1.apply(this, arguments);
                    };
                }
            }
            else if (options.message) {
                // create the validation function based on the rule options
                options.isValid = function (prop, val) {
                    if (options.when && !options.when.call(this)) {
                        // Valid whether or not there is a value, since requiredness is not in effect
                        return true;
                    }
                    if (val === undefined || val === null)
                        return false;
                    // Blank string does not pass required check
                    if (typeof val === "string" && val.trim() === "")
                        return false;
                    // Empty array does not pass required check
                    if (Array.isArray(val) && val.length === 0)
                        return false;
                    // False does not pass required check
                    if (typeof val === "boolean" && val === false)
                        return false;
                    return true;
                };
            }
        }
        // call the base type constructor
        _this = _super.call(this, rootType, options) || this;
        return _this;
    }
    // get the string representation of the rule
    RequiredRule.prototype.toString = function () {
        return this.property.containingType.fullName + "." + this.property.name + " is required";
    };
    return RequiredRule;
}(validation_rule_1.ValidationRule));
exports.RequiredRule = RequiredRule;


/***/ }),

/***/ "../../libs/model.js/lib/resource-en.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var resource_1 = __webpack_require__("../../libs/model.js/lib/resource.js");
resource_1.defineResources("en", {
    "allowed-values": "{property} is not in the list of allowed values.",
    "listlength-at-least": "Please specify at least {min} {property}.",
    "listlength-at-most": "Please specify no more than {max} {property}.",
    "listlength-between": "Please specify between {min} and {max} {property}.",
    "range-at-least": "{property} must be at least {min}.",
    "range-at-most": "{property} must be at most {max}.",
    "range-between": "{property} must be between {min} and {max}.",
    "range-on-or-after": "{property} must be on or after {min}.",
    "range-on-or-before": "{property} must be on or before {max}.",
    "required": "{property} is required.",
    "string-format": "{property} must be formatted as {formatDescription}.",
    "string-length-at-least": "{property} must be at least {min} characters.",
    "string-length-at-most": "{property} must be at most {max} characters.",
    "string-length-between": "{property} must be between {min} and {max} characters.",
    "format-with-description": "{property} must be formatted as {description}.",
    "format-without-description": "{property} is not properly formatted.",
    "format-currency": "$#,###.##",
    "format-percentage": "#.##%",
    "format-integer": "#,###",
    "format-decimal": "#,###.##"
});


/***/ }),

/***/ "../../libs/model.js/lib/resource.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.resourceExists = exports.getResource = exports.defineResources = exports.setDefaultLocale = exports.Resources = void 0;
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
/**
 * The dictionary of localized resource messages
 */
exports.Resources = {};
function mapContainsResource(resources, locale, name) {
    return helpers_1.hasOwnProperty(resources, locale) && helpers_1.hasOwnProperty(resources[locale], name);
}
/**
 * The default locale, can be changed via `setDefaultLocale(locale)`.
 */
var defaultLocale = null;
/**
 * Sets the default locale
 * @param locale The default locale
 */
function setDefaultLocale(locale) {
    defaultLocale = locale;
}
exports.setDefaultLocale = setDefaultLocale;
/**
 * Globally defined resources
 */
var globalResources = {};
/**
 * Globally define localized resource messages for the given locale
 * @param locale The locale to set messages for
 * @param resources The resources messages
 */
function defineResources(locale, resources) {
    globalResources[locale] = helpers_1.hasOwnProperty(globalResources, locale) ? helpers_1.merge(globalResources[locale], resources) : resources;
}
exports.defineResources = defineResources;
// eslint-disable-next-line no-redeclare
function getResource(name, arg2, arg3) {
    var customResources;
    var locale;
    if (arguments.length === 2) {
        if (typeof arg2 === "object") {
            customResources = arg2;
            locale = null;
        }
        else if (typeof arg2 === "string") {
            customResources = null;
            locale = arg2;
        }
    }
    else if (arguments.length >= 3) {
        customResources = arg2;
        locale = arg3;
    }
    if (!locale)
        locale = defaultLocale || "en";
    var res;
    if (customResources && mapContainsResource(customResources, locale, name))
        res = customResources[locale][name];
    else if (mapContainsResource(globalResources, locale, name))
        res = globalResources[locale][name];
    else
        throw new Error("Resource '" + name + "' is not defined for locale '" + locale + "'.");
    return res;
}
exports.getResource = getResource;
function resourceExists(name, customResources, locale) {
    if (!locale)
        locale = defaultLocale || "en";
    return mapContainsResource(globalResources, locale, name) || (customResources && mapContainsResource(customResources, locale, name));
}
exports.resourceExists = resourceExists;


/***/ }),

/***/ "../../libs/model.js/lib/rule-invocation-type.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleInvocationType = void 0;
var RuleInvocationType;
(function (RuleInvocationType) {
    /** Occurs when an existing instance is initialized. */
    RuleInvocationType[RuleInvocationType["InitExisting"] = 2] = "InitExisting";
    /** Occurs when a new instance is initialized. */
    RuleInvocationType[RuleInvocationType["InitNew"] = 4] = "InitNew";
    /** Occurs when a property value is retrieved. */
    RuleInvocationType[RuleInvocationType["PropertyGet"] = 8] = "PropertyGet";
    /** Occurs when a property value is changed. */
    RuleInvocationType[RuleInvocationType["PropertyChanged"] = 16] = "PropertyChanged";
})(RuleInvocationType = exports.RuleInvocationType || (exports.RuleInvocationType = {}));


/***/ }),

/***/ "../../libs/model.js/lib/rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule$ensureConditionType = exports.Rule = void 0;
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var type_1 = __webpack_require__("../../libs/model.js/lib/type.js");
var rule_invocation_type_1 = __webpack_require__("../../libs/model.js/lib/rule-invocation-type.js");
var condition_type_1 = __webpack_require__("../../libs/model.js/lib/condition-type.js");
var Rule$customRuleIndex = 0;
var Rule = /** @class */ (function () {
    /**
     * Creates a rule that executes a delegate when specified model events occur.
     * @param rootType The model type the rule is for.
     * @param options The options for the rule.
     */
    function Rule(rootType, name, options) {
        this.invocationTypes = 0;
        this.predicates = [];
        this.returnValues = [];
        // Track the root type
        this.rootType = rootType;
        this.name = name || (options ? options.name : null) || (rootType.fullName + ".Custom." + (++Rule$customRuleIndex));
        // Configure the rule based on the specified options
        if (options) {
            if (options.onInit)
                this.onInit();
            if (options.onInitNew)
                this.onInitNew();
            if (options.onInitExisting)
                this.onInitExisting();
            if (options.onChangeOf)
                this.onChangeOf(options.onChangeOf);
            if (options.returns)
                this.returns(options.returns);
            if (options.execute instanceof Function)
                this._execute = options.execute;
        }
    }
    Object.defineProperty(Rule.prototype, "model", {
        get: function () {
            return this.rootType.model;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Rule.prototype, "eventScope", {
        get: function () {
            return this.rootType.model.eventScope;
        },
        enumerable: false,
        configurable: true
    });
    Rule.prototype.execute = function (entity) {
        if (this._execute) {
            this._execute.call(entity);
        }
        else {
            // TODO: Warn about execute function not implemented?
        }
    };
    // Indicates that the rule should run only for new instances when initialized
    Rule.prototype.onInitNew = function () {
        // ensure the rule has not already been registered
        if (this._registered)
            throw new Error("Rules cannot be configured once they have been registered: " + this.name);
        // configure the rule to run on init new
        this.invocationTypes |= rule_invocation_type_1.RuleInvocationType.InitNew;
        return this;
    };
    // indicates that the rule should run only for existing instances when initialized
    Rule.prototype.onInitExisting = function () {
        // ensure the rule has not already been registered
        if (this._registered)
            throw new Error("Rules cannot be configured once they have been registered: " + this.name);
        // configure the rule to run on init existingh
        this.invocationTypes |= rule_invocation_type_1.RuleInvocationType.InitExisting;
        return this;
    };
    // indicates that the rule should run for both new and existing instances when initialized
    Rule.prototype.onInit = function () {
        // ensure the rule has not already been registered
        if (this._registered)
            throw new Error("Rules cannot be configured once they have been registered: " + this.name);
        // configure the rule to run on both init new and init existing
        this.invocationTypes |= rule_invocation_type_1.RuleInvocationType.InitNew | rule_invocation_type_1.RuleInvocationType.InitExisting;
        return this;
    };
    Rule.prototype.onChangeOf = function (predicates) {
        // ensure the rule has not already been registered
        if (this._registered)
            throw new Error("Rules cannot be configured once they have been registered: " + this.name);
        // allow change of predicates to be specified as a parameter array without []'s
        if (!(predicates instanceof Array)) {
            predicates = Array.prototype.slice.call(arguments);
        }
        // add to the set of existing change predicates
        this.predicates = this.predicates.length > 0 ? this.predicates.concat(predicates) : predicates;
        // also configure the rule to run on property change unless it has already been configured to run on property get
        if ((this.invocationTypes & rule_invocation_type_1.RuleInvocationType.PropertyGet) === 0)
            this.invocationTypes |= rule_invocation_type_1.RuleInvocationType.PropertyChanged;
        return this;
    };
    Rule.prototype.returns = function (properties) {
        // Ensure the rule has not already been registered
        if (this._registered)
            throw new Error("Rules cannot be configured once they have been registered: " + this.name);
        // Allow return properties to be specified as a parameter array without []'s
        if (properties && properties.constructor === String)
            properties = Array.prototype.slice.call(arguments);
        if (!properties)
            throw new Error("Rule must specify at least one property for returns.");
        // Add to the set of existing return value properties
        this.returnValues = this.returnValues.length > 0 ? this.returnValues.concat(properties) : properties;
        // Configure the rule to run on property get and not on property change
        this.invocationTypes |= rule_invocation_type_1.RuleInvocationType.PropertyGet;
        this.invocationTypes &= ~rule_invocation_type_1.RuleInvocationType.PropertyChanged;
        return this;
    };
    // registers the rule based on the configured invocation types, predicates, and return values
    Rule.prototype.register = function () {
        var rule = this;
        if (rule._registered) {
            throw new Error("Rules cannot be registered more than once: " + rule.name);
        }
        // Indicate that the rule should now be considered registered and cannot be reconfigured
        Object.defineProperty(this, "_registered", { enumerable: false, value: true, writable: false });
        // register for init new
        if (rule.invocationTypes & rule_invocation_type_1.RuleInvocationType.InitNew) {
            rule.rootType.initNew.subscribe(function (args) { executeRule(rule, args.entity); });
        }
        // register for init existing
        if (rule.invocationTypes & rule_invocation_type_1.RuleInvocationType.InitExisting) {
            rule.rootType.initExisting.subscribe(function (args) { executeRule(rule, args.entity); });
        }
        // register for property change
        if (rule.invocationTypes & rule_invocation_type_1.RuleInvocationType.PropertyChanged) {
            rule.predicates.forEach(function (predicate) {
                predicate.changed.subscribe(function (args) {
                    if (canExecuteRule(rule, args.entity) && !pendingInvocation(args.entity.meta, rule)) {
                        pendingInvocation(args.entity.meta, rule, true);
                        rule.eventScope.onExit(function (e) {
                            pendingInvocation(args.entity.meta, rule, false);
                            if (!e.abort)
                                executeRule(rule, args.entity);
                        });
                    }
                });
            });
        }
        // register for property get
        if (rule.invocationTypes & rule_invocation_type_1.RuleInvocationType.PropertyGet && rule.returnValues) {
            // register for property get events for each return value to calculate the property when accessed
            rule.returnValues.forEach(function (returnValue) {
                returnValue.accessed.subscribe(function (args) {
                    // run the rule to initialize the property if it is pending initialization
                    if (canExecuteRule(rule, args.entity) && property_1.Property$pendingInit(args.entity, returnValue)) {
                        property_1.Property$pendingInit(args.entity, returnValue, false);
                        executeRule(rule, args.entity);
                    }
                });
            });
            // register for property change events for each predicate to invalidate the property value when inputs change
            rule.predicates.forEach(function (predicate) {
                predicate.changed.subscribe(function (args) {
                    if (rule.returnValues.some(function (returnValue) { return returnValue.changed.hasSubscribers(); })) {
                        // Immediately execute the rule if there are explicit event subscriptions for the property
                        if (canExecuteRule(rule, args.entity) && !pendingInvocation(args.entity.meta, rule)) {
                            pendingInvocation(args.entity.meta, rule, true);
                            rule.eventScope.onExit(function (e) {
                                pendingInvocation(args.entity.meta, rule, false);
                                if (!e.abort)
                                    executeRule(rule, args.entity);
                            });
                        }
                    }
                    else {
                        // Otherwise, just mark the property as pending initialization and raise property change for UI subscribers
                        rule.returnValues.forEach(function (returnValue) {
                            property_1.Property$pendingInit(args.entity, returnValue, true);
                        });
                        // Defer change notification until the scope of work has completed
                        rule.eventScope.onExit(function (e) {
                            if (!e.abort) {
                                rule.returnValues.forEach(function (returnValue) {
                                    args.entity.changed.publish(args.entity, { entity: args.entity, property: returnValue, newValue: returnValue.value(args.entity) });
                                });
                            }
                        });
                    }
                });
            });
        }
    };
    return Rule;
}());
exports.Rule = Rule;
function pendingInvocation(target, rule, value) {
    if (value === void 0) { value = null; }
    var pendingInvocation;
    if (Object.prototype.hasOwnProperty.call(target, "__pendingInvocation__")) {
        pendingInvocation = target.__pendingInvocation__;
    }
    else {
        Object.defineProperty(target, "__pendingInvocation__", { enumerable: false, value: (pendingInvocation = []), writable: true });
    }
    var indexOfRule = pendingInvocation.indexOf(rule);
    if (arguments.length > 2) {
        if (value && indexOfRule < 0) {
            pendingInvocation.push(rule);
        }
        else if (!value && indexOfRule >= 0) {
            pendingInvocation.splice(indexOfRule, 1);
        }
    }
    else {
        return indexOfRule >= 0;
    }
}
function canExecuteRule(rule, obj) {
    // ensure the rule target is a valid rule root type
    return obj instanceof rule.rootType.jstype;
}
function executeRule(rule, obj) {
    // Ensure that the rule can be executed.
    if (!canExecuteRule(rule, obj)) {
        // TODO: Warn that rule can't be executed?
        return;
    }
    try {
        rule.eventScope.perform(function () {
            rule.execute(obj);
        });
    }
    catch (e) {
        console.warn("Error encountered while running rule \"" + rule.name + "\".");
        if (e)
            console.warn(e);
    }
}
;
function Rule$ensureConditionType(ruleName, typeOrProp, category) {
    var generatedCode = typeOrProp instanceof property_1.Property ? typeOrProp.containingType.fullName + "." + typeOrProp.name + "." + ruleName :
        typeOrProp instanceof type_1.Type ? typeOrProp + "." + ruleName :
            ruleName;
    var counter = "";
    while (condition_type_1.ConditionType.get(generatedCode + counter))
        counter = (typeof counter === "string" ? 0 : counter) + 1;
    var DesiredConditionType;
    if (category === "Error") {
        DesiredConditionType = condition_type_1.ErrorConditionType;
    }
    else if (category === "Warning") {
        DesiredConditionType = condition_type_1.WarningConditionType;
    }
    else {
        throw new Error("Cannot create condition type for unsupported category '" + category + "'.");
    }
    // return a new client condition type of the specified category
    return new DesiredConditionType(generatedCode + counter, "Generated condition type for " + ruleName + " rule.");
}
exports.Rule$ensureConditionType = Rule$ensureConditionType;


/***/ }),

/***/ "../../libs/model.js/lib/string-format-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringFormatRule = void 0;
var validation_rule_1 = __webpack_require__("../../libs/model.js/lib/validation-rule.js");
var StringFormatRule = /** @class */ (function (_super) {
    __extends(StringFormatRule, _super);
    /**
     * Creates a rule that validates that a string property value is correctly formatted.
     * @param rootType The model type the rule is for.
     * @param options The options for the rules.
     */
    function StringFormatRule(rootType, options) {
        var _this = this;
        // exit immediately if called with no arguments
        if (arguments.length > 0) {
            // ensure the rule name is specified
            options.name = options.name || "StringFormat";
            // see if the error message is a valid resource: {resource-name}
            if (typeof options.message === "string" && rootType.model.resourceExists(options.message)) {
                var message_1 = options.message;
                options.message = function () { return rootType.model.getResource(message_1); };
            }
            // get the default validation message if not specified
            if (!options.message) {
                options.message = function () { return rootType.model.getResource("string-format").replace("{formatDescription}", options.description); };
            }
            var expression_1 = options.expression instanceof RegExp ? options.expression : RegExp(options.expression);
            var reformat_1 = options.reformat;
            // create the string format validation function
            options.isValid = function (prop, val) {
                var isValid = true;
                if (val && val !== "") {
                    expression_1.lastIndex = 0;
                    isValid = expression_1.test(val);
                    if (isValid && options.reformat) {
                        if (reformat_1 instanceof Function) {
                            val = reformat_1(val);
                        }
                        else {
                            expression_1.lastIndex = 0;
                            val = val.replace(expression_1, reformat_1);
                        }
                        prop.value(this, val);
                    }
                }
                return isValid;
            };
        }
        // call the base type constructor
        _this = _super.call(this, rootType, options) || this;
        // define properties for the rule
        _this.description = options.description;
        return _this;
    }
    // get the string representation of the rule
    StringFormatRule.prototype.toString = function () {
        return this.property.containingType.fullName + "." + this.property.name + " formatted as " + this.description;
    };
    return StringFormatRule;
}(validation_rule_1.ValidationRule));
exports.StringFormatRule = StringFormatRule;


/***/ }),

/***/ "../../libs/model.js/lib/string-length-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringLengthRule = void 0;
var validation_rule_1 = __webpack_require__("../../libs/model.js/lib/validation-rule.js");
/**
 * A rule that validates that validates that the length of a string property is within a specific range
 */
var StringLengthRule = /** @class */ (function (_super) {
    __extends(StringLengthRule, _super);
    /**
     * Creates a rule that validates that the length of a string property is within a specific range
     * @param rootType The model type the rule is for
     * @param options The options for the rule
     */
    function StringLengthRule(rootType, options) {
        var _this = this;
        // ensure the rule name is specified
        options.name = options.name || "StringLength";
        options.message = function () {
            var range = {};
            if (options.min && options.min instanceof Function) {
                try {
                    range.min = options.min.call(this);
                }
                catch (e) {
                    // Silently ignore min errors
                }
            }
            if (options.max && options.max instanceof Function) {
                try {
                    range.max = options.max.call(this);
                }
                catch (e) {
                    // Silently ignore max errors
                }
            }
            var val = options.property.value(this);
            if (val == null || typeof val !== "string" || val.length === 0) {
                return null;
            }
            if ((range.min == null || val.length >= range.min) && (range.max == null || val.length <= range.max)) {
                // Value is within range
                return null;
            }
            if (range.min != null && range.max != null)
                return rootType.model.getResource("string-length-between").replace("{min}", range.min.toString()).replace("{max}", range.max.toString());
            if (range.min != null)
                return rootType.model.getResource("string-length-at-least").replace("{min}", range.min.toString());
            else
                return rootType.model.getResource("string-length-at-most").replace("{max}", range.max.toString());
        };
        // call the base type constructor
        _this = _super.call(this, rootType, options) || this;
        return _this;
    }
    // get the string representation of the rule
    StringLengthRule.prototype.toString = function () {
        return this.property.containingType.fullName + "." + this.property.name + " string length, min: , max: ";
    };
    return StringLengthRule;
}(validation_rule_1.ValidationRule));
exports.StringLengthRule = StringLengthRule;


/***/ }),

/***/ "../../libs/model.js/lib/type.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Type$generateConstructor = exports.Type$generateMethod = exports.getIdFromState = exports.isEntityType = exports.isValueArray = exports.isValue = exports.isValueType = exports.Type = exports.Type$newIdPrefix = void 0;
var entity_1 = __webpack_require__("../../libs/model.js/lib/entity.js");
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var helpers_1 = __webpack_require__("../../libs/model.js/lib/helpers.js");
var events_1 = __webpack_require__("../../libs/model.js/lib/events.js");
var observable_array_1 = __webpack_require__("../../libs/model.js/lib/observable-array.js");
var rule_1 = __webpack_require__("../../libs/model.js/lib/rule.js");
var format_1 = __webpack_require__("../../libs/model.js/lib/format.js");
var property_chain_1 = __webpack_require__("../../libs/model.js/lib/property-chain.js");
exports.Type$newIdPrefix = "+c";
var Type = /** @class */ (function () {
    // readonly conditionsChanged: EventSubscriber<Type, ConditionTargetsChangedEventArgs>;
    function Type(model, fullName, baseType, format, options) {
        if (baseType === void 0) { baseType = null; }
        this.model = model;
        this.fullName = fullName;
        this.jstype = Type$generateConstructor(this, fullName, baseType, model.settings.useGlobalObject ? helpers_1.getGlobalObject() : null);
        this.baseType = baseType;
        this.derivedTypes = [];
        this._identifier = null;
        Object.defineProperty(this, "__pool__", { enumerable: false, configurable: false, writable: false, value: {} });
        Object.defineProperty(this, "__properties__", { enumerable: false, configurable: false, writable: false, value: {} });
        Object.defineProperty(this, "_lastId", { enumerable: false, configurable: false, writable: true, value: 0 });
        Object.defineProperty(this, "_formats", { enumerable: false, configurable: false, writable: true, value: {} });
        Object.defineProperty(this, "_chains", { enumerable: false, configurable: false, writable: true, value: {} });
        if (baseType) {
            baseType.derivedTypes.push(this);
        }
        this.initNew = new events_1.Event();
        this.initExisting = new events_1.Event();
        // this.conditionsChanged = new Event<Type, ConditionTargetsChangedEventArgs>();
        // Set Format
        if (format) {
            if (typeof (format) === "string") {
                this.format = this.model.getFormat(this.jstype, format);
            }
            else
                this.format = format;
        }
        // Apply type options
        if (options)
            this.extend(options);
    }
    Object.defineProperty(Type.prototype, "identifier", {
        get: function () {
            if (this._identifier)
                return this._identifier;
            return this.baseType ? this.baseType.identifier : null;
        },
        set: function (val) {
            this._identifier = val;
        },
        enumerable: false,
        configurable: true
    });
    Type.prototype.createIfNotExists = function (state) {
        var id = getIdFromState(this, state);
        if (id) {
            var existing = this.get(id);
            if (existing)
                return existing;
        }
        var Ctor = this.jstype;
        // Construct an instance using the known id if it is present
        var instance = (id ? new Ctor(id, state) : new Ctor(state));
        return instance;
    };
    Type.prototype.createSync = function (state) {
        var id = getIdFromState(this, state);
        if (id && this.get(id))
            throw new Error("Could not create instance of type '" + this.fullName + "' with identifier '" + id + "' because this object already exists.");
        var Ctor = this.jstype;
        // Construct an instance using the known id if it is present
        var instance = (id ? new Ctor(id, state) : new Ctor(state));
        return instance;
    };
    Type.prototype.create = function (state) {
        var instance = this.createSync(state);
        return instance.initialized.then(function () { return instance; });
    };
    /** Generates a unique id suitable for an instance in the current type hierarchy. */
    Type.prototype.newId = function () {
        var lastId;
        for (var type = this; type; type = type.baseType) {
            lastId = Math.max(lastId || 0, type._lastId);
        }
        var nextId = lastId + 1;
        // Update the last id for each type in the heirarchy.
        for (var type = this; type; type = type.baseType) {
            type._lastId = nextId;
        }
        // Return the new id.
        return exports.Type$newIdPrefix + nextId;
    };
    Type.prototype.assertValidId = function (id) {
        if (id === null || id === undefined) {
            throw new Error("Id cannot be " + (id === null ? "null" : "undefined") + " (entity = " + this.fullName + ").");
        }
        else if (helpers_1.getTypeName(id) !== "string") {
            throw new Error("Id must be a string:  encountered id " + id + " of type \"" + helpers_1.parseFunctionName(id.constructor) + "\" (entity = " + this.fullName + ").");
        }
        else if (id === "") {
            throw new Error("Id cannot be a blank string (entity = " + this.fullName + ").");
        }
    };
    Type.prototype.register = function (obj) {
        this.assertValidId(obj.meta.id);
        var key = obj.meta.id.toLowerCase();
        for (var t = this; t; t = t.baseType) {
            if (t.__pool__.hasOwnProperty(key)) {
                throw new Error("Object \"" + this.fullName + "|" + obj.meta.id + "\" has already been registered.");
            }
            t.__pool__[key] = obj;
            if (t.__known__) {
                t.__known__.push(obj);
            }
        }
        if (this.model.settings.createOwnProperties === true) {
            for (var prop in this.__properties__) {
                if (Object.prototype.hasOwnProperty.call(this.__properties__, prop)) {
                    var property = this.__properties__[prop];
                    property_1.Property$generateOwnProperty(property, obj);
                }
            }
        }
        this.model.entityRegistered.publish(this.model, { entity: obj });
    };
    Type.prototype.changeObjectId = function (oldId, newId) {
        this.assertValidId(oldId);
        this.assertValidId(newId);
        var oldKey = oldId.toLowerCase();
        var newKey = newId.toLowerCase();
        if (this.__pool__[newKey]) {
            throw new Error("Entity '" + this.fullName + "|" + newKey + "' is already registered.");
        }
        var obj = this.__pool__[oldKey];
        if (!obj) {
            // TODO: Throw error or warn when attempting to change an object Id that is unknown?
            return;
        }
        for (var t = this; t; t = t.baseType) {
            t.__pool__[newKey] = obj;
        }
        obj.meta.id = newId;
        obj.markPersisted();
        return obj;
    };
    Type.prototype.get = function (id, exactTypeOnly) {
        if (exactTypeOnly === void 0) { exactTypeOnly = false; }
        if (!id) {
            throw new Error("Method \"" + this.fullName + ".meta.get()\" was called without a valid id argument.");
        }
        var key = id.toLowerCase();
        var obj = this.__pool__[key];
        // If exactTypeOnly is specified, don't return sub-types.
        if (obj && exactTypeOnly === true && obj.meta.type !== this) {
            throw new Error("The entity with id='" + id + "' is expected to be of type '" + this.fullName + "' but found type '" + obj.meta.type.fullName + "'.");
        }
        return obj;
    };
    // Gets an array of all objects of this type that have been registered.
    // The returned array is observable and collection changed events will be raised
    // when new objects are registered.
    // The array is in no particular order.
    Type.prototype.known = function () {
        var known = this.__known__;
        if (!known) {
            var list = [];
            for (var id in this.__pool__) {
                if (Object.prototype.hasOwnProperty.call(this.__pool__, id)) {
                    list.push(this.__pool__[id]);
                }
            }
            known = observable_array_1.ObservableArray.ensureObservable(list);
            Object.defineProperty(this, "__known__", { enumerable: false, configurable: false, writable: false, value: known });
        }
        return known;
    };
    Type.prototype.getProperty = function (name) {
        var prop;
        for (var t = this; t && !prop; t = t.baseType) {
            prop = t.__properties__[name];
            if (prop) {
                return prop;
            }
        }
        return null;
    };
    /** Gets the {Property} or {PropertyChain} for the specified simple path {string}. */
    Type.prototype.getPath = function (path) {
        // Get single property
        var property = this.getProperty(path);
        // Get cached property chain
        if (!property)
            property = this._chains[path];
        // Create and cache property chain
        if (!property) {
            property = this._chains[path] = new property_chain_1.PropertyChain(this, path);
        }
        // Return the property path
        return property;
    };
    /** Gets and array of {Property} or {PropertyChain} instances for the specified complex graph path {string}. */
    Type.prototype.getPaths = function (path) {
        var start = 0;
        var paths = [];
        // Process the path
        if (/{|,|}/g.test(path)) {
            var stack = [];
            var parent_1;
            for (var i = 0, len = path.length; i < len; ++i) {
                var c = path.charAt(i);
                if (c === "{" || c === "," || c === "}") {
                    var seg = path.substring(start, i).trim();
                    start = i + 1;
                    if (c === "{") {
                        if (parent_1) {
                            stack.push(parent_1);
                            parent_1 += "." + seg;
                        }
                        else {
                            parent_1 = seg;
                        }
                    }
                    else { // ',' or '}'
                        if (seg.length > 0) {
                            paths.push(this.getPath(parent_1 ? parent_1 + "." + seg : seg));
                        }
                        if (c === "}") {
                            parent_1 = (stack.length === 0) ? undefined : stack.pop();
                        }
                    }
                }
            }
            if (stack.length > 0 || parent_1) {
                throw new Error("Unclosed '{' in path: " + path);
            }
            if (start < path.length) {
                var seg = path.substring(start).trim();
                if (seg.length > 0) {
                    paths.push(this.getPath(seg));
                }
                // Set start to past the end of the list to indicate that the entire string was processed
                start = path.length;
            }
        }
        // If the input is a simple property or path, then add the single property or chain
        if (start === 0) {
            paths.push(this.getPath(path.trim()));
        }
        return paths;
    };
    Object.defineProperty(Type.prototype, "properties", {
        get: function () {
            var propertiesObject = __assign({}, this.__properties__);
            for (var type = this.baseType; type != null; type = type.baseType) {
                for (var propertyName in type.__properties__) {
                    if (!propertiesObject.hasOwnProperty(propertyName)) {
                        propertiesObject[propertyName] = type.__properties__[propertyName];
                    }
                }
            }
            return Object.values(propertiesObject);
        },
        enumerable: false,
        configurable: true
    });
    Type.prototype.addRule = function (optionsOrFunction) {
        var options;
        if (optionsOrFunction) {
            // The options are the function to execute
            if (optionsOrFunction instanceof Function) {
                options = { execute: optionsOrFunction };
            }
            else {
                options = optionsOrFunction;
            }
        }
        var rule = new rule_1.Rule(this, options.name, options);
        // TODO: Track rules on the type?
        return rule;
    };
    Type.prototype.hasModelProperty = function (prop) {
        return prop.containingType === this || this.isSubclassOf(prop.containingType);
    };
    Type.prototype.isSubclassOf = function (type) {
        var result = false;
        helpers_1.navigateAttribute(this, "baseType", function (baseType) {
            if (baseType === type) {
                result = true;
                return false;
            }
        });
        return result;
    };
    Type.prototype.toString = function () {
        return this.fullName;
    };
    /**
     * Extends the current type with the specified format, properties and methods
     * @param options The options specifying how to extend the type
     */
    Type.prototype.extend = function (options) {
        var _this = this;
        var type = this;
        // Utility function to convert a path string into a resolved array of Property and PropertyChain instances
        function resolveDependsOn(rule, dependsOn) {
            // return an empty dependency array if no path was specified
            if (!dependsOn)
                return [];
            // throw an exception if dependsOn is not a string
            if (typeof (dependsOn) !== "string")
                throw new Error("Invalid dependsOn property for '" + rule + "' rule on '" + type + ".");
            // get the property paths for the specified dependency string
            return type.getPaths(dependsOn);
        }
        // Use prepare() to defer property path resolution while the model is being extended
        this.model.prepare(function () {
            var isRuleMethod = function (value) { return value.hasOwnProperty("function"); };
            var _loop_1 = function (name_1, member) {
                if (name_1.startsWith("$"))
                    return "continue";
                // Ignore Type and Format values, which do not represent type members
                if (member instanceof Type || member instanceof format_1.Format)
                    return "continue";
                // Property Type Name
                if (typeof (member) === "string")
                    member = { type: member };
                // Property Type
                else if (isValueType(member))
                    member = { type: member };
                // Non-Rule Method/Function
                if (typeof (member) === "function") {
                    Type$generateMethod(_this, _this.jstype.prototype, name_1, member);
                }
                // Rule Method
                else if (isRuleMethod(member)) {
                    var func = member.function, dependsOn_1 = member.dependsOn;
                    Type$generateMethod(_this, _this.jstype.prototype, name_1, func);
                    _this.model.ready(function () {
                        new rule_1.Rule(_this, _this.fullName + "." + name_1 + "Rule", {
                            execute: (new Function("return this." + name_1 + "();")),
                            onChangeOf: resolveDependsOn("get", dependsOn_1)
                        }).register();
                    });
                }
                // Property
                else {
                    member = __assign({}, member);
                    // Get Property
                    var property = _this.getProperty(name_1);
                    // Add Property
                    if (!property
                        || (member.type && isEntityType(property.propertyType) && property.propertyType.meta.fullName !== member.type)
                        || (member.type && isValueType(member.type) && isValueType(property.propertyType) && property.propertyType !== member.type)) {
                        // Type & IsList
                        var isList = false;
                        if (typeof (member.type) === "string") {
                            var typeName = member.type;
                            // Type names ending in [] are lists
                            if (typeName.lastIndexOf("[]") === (typeName.length - 2)) {
                                isList = true;
                                typeName = typeName.substr(0, typeName.length - 2);
                            }
                            // Convert type names to javascript types
                            member.type = _this.model.getJsType(typeName);
                            // Warn if the type couldn't be found
                            if (!member.type && window.console && console.warn) {
                                console.warn("Could not resolve type '" + typeName + ".");
                            }
                        }
                        var isIdentifier = member.identifier === true;
                        // Add Property
                        var property_2 = new property_1.Property(_this, name_1, member.type, isIdentifier, isList, member);
                        if (isIdentifier) {
                            _this.identifier = property_2;
                        }
                        _this.__properties__[name_1] = property_2;
                        property_1.Property$generateShortcuts(property_2, _this.jstype);
                        if (!_this.model.settings.createOwnProperties) {
                            property_1.Property$generatePrototypeProperty(property_2, _this.jstype.prototype);
                        }
                    }
                    else {
                        property.extend(member, _this);
                    }
                }
            };
            // Type Members
            for (var _i = 0, _a = helpers_1.entries(options); _i < _a.length; _i++) {
                var _b = _a[_i], name_1 = _b[0], member = _b[1];
                _loop_1(name_1, member);
            }
        });
    };
    return Type;
}());
exports.Type = Type;
function isValueType(type) {
    return type === String || type === Number || type === Date || type === Boolean;
}
exports.isValueType = isValueType;
function isValue(value, type) {
    if (type === void 0) { type = null; }
    if (value == null)
        return false;
    var valueType = value.constructor;
    if (type != null)
        return valueType === type;
    return isValueType(valueType);
}
exports.isValue = isValue;
function isValueArray(value) {
    if (value == null)
        return false;
    if (!Array.isArray(value))
        return false;
    if (value.length === 0)
        return true;
    var item = value[0];
    if (item == null)
        return false;
    var itemType = item.constructor;
    return isValueType(itemType);
}
exports.isValueArray = isValueArray;
function isEntityType(type) {
    return type.meta && type.meta instanceof Type;
}
exports.isEntityType = isEntityType;
function getIdFromState(type, state) {
    if (type.identifier && typeof state === "object") {
        var id = state[type.identifier.name];
        if (id && typeof id === "string" && id.length > 0)
            return id;
    }
}
exports.getIdFromState = getIdFromState;
function Type$generateMethod(type, target, name, fn) {
    target[name] = fn;
}
exports.Type$generateMethod = Type$generateMethod;
// TODO: Get rid of disableConstruction?
var disableConstruction = false;
function Type$generateConstructor(type, fullName, baseType, global) {
    if (baseType === void 0) { baseType = null; }
    if (global === void 0) { global = null; }
    // Create namespaces as needed
    var nameTokens = fullName.split(".");
    var token = nameTokens.shift();
    var namespaceObj = type.model.$namespace || type.model;
    var namespacePrefix = "";
    var globalObj = global;
    while (nameTokens.length > 0) {
        namespacePrefix = namespacePrefix + token + ".";
        namespaceObj = helpers_1.ensureNamespace(token, namespaceObj);
        if (global) {
            globalObj = helpers_1.ensureNamespace(token, globalObj);
        }
        token = nameTokens.shift();
    }
    // The final name to use is the last token
    var finalName = token;
    var BaseConstructor;
    if (baseType) {
        BaseConstructor = baseType.jstype;
        // // TODO: Implement `inheritBaseTypePropShortcuts`
        // // inherit all shortcut properties that have aleady been defined
        // inheritBaseTypePropShortcuts(ctor, baseType);
    }
    else {
        BaseConstructor = entity_1.Entity;
    }
    var ctorFactory = new Function("construct", "return function " + finalName + " () { construct.apply(this, arguments); }");
    function construct() {
        if (!disableConstruction) {
            try {
                entity_1.Entity.ctorDepth++;
                var args = Array.from(arguments);
                if (!(args[0] instanceof Type))
                    args.unshift(type);
                BaseConstructor.apply(this, args);
            }
            finally {
                entity_1.Entity.ctorDepth--;
            }
        }
    }
    var ctor = ctorFactory(construct);
    var namespaceKey = finalName;
    // If the namespace already contains a type with this name, prepend a '$' to the name
    while (namespaceObj[namespaceKey]) {
        if (true) {
            console.warn("Namespace path '" + namespacePrefix + namespaceKey + "' is already assigned.");
        }
        namespaceKey = "$" + namespaceKey;
    }
    namespaceObj[namespaceKey] = ctor;
    if (global) {
        var globalKey = finalName;
        // If the global object already contains a type with this name, append a '$' to the name
        while (globalObj[globalKey]) {
            if (true) {
                console.warn("Global path '" + namespacePrefix + globalKey + "' is already assigned.");
            }
            globalKey = "$" + globalKey;
        }
        globalObj[globalKey] = ctor;
    }
    // Setup inheritance
    disableConstruction = true;
    ctor.prototype = new BaseConstructor();
    disableConstruction = false;
    ctor.prototype.constructor = ctor;
    // Add the 'meta' helper
    Object.defineProperty(ctor, "meta", { enumerable: false, value: type, configurable: false, writable: false });
    return ctor;
}
exports.Type$generateConstructor = Type$generateConstructor;


/***/ }),

/***/ "../../libs/model.js/lib/validation-rule.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationRule = void 0;
var condition_rule_1 = __webpack_require__("../../libs/model.js/lib/condition-rule.js");
var property_1 = __webpack_require__("../../libs/model.js/lib/property.js");
var ValidationRule = /** @class */ (function (_super) {
    __extends(ValidationRule, _super);
    function ValidationRule(rootType, options) {
        var _this = this;
        // ensure the rule name is specified
        options.name = options.name || "ValidatedProperty";
        // store the property being validated
        var property = options.property;
        // ensure the properties and predicates to include the target property
        if (!options.properties)
            options.properties = [];
        if (!options.properties.includes(property))
            options.properties.push(property);
        if (!options.onChangeOf) {
            options.onChangeOf = [property];
        }
        else if (options.onChangeOf.indexOf(property) < 0) {
            options.onChangeOf.push(property);
        }
        // default condition category to Error if a condition category was not specified
        if (!options.conditionType) {
            options.category = "Error";
        }
        // replace the property label token in the validation message if present
        if (options.message && (typeof options.message === "function" || (typeof options.message === "string" && options.message.indexOf("{property}") >= 0))) {
            // Property label with dynamic format tokens
            if (property.labelIsFormat) {
                var labelSourceType_1 = property_1.getLabelSourceType(property);
                var labelFormat = property_1.getLabelFormat(property);
                // ensure tokens included in the format trigger rule execution
                labelFormat.paths.forEach(function (p) {
                    labelSourceType_1.getPaths(p).forEach(function (prop) {
                        var labelTokenProp = prop;
                        if (property.labelSource) {
                            labelTokenProp = rootType.getPath(property.labelSource.path + "." + prop.path);
                        }
                        if (!options.onChangeOf) {
                            options.onChangeOf = [labelTokenProp];
                        }
                        else if (options.onChangeOf.indexOf(labelTokenProp) < 0) {
                            options.onChangeOf.push(labelTokenProp);
                        }
                    });
                });
                if (typeof options.message === "function") {
                    var messageFunction_1 = options.message;
                    // Create a function to apply the format to the property label when generating the message
                    options.message = function () {
                        var message = "";
                        try {
                            message = messageFunction_1.call(this);
                            if (typeof message === "string") {
                                if (message.trim().length > 0 && message.indexOf("{property}") >= 0) {
                                    message = message.replace("{property}", property_1.evaluateLabel(property, this));
                                }
                            }
                            else if (message != null) {
                                console.warn("Converting message of type '" + (typeof message) + "' for rule '" + options.name + "' to a string.");
                                message = message.toString();
                            }
                        }
                        catch (e) {
                            console.warn(e);
                        }
                        return message;
                    };
                }
                else if (typeof options.message === "string") {
                    var messageTemplate_1 = options.message;
                    // Create a function to apply the format to the property label when generating the message
                    options.message = function () {
                        return messageTemplate_1.replace("{property}", property_1.evaluateLabel(property, this));
                    };
                }
            }
            // Static property label
            else if (typeof options.message === "string") {
                options.message = options.message.replace("{property}", property.label);
            }
            // Use static property label in function return value
            else if (typeof options.message === "function") {
                var messageFunction_2 = options.message;
                // Create a function to apply the format to the property label when generating the message
                options.message = function () {
                    var message = "";
                    try {
                        message = messageFunction_2.call(this);
                        if (typeof message === "string") {
                            if (message.trim().length > 0 && message.indexOf("{property}") >= 0) {
                                message = message.replace("{property}", property.label);
                            }
                        }
                        else if (message != null) {
                            console.warn("Converting message of type '" + (typeof message) + "' for rule '" + options.name + "' to a string.");
                            message = message.toString();
                        }
                    }
                    catch (e) {
                        console.warn(e);
                    }
                    return message;
                };
            }
        }
        if (options.isValid) {
            options.assert = function () {
                var isValid;
                try {
                    isValid = options.isValid.call(this, options.property, options.property.value(this));
                }
                catch (e) {
                    console.warn(e);
                }
                return isValid === undefined ? isValid : !isValid;
            };
        }
        // call the base rule constructor
        _this = _super.call(this, rootType, options) || this;
        Object.defineProperty(_this, "property", { value: property });
        // register the rule with the target property
        _this.property.rules.push(_this);
        return _this;
    }
    return ValidationRule;
}(condition_rule_1.ConditionRule));
exports.ValidationRule = ValidationRule;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL2FsbG93ZWQtdmFsdWVzLXJ1bGUuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9jYWxjdWxhdGVkLXByb3BlcnR5LXJ1bGUuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9jb25kaXRpb24tcnVsZS5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL2NvbmRpdGlvbi10YXJnZXQuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9jb25kaXRpb24tdHlwZS1zZXQuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9jb25kaXRpb24tdHlwZS5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL2NvbmRpdGlvbi5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL2VudGl0eS1zZXJpYWxpemVyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvZW50aXR5LmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvZXZlbnQtc2NvcGUuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9mb3JtYXQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9mb3JtYXQuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9mdW5jdG9yLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvZ2xvYmFsaXphdGlvbi5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL2luaXRpbGl6YXRpb24tY29udGV4dC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL2xpc3QtbGVuZ3RoLXJ1bGUuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9tb2RlbC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL29iamVjdC1tZXRhLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvb2JzZXJ2YWJsZS1hcnJheS5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL3Byb3BlcnR5LWNoYWluLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvcHJvcGVydHktcGF0aC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL3Byb3BlcnR5LmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvcmFuZ2UtcnVsZS5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL3JlcXVpcmVkLXJ1bGUuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9yZXNvdXJjZS1lbi5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL3Jlc291cmNlLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvcnVsZS1pbnZvY2F0aW9uLXR5cGUuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL21vZGVsLmpzL2xpYi9ydWxlLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvc3RyaW5nLWZvcm1hdC1ydWxlLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvc3RyaW5nLWxlbmd0aC1ydWxlLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy9tb2RlbC5qcy9saWIvdHlwZS5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvbW9kZWwuanMvbGliL3ZhbGlkYXRpb24tcnVsZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsNENBQW1CO0FBQ25ELGlCQUFpQixtQkFBTyxDQUFDLHFDQUFZO0FBQ3JDLHVCQUF1QixtQkFBTyxDQUFDLDJDQUFrQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQscURBQXFEO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsaUNBQWlDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG1DQUFtQyxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7OztBQzVFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdURBQXVELEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdDQUF3QyxFQUFFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxnQkFBZ0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxxRUFBcUUsRUFBRTtBQUM1TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxFQUFFO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEM7QUFDQTtBQUNBLG9DQUFvQyxFQUFFO0FBQ3RDO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQiw0SkFBNEo7QUFDL0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7Ozs7Ozs7O0FDdHNDQSw4Q0FBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQkFBZ0I7QUFDN0MsNkJBQTZCLGFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiJtb2RlbGpzLjEzZWZlZGUxZGQ2MzhmMmUwOTY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQWxsb3dlZFZhbHVlc1J1bGUgPSB2b2lkIDA7XHJcbnZhciB2YWxpZGF0aW9uX3J1bGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24tcnVsZVwiKTtcclxudmFyIHByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eVwiKTtcclxudmFyIHByb3BlcnR5X2NoYWluXzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eS1jaGFpblwiKTtcclxudmFyIEFsbG93ZWRWYWx1ZXNSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFsbG93ZWRWYWx1ZXNSdWxlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcnVsZSB0aGF0IHZhbGlkYXRlcyB3aGV0aGVyIGEgc2VsZWN0ZWQgdmFsdWUgb3IgdmFsdWVzIGlzIGluIGEgbGlzdCBvZiBhbGxvd2VkIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSByb290VHlwZSBUaGUgcm9vdCB0eXBlIHRvIGJpbmQgdGhlIHJ1bGUgdG9cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBydWxlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBbGxvd2VkVmFsdWVzUnVsZShyb290VHlwZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gZW5zdXJlIHRoZSBydWxlIG5hbWUgaXMgc3BlY2lmaWVkXHJcbiAgICAgICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IFwiQWxsb3dlZFZhbHVlc1wiO1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgZXJyb3IgbWVzc2FnZSBpcyBzcGVjaWZpZWRcclxuICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm9vdFR5cGUubW9kZWwuZ2V0UmVzb3VyY2UoXCJhbGxvd2VkLXZhbHVlc1wiKTsgfTtcclxuICAgICAgICAvLyBjb252ZXJ0IHByb3BlcnR5IHBhdGggc291cmNlcyBpbnRvIGEgc291cmNlIGZ1bmN0aW9uXHJcbiAgICAgICAgdmFyIHNvdXJjZTtcclxuICAgICAgICBpZiAob3B0aW9ucy5zb3VyY2UgaW5zdGFuY2VvZiBwcm9wZXJ0eV8xLlByb3BlcnR5IHx8IG9wdGlvbnMuc291cmNlIGluc3RhbmNlb2YgcHJvcGVydHlfY2hhaW5fMS5Qcm9wZXJ0eUNoYWluKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2VQYXRoXzEgPSBvcHRpb25zLnNvdXJjZTtcclxuICAgICAgICAgICAgb3B0aW9ucy5vbkNoYW5nZU9mID0gW3NvdXJjZVBhdGhfMV07XHJcbiAgICAgICAgICAgIG9wdGlvbnMuc291cmNlID0gc291cmNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlUGF0aF8xLnZhbHVlKHRoaXMpOyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xyXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvblxyXG4gICAgICAgIG9wdGlvbnMuaXNWYWxpZCA9IGZ1bmN0aW9uIChwcm9wLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pZ25vcmVWYWxpZGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZiBubyB2YWx1ZSBpcyBjdXJyZW50bHkgc2VsZWN0ZWRcclxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBsaXN0IG9mIGFsbG93ZWQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIGdpdmVuIG9iamVjdFxyXG4gICAgICAgICAgICB2YXIgYWxsb3dlZCA9IHNvdXJjZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdmFsdWUgb3IgbGlzdCBvZiB2YWx1ZXMgaXMgaW4gdGhlIGFsbG93ZWQgdmFsdWVzIGxpc3QgKHNpbmdsZSBhbmQgbXVsdGktc2VsZWN0KVxyXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBhbGxvd2VkLmluZGV4T2YoaXRlbSkgPj0gMDsgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dlZC5pbmRleE9mKHZhbHVlKSA+PSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjYWxsIHRoZSBiYXNlIHR5cGUgY29uc3RydWN0b3JcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RUeXBlLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIHN0b3JlIHRoZSBhbGxvd2VkIHZhbHVlcyBzb3VyY2VcclxuICAgICAgICBfdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgX3RoaXMuaWdub3JlVmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5pZ25vcmVWYWxpZGF0aW9uO1xyXG4gICAgICAgIF90aGlzLnByZXZlbnRJbnZhbGlkVmFsdWVzID0gISFvcHRpb25zLnByZXZlbnRJbnZhbGlkVmFsdWVzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEFsbG93ZWRWYWx1ZXNSdWxlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNhbGwob2JqKTtcclxuICAgIH07XHJcbiAgICBBbGxvd2VkVmFsdWVzUnVsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuY29udGFpbmluZ1R5cGUuZnVsbE5hbWUgKyBcIi5cIiArIHRoaXMucHJvcGVydHkubmFtZSArIFwiIGFsbG93ZWQgdmFsdWVzXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFsbG93ZWRWYWx1ZXNSdWxlO1xyXG59KHZhbGlkYXRpb25fcnVsZV8xLlZhbGlkYXRpb25SdWxlKSk7XHJcbmV4cG9ydHMuQWxsb3dlZFZhbHVlc1J1bGUgPSBBbGxvd2VkVmFsdWVzUnVsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ2FsY3VsYXRlZFByb3BlcnR5UnVsZSA9IHZvaWQgMDtcclxudmFyIHJ1bGVfMSA9IHJlcXVpcmUoXCIuL3J1bGVcIik7XHJcbnZhciBwcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vcHJvcGVydHlcIik7XHJcbnZhciBvYnNlcnZhYmxlX2FycmF5XzEgPSByZXF1aXJlKFwiLi9vYnNlcnZhYmxlLWFycmF5XCIpO1xyXG52YXIgcnVsZV9pbnZvY2F0aW9uX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3J1bGUtaW52b2NhdGlvbi10eXBlXCIpO1xyXG52YXIgY2FsY3VsYXRpb25FcnJvckRlZmF1bHQgPSBudWxsO1xyXG52YXIgQ2FsY3VsYXRlZFByb3BlcnR5UnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhDYWxjdWxhdGVkUHJvcGVydHlSdWxlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ2FsY3VsYXRlZFByb3BlcnR5UnVsZShyb290VHlwZSwgbmFtZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHByb3BlcnR5O1xyXG4gICAgICAgIHZhciBkZWZhdWx0SWZFcnJvciA9IGNhbGN1bGF0aW9uRXJyb3JEZWZhdWx0O1xyXG4gICAgICAgIHZhciBjYWxjdWxhdGVGbjtcclxuICAgICAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG9wdGlvbnMubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5ID0gdHlwZW9mIG9wdGlvbnMucHJvcGVydHkgPT09IFwic3RyaW5nXCIgPyByb290VHlwZS5nZXRQcm9wZXJ0eShvcHRpb25zLnByb3BlcnR5KSA6IG9wdGlvbnMucHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbmRpY2F0ZSB0aGF0IHRoZSBydWxlIGlzIHJlc3BvbnNpYmxlIGZvciByZXR1cm5pbmcgdGhlIHZhbHVlIG9mIHRoZSBjYWxjdWxhdGVkIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJldHVybnMgPSBbcHJvcGVydHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSByZWFzb25hYmxlIGRlZmF1bHQgcnVsZSBuYW1lIGlmIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICAgICAgICAgIG5hbWUgPSBvcHRpb25zLm5hbWUgPSAocm9vdFR5cGUuZnVsbE5hbWUgKyBcIi5cIiArICh0eXBlb2YgcHJvcGVydHkgPT09IFwic3RyaW5nXCIgPyBwcm9wZXJ0eSA6IHByb3BlcnR5Lm5hbWUpICsgXCIuQ2FsY3VsYXRlZFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShcImRlZmF1bHRJZkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdElmRXJyb3IgPSBvcHRpb25zLmRlZmF1bHRJZkVycm9yO1xyXG4gICAgICAgICAgICBjYWxjdWxhdGVGbiA9IG9wdGlvbnMuY2FsY3VsYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDYWxsIHRoZSBiYXNlIHJ1bGUgY29uc3RydWN0b3JcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RUeXBlLCBuYW1lLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIFB1YmxpYyByZWFkLW9ubHkgcHJvcGVydGllc1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwcm9wZXJ0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBwcm9wZXJ0eSB9KTtcclxuICAgICAgICAvLyBQdWJsaWMgc2V0dGFibGUgcHJvcGVydGllc1xyXG4gICAgICAgIF90aGlzLmRlZmF1bHRJZkVycm9yID0gZGVmYXVsdElmRXJyb3I7XHJcbiAgICAgICAgX3RoaXMuaXNEZWZhdWx0VmFsdWUgPSAhIW9wdGlvbnMuaXNEZWZhdWx0VmFsdWU7XHJcbiAgICAgICAgLy8gQmFja2luZyBmaWVsZHMgZm9yIHByb3BlcnRpZXNcclxuICAgICAgICBpZiAoY2FsY3VsYXRlRm4pXHJcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfY2FsY3VsYXRlRm5cIiwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IGNhbGN1bGF0ZUZuLCB3cml0YWJsZTogdHJ1ZSB9KTtcclxuICAgICAgICAvLyByZWdpc3RlciB0aGUgcnVsZSB3aXRoIHRoZSB0YXJnZXQgcHJvcGVydHlcclxuICAgICAgICBfdGhpcy5wcm9wZXJ0eS5ydWxlcy5wdXNoKF90aGlzKTtcclxuICAgICAgICAvLyBtYXJrIHRoZSBwcm9wZXJ0eSBhcyBjYWxjdWxhdGVkIGlmIHRoZSBydWxlIHJ1bnMgb24gcHJvcGVydHkgYWNjZXNzIGFuZCBpcyBub3QgYSBkZWZhdWx0IHZhbHVlIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmlzRGVmYXVsdFZhbHVlICYmIF90aGlzLmludm9jYXRpb25UeXBlcyAmIHJ1bGVfaW52b2NhdGlvbl90eXBlXzEuUnVsZUludm9jYXRpb25UeXBlLlByb3BlcnR5R2V0KVxyXG4gICAgICAgICAgICBfdGhpcy5wcm9wZXJ0eS5pc0NhbGN1bGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENhbGN1bGF0ZWRQcm9wZXJ0eVJ1bGUucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZWdpc3Rlci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGEgZGVmYXVsdCB2YWx1ZSBydWxlIHdpbGwgcnVuIGlmIGEgY2FsY3VsYXRpb24gdGhhdCBpdCBkZXBlbmRzIG9uIGlzIGNoYW5nZWQuXHJcbiAgICAgICAgICAgIC8vIEEgcHJvcGVydHkgd2l0aCBhIGRlZmF1bHQgdmFsdWUgcnVsZSBtYXkgaGF2ZSBhIHBlcnNpc3RlZCB2YWx1ZSwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsXHJcbiAgICAgICAgICAgIC8vIG5vdCBydW4gdW5sZXNzIG9uZSBvZiBpdHMgcHJlZGljYXRlcyBmaXJlcyBhIGNoYW5nZSBldmVudC4gQSBjYWxjdWxhdGlvbiB3aWxsIG5vdCBmaXJlXHJcbiAgICAgICAgICAgIC8vIGEgY2hhbmdlIGV2ZW50IHRoZSBmaXJzdCB0aW1lIGl0IHJ1bnMgaWYgaXQgZGlkbid0IHByZXZpb3VzbHkgaGF2ZSBhIHZhbHVlLCB3aGljaCBtYXlcclxuICAgICAgICAgICAgLy8gYmUgdGhlIGNhc2UgZm9yIGV4aXN0aW5nIGluc3RhbmNlcyBpZiB0aGUgY2FsY3VsYXRpb24gaXMgbmV2ZXIgYWNjZXNzZWQgKGV4OiBhIGhpZGRlbiBmaWVsZCkuXHJcbiAgICAgICAgICAgIC8vIFNvLCBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCB0aGUgZGVmYXVsdCBydWxlJ3MgY2FsY3VsYXRlZCBwcmVkaWNhdGVzIGZpcmUgYSBjaGFuZ2UgZXZlbnQsXHJcbiAgICAgICAgICAgIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgdGhlIGNhbGN1bGF0aW9uIGlzIGFjY2Vzc2VkIHdoZW4gdGhlIG9iamVjdCBpcyBpbml0aWFsaXplZC5cclxuICAgICAgICAgICAgdGhpcy5yb290VHlwZS5pbml0RXhpc3Rpbmcuc3Vic2NyaWJlKGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgaW5pdGlhbGl6ZWQgKGkuZS4gaXQgaGFzIGFuIGluaXRpYWwgcGVyc2lzdGVkIHZhbHVlKSxcclxuICAgICAgICAgICAgICAgIC8vIHJ1biB0aGUgY2FsY3VsYXRpb24gYW5kIHRocm93IGF3YXkgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsVmFsdWUgPSBhcmdzLmVudGl0eS5fX2ZpZWxkc19fW190aGlzLnByb3BlcnR5Lm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsY3VsYXRlRm4uY2FsbChhcmdzLmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbGN1bGF0ZWRQcm9wZXJ0eVJ1bGUucHJvdG90eXBlLCBcImNhbGN1bGF0ZUZuXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZUZuO1xyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyBmdW5jdGlvbnMgaW50byBjb21waWxlZCBmdW5jdGlvbnMgb24gZmlyc3QgZXhlY3V0aW9uXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxjdWxhdGVGbi5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDYWxjdWxhdGlvbiBleHByZXNzaW9uIHN1cHBvcnRcclxuICAgICAgICAgICAgICAgIHZhciBjYWxjdWxhdGVFeHByID0gdGhpcy5fY2FsY3VsYXRlRm47XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsY3VsYXRlQ29tcGlsZWRGbiA9IG5ldyBGdW5jdGlvbihcInJldHVybiBcIiArIGNhbGN1bGF0ZUV4cHIgKyBcIjtcIik7XHJcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVGbiA9IHRoaXMuX2NhbGN1bGF0ZUZuID0gY2FsY3VsYXRlQ29tcGlsZWRGbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZUZuID0gdGhpcy5fY2FsY3VsYXRlRm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUZuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENhbGN1bGF0ZWRQcm9wZXJ0eVJ1bGUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgcHJvcGVydHkgdmFsdWVcclxuICAgICAgICB2YXIgbmV3VmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdElmRXJyb3IgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXMuY2FsY3VsYXRlRm4uY2FsbChvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5jYWxjdWxhdGVGbi5jYWxsKG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5kZWZhdWx0SWZFcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFeGl0IGltbWVkaWF0ZWx5IGlmIHRoZSBjYWxjdWxhdGVkIHJlc3VsdCB3YXMgdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtb2RpZnkgbGlzdCBwcm9wZXJ0aWVzIHRvIG1hdGNoIHRoZSBjYWxjdWxhdGVkIHZhbHVlIGluc3RlYWQgb2Ygb3ZlcndyaXRpbmcgdGhlIHByb3BlcnR5XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcGVydHkuaXNMaXN0KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdMaXN0XzEgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBpbml0aWFsIGNhbGN1bGF0aW9uIG9mIHRoZSBsaXN0IGRvZXMgbm90IHJhaXNlIGNoYW5nZSBldmVudHNcclxuICAgICAgICAgICAgLy8gZGVmYXVsdGluZyBhIGxpc3QgcHJvcGVydHkgc2hvdWxkIHJhaXNlIGNoYW5nZSBldmVudHNcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGVmYXVsdFZhbHVlICYmICF0aGlzLnByb3BlcnR5LmlzSW5pdGVkKG9iaikpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eV8xLlByb3BlcnR5JGluaXQodGhpcy5wcm9wZXJ0eSwgb2JqLCBuZXdMaXN0XzEpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGNvbXBhcmUgdGhlIG5ldyBsaXN0IHRvIHRoZSBvbGQgb25lIHRvIHNlZSBpZiBjaGFuZ2VzIHdlcmUgbWFkZVxyXG4gICAgICAgICAgICAgICAgdmFyIGN1ckxpc3QgPSB0aGlzLnByb3BlcnR5LnZhbHVlKG9iaik7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3TGlzdF8xLmxlbmd0aCA9PT0gY3VyTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9DaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0xpc3RfMS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3TGlzdF8xW2ldICE9PSBjdXJMaXN0W2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub0NoYW5nZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub0NoYW5nZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBsaXN0IHNvIG9ic2VydmVycyB3aWxsIHJlY2VpdmUgdGhlIGNoYW5nZSBldmVudHNcclxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyB3aWxsIG5vdCBiZSByYWlzZWQgaWYgdGhpcyBpcyB0aGUgaW5pdGlhbCBjYWxjdWxhdGlvbiBvZiB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgY3VyTGlzdC5iYXRjaFVwZGF0ZShmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlX2FycmF5XzEudXBkYXRlQXJyYXkoYXJyYXksIG5ld0xpc3RfMSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBqdXN0IHNldCB0aGUgcHJvcGVydHkgdG8gdGhlIG5ldyB2YWx1ZVxyXG4gICAgICAgICAgICB0aGlzLnByb3BlcnR5LnZhbHVlKG9iaiwgbmV3VmFsdWUsIHsgY2FsY3VsYXRlZDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsY3VsYXRlZFByb3BlcnR5UnVsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiY2FsY3VsYXRpb24gb2YgXCIgKyB0aGlzLnByb3BlcnR5Lm5hbWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENhbGN1bGF0ZWRQcm9wZXJ0eVJ1bGU7XHJcbn0ocnVsZV8xLlJ1bGUpKTtcclxuZXhwb3J0cy5DYWxjdWxhdGVkUHJvcGVydHlSdWxlID0gQ2FsY3VsYXRlZFByb3BlcnR5UnVsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ29uZGl0aW9uUnVsZSA9IHZvaWQgMDtcclxudmFyIHJ1bGVfMSA9IHJlcXVpcmUoXCIuL3J1bGVcIik7XHJcbnZhciBjb25kaXRpb25fdHlwZV8xID0gcmVxdWlyZShcIi4vY29uZGl0aW9uLXR5cGVcIik7XHJcbnZhciBDb25kaXRpb25SdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKENvbmRpdGlvblJ1bGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBydWxlIHRoYXQgYXNzZXJ0cyBhIGNvbmRpdGlvbiBiYXNlZCBvbiBhIHByZWRpY2F0ZVxyXG4gICAgICogQHBhcmFtIHJvb3RUeXBlIFRoZSBtb2RlbCB0eXBlIHRoZSBydWxlIGlzIGZvclxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBydWxlLCBvZiB0eXBlIENvbmRpdGlvblJ1bGVPcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbmRpdGlvblJ1bGUocm9vdFR5cGUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgcnVuIHRoZSBjb25kaXRpb24gcnVsZSBkdXJpbmcgaW5pdGlhbGl6YXRpb24gb2YgbmV3IGFuZCBleGlzdGluZyBpbnN0YW5jZXNcclxuICAgICAgICBvcHRpb25zLm9uSW5pdCA9IHRydWU7XHJcbiAgICAgICAgLy8gY2FsbCB0aGUgYmFzZSBydWxlIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290VHlwZSwgb3B0aW9ucy5uYW1lLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIC8vIGFzc2VydGlvbiBmdW5jdGlvblxyXG4gICAgICAgIF90aGlzLmFzc2VydCA9IG9wdGlvbnMuYXNzZXJ0O1xyXG4gICAgICAgIC8vIG1lc3NhZ2VcclxuICAgICAgICBfdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xyXG4gICAgICAgIC8vIGNvbmRpdGlvbiB0eXBlXHJcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uVHlwZSA9IG9wdGlvbnMuY29uZGl0aW9uVHlwZSA/ICh0eXBlb2Ygb3B0aW9ucy5jb25kaXRpb25UeXBlID09PSBcInN0cmluZ1wiID9cclxuICAgICAgICAgICAgY29uZGl0aW9uX3R5cGVfMS5Db25kaXRpb25UeXBlLmdldChvcHRpb25zLmNvbmRpdGlvblR5cGUpIDpcclxuICAgICAgICAgICAgb3B0aW9ucy5jb25kaXRpb25UeXBlKSA6XHJcbiAgICAgICAgICAgIHJ1bGVfMS5SdWxlJGVuc3VyZUNvbmRpdGlvblR5cGUob3B0aW9ucy5uYW1lLCByb290VHlwZSwgb3B0aW9ucy5jYXRlZ29yeSB8fCBcIkVycm9yXCIpO1xyXG4gICAgICAgIC8vIHByb3BlcnRpZXNcclxuICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzID0gb3B0aW9ucy5wcm9wZXJ0aWVzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIGFzc2VydHMgdGhlIGNvbmRpdGlvbiBhbmQgYWRkcyBvciByZW1vdmVzIGl0IGZyb20gdGhlIG1vZGVsIGlmIG5lY2Vzc2FyeVxyXG4gICAgQ29uZGl0aW9uUnVsZS5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICB2YXIgYXNzZXJ0O1xyXG4gICAgICAgIHZhciBtZXNzYWdlO1xyXG4gICAgICAgIGlmICh0aGlzLmFzc2VydCkge1xyXG4gICAgICAgICAgICAvLyBJZiBhbiBhc3NlcnQgZnVuY3Rpb24gaXMgZGVmaW5lZCwgdGhlbiB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gYXR0YWNoIGEgY29uZGl0aW9uXHJcbiAgICAgICAgICAgIGFzc2VydCA9IHRoaXMuYXNzZXJ0LmNhbGwoZW50aXR5KTtcclxuICAgICAgICAgICAgbWVzc2FnZSA9IHR5cGVvZiB0aGlzLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyB0aGlzLm1lc3NhZ2UgOiB0aGlzLm1lc3NhZ2UuY2FsbChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLm1lc3NhZ2UgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5tZXNzYWdlLmNhbGwoZW50aXR5KTtcclxuICAgICAgICAgICAgYXNzZXJ0ID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiYgbWVzc2FnZS50cmltKCkubGVuZ3RoID4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3JlYXRlIG9yIHJlbW92ZSB0aGUgY29uZGl0aW9uIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgIGlmICh0eXBlb2YgYXNzZXJ0ICE9PSBcInVuZGVmaW5lZFwiKSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3MgdGhyb3VnaCBcInRoaXNcIiBzbyBpdCBjYW4gYWRkIHRoZSBzb3VyY2Ugd2hlbiB0aGUgcnVsZSBpcyBjb25zdHJ1Y3RlZFxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIHNvdXJjZSB0byB0aGUgY29uZGl0aW9uIGluc3RlYWQgb2YgdGhlIGNvbmRpdGlvbiB0eXBlXHJcbiAgICAgICAgICAgIHRoaXMuY29uZGl0aW9uVHlwZS53aGVuKHRoaXMsIGFzc2VydCwgZW50aXR5LCBtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZ2V0cyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb25kaXRpb24gcnVsZVxyXG4gICAgQ29uZGl0aW9uUnVsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyB0aGlzLm1lc3NhZ2UgOiB0aGlzLmNvbmRpdGlvblR5cGUubWVzc2FnZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29uZGl0aW9uUnVsZTtcclxufShydWxlXzEuUnVsZSkpO1xyXG5leHBvcnRzLkNvbmRpdGlvblJ1bGUgPSBDb25kaXRpb25SdWxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNvbmRpdGlvblRhcmdldCA9IHZvaWQgMDtcclxudmFyIGZvcm1hdF9lcnJvcl8xID0gcmVxdWlyZShcIi4vZm9ybWF0LWVycm9yXCIpO1xyXG4vKiogUmVwcmVzZW50cyB0aGUgYXNzb2NpYXRpb24gb2YgYSBjb25kaXRpb24gdG8gYSBzcGVjaWZpYyB0YXJnZXQgZW50aXR5LiAqL1xyXG52YXIgQ29uZGl0aW9uVGFyZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZXMgdGhlIGFzc29jaWF0aW9uIG9mIGEgY29uZGl0aW9uIHRvIGEgc3BlY2lmaWMgdGFyZ2V0IGVudGl0eS5cclxuICAgICogQHBhcmFtIGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHRoZSB0YXJnZXQgaXMgZm9yLlxyXG4gICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgZW50aXR5IHRoZSBjb25kaXRpb24gaXMgYXNzb2NpYXRlZCB3aXRoLlxyXG4gICAgKiBAcGFyYW0gcHJvcGVydGllcyBUaGUgc2V0IG9mIHByb3BlcnRpZXMgb24gdGhlIHRhcmdldCBlbnRpdHkgdGhlIGNvbmRpdGlvbiBpcyByZWxhdGVkIHRvLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbmRpdGlvblRhcmdldChjb25kaXRpb24sIHRhcmdldCwgcHJvcGVydGllcykge1xyXG4gICAgICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XHJcbiAgICAgICAgLy8gQXR0YWNoIHRoZSBjb25kaXRpb24gdGFyZ2V0IHRvIHRoZSB0YXJnZXQgZW50aXR5LlxyXG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbi50eXBlICE9PSBmb3JtYXRfZXJyb3JfMS5Gb3JtYXRFcnJvci5Db25kaXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5tZXRhLnNldENvbmRpdGlvbih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQ29uZGl0aW9uVGFyZ2V0O1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbmRpdGlvblRhcmdldCA9IENvbmRpdGlvblRhcmdldDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Db25kaXRpb25UeXBlU2V0ID0gdm9pZCAwO1xyXG52YXIgb2JzZXJ2YWJsZV9hcnJheV8xID0gcmVxdWlyZShcIi4vb2JzZXJ2YWJsZS1hcnJheVwiKTtcclxudmFyIGFsbENvbmRpdGlvblR5cGVTZXRzID0ge307XHJcbi8qKiBHcm91cHMgY29uZGl0aW9uIHR5cGVzIGludG8gYSBzZXQgaW4gb3JkZXIgdG8gYmUgbm90aWZpZWQgY29uZGl0aW9ucyBmb3IgdGhlc2UgdHlwZXMgY2hhbmdlLiAqL1xyXG52YXIgQ29uZGl0aW9uVHlwZVNldCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgKiBDcmVhdGVzIGEgc2V0IG9mIGNvbmRpdGlvbiB0eXBlcy5cclxuICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNldFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbmRpdGlvblR5cGVTZXQobmFtZSkge1xyXG4gICAgICAgIGlmIChhbGxDb25kaXRpb25UeXBlU2V0c1tuYW1lXSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQSBzZXQgd2l0aCB0aGUgbmFtZSAnXCIgKyBuYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZC5cIik7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gb2JzZXJ2YWJsZV9hcnJheV8xLk9ic2VydmFibGVBcnJheS5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLmNvbmRpdGlvbnMgPSBvYnNlcnZhYmxlX2FycmF5XzEuT2JzZXJ2YWJsZUFycmF5LmNyZWF0ZSgpO1xyXG4gICAgICAgIGFsbENvbmRpdGlvblR5cGVTZXRzW25hbWVdID0gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgKiBHZXRzIGFsbCBjb25kaXRpb24gdHlwZSBzZXRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWQuXHJcbiAgICAqIEByZXR1cm5zIEFycmF5IG9mIGFsbCBjb25kaXRpb24gdHlwZSBzZXRzLlxyXG4gICAgKiAqL1xyXG4gICAgQ29uZGl0aW9uVHlwZVNldC5hbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFsbCA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIHR5cGUgaW4gYWxsQ29uZGl0aW9uVHlwZVNldHMua2V5cykge1xyXG4gICAgICAgICAgICBhbGwucHVzaChhbGxDb25kaXRpb25UeXBlU2V0c1t0eXBlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbGw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAqIEdldHMgdGhlIGNvbmRpdGlvbiB0eXBlIHNldCB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cclxuICAgICogQHBhcmFtIG5hbWVcclxuICAgICovXHJcbiAgICBDb25kaXRpb25UeXBlU2V0LmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGFsbENvbmRpdGlvblR5cGVTZXRzW25hbWVdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb25kaXRpb25UeXBlU2V0O1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbmRpdGlvblR5cGVTZXQgPSBDb25kaXRpb25UeXBlU2V0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5QZXJtaXNzaW9uQ29uZGl0aW9uVHlwZSA9IGV4cG9ydHMuV2FybmluZ0NvbmRpdGlvblR5cGUgPSBleHBvcnRzLkVycm9yQ29uZGl0aW9uVHlwZSA9IGV4cG9ydHMuQ29uZGl0aW9uVHlwZSA9IHZvaWQgMDtcclxudmFyIGNvbmRpdGlvbl8xID0gcmVxdWlyZShcIi4vY29uZGl0aW9uXCIpO1xyXG52YXIgb2JzZXJ2YWJsZV9hcnJheV8xID0gcmVxdWlyZShcIi4vb2JzZXJ2YWJsZS1hcnJheVwiKTtcclxudmFyIGFsbENvbmRpdGlvblR5cGVzID0ge307XHJcbnZhciBDb25kaXRpb25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAqIENyZWF0ZXMgYSB1bmlxdWUgdHlwZSBvZiBtb2RlbCBjb25kaXRpb24uXHJcbiAgICAqIEBwYXJhbSBjb2RlIFRoZSB1bmlxdWUgY29uZGl0aW9uIHR5cGUgY29kZS5cclxuICAgICogQHBhcmFtIGNhdGVnb3J5IFRoZSBjYXRlZ29yeSBvZiB0aGUgY29uZGl0aW9uIHR5cGUsIHN1Y2ggYXMgXCJFcnJvclwiLCBcIldhcm5pbmdcIiwgb3IgXCJQZXJtaXNzaW9uXCIuXHJcbiAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBkZWZhdWx0IG1lc3NhZ2UgdG8gdXNlIHdoZW4gdGhlIGNvbmRpdGlvbiBpcyBwcmVzZW50LlxyXG4gICAgKiBAcGFyYW0gc2V0cyBPbmUgb3IgbW9yZSBzZXRzIHRoZSBjb25kaXRpb24gdHlwZSBiZWxvbmdzIHRvLlxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbmRpdGlvblR5cGUoY29kZSwgY2F0ZWdvcnksIG1lc3NhZ2UsIHNldHMpIHtcclxuICAgICAgICAvLyBFbnN1cmUgdW5pcXVlIGNvbmRpdGlvbiB0eXBlIGNvZGVzXHJcbiAgICAgICAgaWYgKGFsbENvbmRpdGlvblR5cGVzW2NvZGVdKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIGNvbmRpdGlvbiB0eXBlIHdpdGggdGhlIGNvZGUgXFxcIlwiICsgY29kZSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQuXCIpO1xyXG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XHJcbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IGNhdGVnb3J5O1xyXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgLy8gdGhpcy5ydWxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29uZGl0aW9ucyA9IG9ic2VydmFibGVfYXJyYXlfMS5PYnNlcnZhYmxlQXJyYXkuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5zZXRzID0gb2JzZXJ2YWJsZV9hcnJheV8xLk9ic2VydmFibGVBcnJheS5lbnN1cmVPYnNlcnZhYmxlKHNldHMgfHwgW10pO1xyXG4gICAgICAgIC8vIFJlZ2lzdGVyIHdpdGggdGhlIHN0YXRpYyBkaWN0aW9uYXJ5IG9mIGFsbCBjb25kaXRpb24gdHlwZXNcclxuICAgICAgICBhbGxDb25kaXRpb25UeXBlc1tjb2RlXSA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogQWRkcyBvciByZW1vdmVzIGEgY29uZGl0aW9uIGZyb20gdGhlIG1vZGVsIGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCBpZiBuZWNlc3NhcnkuXHJcbiAgICAqIEBwYXJhbSBjb25kaXRpb24gV2hldGhlciBvciBub3QgdGhlIGNvbmRpdGlvbiBzaG91bGQgYmUgcHJlc2VudFxyXG4gICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgaW5zdGFuY2VcclxuICAgICogQHBhcmFtIHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gYXR0YWNoIHRoZSBjb25kaXRpb24gdG9cclxuICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIGNvbmRpdGlvbiBtZXNzYWdlIChvciBhIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIHRoZSBtZXNzYWdlKVxyXG4gICAgKi9cclxuICAgIENvbmRpdGlvblR5cGUucHJvdG90eXBlLndoZW4gPSBmdW5jdGlvbiAoc291cmNlLCBjb25kaXRpb24sIHRhcmdldCwgbWVzc2FnZSkge1xyXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBjb25kaXRpb24gaWYgaXQgZXhpc3RzXHJcbiAgICAgICAgdmFyIGNvbmRpdGlvblRhcmdldCA9IHRhcmdldC5tZXRhLmdldENvbmRpdGlvbih0aGlzKTtcclxuICAgICAgICAvLyBhZGQgdGhlIGNvbmRpdGlvbiBvbiB0aGUgdGFyZ2V0IGlmIGl0IGRvZXMgbm90IGV4aXN0IHlldFxyXG4gICAgICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIG1lc3NhZ2UgaXMgYSBmdW5jdGlvbiwgaW52b2tlIHRvIGdldCB0aGUgYWN0dWFsIG1lc3NhZ2VcclxuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IG1lc3NhZ2UodGFyZ2V0KSA6IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBjb25kaXRpb24gaWYgb25lIGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICAgIGlmICghY29uZGl0aW9uVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvbmRpdGlvbl8xLkNvbmRpdGlvbih0aGlzLCBtZXNzYWdlLCB0YXJnZXQsIHNvdXJjZSwgc291cmNlLnByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIGNvbmRpdGlvbiBpZiB0aGUgbWVzc2FnZSBoYXMgY2hhbmdlZFxyXG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UgIT09IGNvbmRpdGlvblRhcmdldC5jb25kaXRpb24ubWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVzdHJveSB0aGUgZXhpc3RpbmcgY29uZGl0aW9uXHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb25UYXJnZXQuY29uZGl0aW9uLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBjb25kaXRpb24gd2l0aCB0aGUgdXBkYXRlZCBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGNvbmRpdGlvbl8xLkNvbmRpdGlvbih0aGlzLCBtZXNzYWdlLCB0YXJnZXQsIHNvdXJjZSwgc291cmNlLnByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwganVzdCByZXR1cm4gdGhlIGV4aXN0aW5nIGNvbmRpdGlvblxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25UYXJnZXQuY29uZGl0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERlc3Ryb3kgdGhlIGNvbmRpdGlvbiBpZiBpdCBleGlzdHMgb24gdGhlIHRhcmdldCBhbmQgaXMgbm8gbG9uZ2VyIHZhbGlkXHJcbiAgICAgICAgaWYgKGNvbmRpdGlvblRhcmdldCAhPSBudWxsKVxyXG4gICAgICAgICAgICBjb25kaXRpb25UYXJnZXQuY29uZGl0aW9uLmRlc3Ryb3koKTtcclxuICAgICAgICAvLyBSZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSB0aGF0IG5vIGNvbmRpdGlvbiB3YXMgY3JlYXRlZFxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICAgICogR2V0cyBhbGwgY29uZGl0aW9uIHR5cGVzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWQuXHJcbiAgICAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBhbGwgY29uZGl0aW9uIHR5cGVzLlxyXG4gICAgICAgICogKi9cclxuICAgIENvbmRpdGlvblR5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhbGwgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciB0eXBlIGluIGFsbENvbmRpdGlvblR5cGVzLmtleXMpIHtcclxuICAgICAgICAgICAgYWxsLnB1c2goYWxsQ29uZGl0aW9uVHlwZXNbdHlwZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICAgICogUmV0dXJucyB0aGUgY29uZGl0aW9uIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gY29kZSwgaWYgaXQgZXhpc3RzLlxyXG4gICAgICAgICogQHBhcmFtIGNvZGUgVGhlIHVuaXF1ZSBjb2RlIG9mIHRoZSBjb25kaXRpb24gdHlwZSB0byBmaW5kLlxyXG4gICAgICAgICovXHJcbiAgICBDb25kaXRpb25UeXBlLmdldCA9IGZ1bmN0aW9uIChjb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIGFsbENvbmRpdGlvblR5cGVzW2NvZGVdO1xyXG4gICAgfTtcclxuICAgIDtcclxuICAgIHJldHVybiBDb25kaXRpb25UeXBlO1xyXG59KCkpO1xyXG5leHBvcnRzLkNvbmRpdGlvblR5cGUgPSBDb25kaXRpb25UeXBlO1xyXG52YXIgRXJyb3JDb25kaXRpb25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVycm9yQ29uZGl0aW9uVHlwZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVycm9yQ29uZGl0aW9uVHlwZShjb2RlLCBtZXNzYWdlLCBzZXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGNvZGUsIFwiRXJyb3JcIiwgbWVzc2FnZSwgc2V0cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBFcnJvckNvbmRpdGlvblR5cGU7XHJcbn0oQ29uZGl0aW9uVHlwZSkpO1xyXG5leHBvcnRzLkVycm9yQ29uZGl0aW9uVHlwZSA9IEVycm9yQ29uZGl0aW9uVHlwZTtcclxudmFyIFdhcm5pbmdDb25kaXRpb25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdhcm5pbmdDb25kaXRpb25UeXBlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gV2FybmluZ0NvbmRpdGlvblR5cGUoY29kZSwgbWVzc2FnZSwgc2V0cykge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBjb2RlLCBcIldhcm5pbmdcIiwgbWVzc2FnZSwgc2V0cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBXYXJuaW5nQ29uZGl0aW9uVHlwZTtcclxufShDb25kaXRpb25UeXBlKSk7XHJcbmV4cG9ydHMuV2FybmluZ0NvbmRpdGlvblR5cGUgPSBXYXJuaW5nQ29uZGl0aW9uVHlwZTtcclxudmFyIFBlcm1pc3Npb25Db25kaXRpb25UeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBlcm1pc3Npb25Db25kaXRpb25UeXBlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUGVybWlzc2lvbkNvbmRpdGlvblR5cGUoY29kZSwgbWVzc2FnZSwgc2V0cywgaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgaWYgKGlzQWxsb3dlZCA9PT0gdm9pZCAwKSB7IGlzQWxsb3dlZCA9IHRydWU7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb2RlLCBcIldhcm5pbmdcIiwgbWVzc2FnZSwgc2V0cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc0FsbG93ZWQgPSAhKGlzQWxsb3dlZCA9PT0gZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBQZXJtaXNzaW9uQ29uZGl0aW9uVHlwZTtcclxufShDb25kaXRpb25UeXBlKSk7XHJcbmV4cG9ydHMuUGVybWlzc2lvbkNvbmRpdGlvblR5cGUgPSBQZXJtaXNzaW9uQ29uZGl0aW9uVHlwZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Db25kaXRpb24gPSB2b2lkIDA7XHJcbnZhciBmb3JtYXRfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdC1lcnJvclwiKTtcclxudmFyIGNvbmRpdGlvbl90YXJnZXRfMSA9IHJlcXVpcmUoXCIuL2NvbmRpdGlvbi10YXJnZXRcIik7XHJcbnZhciBvYnNlcnZhYmxlX2FycmF5XzEgPSByZXF1aXJlKFwiLi9vYnNlcnZhYmxlLWFycmF5XCIpO1xyXG52YXIgQ29uZGl0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgICAgKiBDcmVhdGVzIGEgY29uZGl0aW9uIG9mIGEgc3BlY2lmaWMgdHlwZSBhc3NvY2lhdGVkIHdpdGggb25lIG9yIG1vcmUgZW50aXRpZXMgaW4gYSBtb2RlbC5cclxuICAgICAgICAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIGNvbmRpdGlvbiwgd2hpY2ggdXN1YWxseSBpcyBhbiBpbnN0YW5jZSBvZiBhIHN1YmNsYXNzIGxpa2UgRXJyb3IsIFdhcm5pbmcgb3IgUGVybWlzc2lvbi5cclxuICAgICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBvcHRpb25hbCBtZXNzYWdlIHRvIHVzZSBmb3IgdGhlIGNvbmRpdGlvbiwgd2hpY2ggd2lsbCBkZWZhdWx0IHRvIHRoZSBjb25kaXRpb24gdHlwZSBtZXNzYWdlIGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSByb290IHRhcmdldCBlbnRpdHkgdGhlIGNvbmRpdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGguXHJcbiAgICAgICAgKiBAcGFyYW0gcHJvcGVydGllcyBUaGUgc2V0IG9mIHByb3BlcnR5IHBhdGhzIHNwZWNpZnlpbmcgd2hpY2ggcHJvcGVydGllcyBhbmQgZW50aXRpZXMgdGhlIGNvbmRpdGlvbiBzaG91bGQgYmUgYXR0YWNoZWQgdG8uXHJcbiAgICAgICAgKi9cclxuICAgIGZ1bmN0aW9uIENvbmRpdGlvbih0eXBlLCBtZXNzYWdlLCB0YXJnZXQsIHNvdXJjZSwgcHJvcGVydGllcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHByb3BlcnRpZXMgPT09IHZvaWQgMCkgeyBwcm9wZXJ0aWVzID0gW107IH1cclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2UgPSBtZXNzYWdlIHx8ICh0eXBlID8gdHlwZS5tZXNzYWdlIDogdW5kZWZpbmVkKTtcclxuICAgICAgICB2YXIgdGFyZ2V0cyA9IHRoaXMudGFyZ2V0cyA9IG9ic2VydmFibGVfYXJyYXlfMS5PYnNlcnZhYmxlQXJyYXkuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgLy8gY3JlYXRlIHRhcmdldHMgaWYgYSByb290IHdhcyBzcGVjaWZpZWRcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gcHJvcGVydGllc1twXTtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRJbmZvcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gYnVpbGQgbGlzdCBvZiBvYmplY3RzIGNvbnRhaW5pbmcgQ29uZGl0aW9uVGFyZ2V0IGluZm9ybWF0aW9uXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGNvbnN0cnVjdCBDb25kaXRpb25UYXJnZXRzIGFzIHdlJ3JlIHByb2Nlc3NpbmcgdGhlIHBhdGggYmVjYXVzZSB3ZSBtYXkgbm90IGhhdmUgZ2F0aGVyZWQgYWxsIHRhcmdldGVkIHByb3BlcnRpZXMsXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlIGNvbnN0cnVjdG9yIHRyaWdnZXJzIGNoYW5nZSBvbiB0aGUgZW50aXR5IG1ldGEncyBjb25kaXRpb25zIGxpc3QsIHdoaWNoIHNob3VsZCBiZSBpbiBhIGNvcnJlY3Qgc3RhdGUgYmVmb3JlIHB1Ymxpc2hpbmcgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICBwYXRoLmVhY2godGFyZ2V0LCBmdW5jdGlvbiAoZW50aXR5LCBwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSAhPT0gcGF0aC5sYXN0UHJvcGVydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaWYgYSB0YXJnZXQgYWxyZWFkeSBleGlzdHMgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldEluZm8gPSB0YXJnZXRJbmZvcy5maW5kKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0LmVudGl0eSA9PT0gZW50aXR5OyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGNvbmRpdGlvbiB0YXJnZXQgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdFxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0SW5mbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmZvID0geyBlbnRpdHk6IGVudGl0eSwgcHJvcGVydGllczogW3Byb3BlcnR5XSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmZvcy5wdXNoKHRhcmdldEluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGp1c3QgZW5zdXJlIGl0IHJlZmVyZW5jZXMgdGhlIGN1cnJlbnQgc3RlcFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0YXJnZXRJbmZvLnByb3BlcnRpZXMuaW5jbHVkZXMocHJvcGVydHkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJbmZvLnByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnN0cnVjdCB0aGUgQ29uZGl0aW9uVGFyZ2V0cyBoZXJlIG5vdyB0aGF0IHdlJ3ZlIGdhdGhlcmVkIGFsbCBpbmZvcm1hdGlvblxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0cy5wdXNoLmFwcGx5KHRhcmdldHMsIHRhcmdldEluZm9zLm1hcChmdW5jdGlvbiAoaSkgeyByZXR1cm4gbmV3IGNvbmRpdGlvbl90YXJnZXRfMS5Db25kaXRpb25UYXJnZXQoX3RoaXMsIGkuZW50aXR5LCBpLnByb3BlcnRpZXMpOyB9KSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZWFjaCBwcm9wZXJ0eSBwYXRoIHRvIGJ1aWxkIHVwIHRoZSBjb25kaXRpb24gc291cmNlc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwID0gcHJvcGVydGllcy5sZW5ndGggLSAxOyBwID49IDA7IHAtLSkge1xyXG4gICAgICAgICAgICAgICAgX2xvb3BfMShwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByYWlzZSBldmVudHMgZm9yIHRoZSBuZXcgY29uZGl0aW9uXHJcbiAgICAgICAgaWYgKHR5cGUgIT09IGZvcm1hdF9lcnJvcl8xLkZvcm1hdEVycm9yLkNvbmRpdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvblR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICAvLyByYWlzZSBldmVudHMgb24gY29uZGl0aW9uIHRhcmdldHNcclxuICAgICAgICAgICAgZm9yICh2YXIgdCA9IHRhcmdldHMubGVuZ3RoIC0gMTsgdCA+PSAwOyB0LS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb25UYXJnZXQgPSB0YXJnZXRzW3RdO1xyXG4gICAgICAgICAgICAgICAgLy8gdHlwZSBldmVudHNcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG9iamVjdFR5cGUgPSBjb25kaXRpb25UYXJnZXQudGFyZ2V0Lm1ldGEudHlwZTsgb2JqZWN0VHlwZSAhPSBudWxsOyBvYmplY3RUeXBlID0gb2JqZWN0VHlwZS5iYXNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIChvYmplY3RUeXBlLmNvbmRpdGlvbnNDaGFuZ2VkIGFzIEV2ZW50PFR5cGUsIENvbmRpdGlvblRhcmdldHNDaGFuZ2VkRXZlbnRBcmdzPikucHVibGlzaChvYmplY3RUeXBlLCB7IGNvbmRpdGlvblRhcmdldDogY29uZGl0aW9uVGFyZ2V0LCBhZGQ6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25kaXRpb24gdG8gdGhlIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIHR5cGVcclxuICAgICAgICAgICAgY29uZGl0aW9uVHlwZS5jb25kaXRpb25zLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgY29uZGl0aW9uIHRvIHJlbGV2YW50IGNvbmRpdGlvbiB0eXBlIHNldHNcclxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5zZXRzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gdGhpcy50eXBlLnNldHMubGVuZ3RoIC0gMTsgcyA+PSAwOyBzLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUuc2V0c1tzXS5jb25kaXRpb25zLnB1c2godGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uZGl0aW9uLnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5fbWVzc2FnZSkgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlID0gdmFsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIENvbmRpdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLy8gPHN1bW1hcnk+UmVtb3ZlcyB0aGUgY29uZGl0aW9uIHRhcmdldHMgZnJvbSBhbGwgdGFyZ2V0IGluc3RhbmNlcyBhbmQgcmFpc2VzIGNvbmRpdGlvbiBjaGFuZ2UgZXZlbnRzLjwvc3VtbWFyeT5cclxuICAgICAgICAvLyByYWlzZSBldmVudHMgb24gY29uZGl0aW9uIHR5cGUgc2V0c1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGUuc2V0cykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBzID0gdGhpcy50eXBlLnNldHMubGVuZ3RoIC0gMTsgcyA+PSAwOyBzLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZXQgPSB0aGlzLnR5cGUuc2V0c1tzXTtcclxuICAgICAgICAgICAgICAgIHZhciBpZHhfMSA9IHNldC5jb25kaXRpb25zLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWR4XzEgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldC5jb25kaXRpb25zLnNwbGljZShpZHhfMSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmFpc2UgZXZlbnRzIG9uIGNvbmRpdGlvbiB0eXBlc1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLnR5cGUuY29uZGl0aW9ucy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgIGlmIChpZHggPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnR5cGUuY29uZGl0aW9ucy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgdCA9IHRoaXMudGFyZ2V0cy5sZW5ndGggLSAxOyB0ID49IDA7IHQtLSkge1xyXG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uVGFyZ2V0ID0gdGhpcy50YXJnZXRzW3RdO1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0TWV0YSA9IGNvbmRpdGlvblRhcmdldC50YXJnZXQubWV0YTtcclxuICAgICAgICAgICAgb2JqZWN0TWV0YS5jbGVhckNvbmRpdGlvbihjb25kaXRpb25UYXJnZXQuY29uZGl0aW9uLnR5cGUpO1xyXG4gICAgICAgICAgICAvLyB0eXBlIGV2ZW50c1xyXG4gICAgICAgICAgICBmb3IgKHZhciBvYmplY3RUeXBlID0gY29uZGl0aW9uVGFyZ2V0LnRhcmdldC5tZXRhLnR5cGU7IG9iamVjdFR5cGUgIT0gbnVsbDsgb2JqZWN0VHlwZSA9IG9iamVjdFR5cGUuYmFzZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIChvYmplY3RUeXBlLmNvbmRpdGlvbnNDaGFuZ2VkIGFzIEV2ZW50PFR5cGUsIENvbmRpdGlvblRhcmdldHNDaGFuZ2VkRXZlbnRBcmdzPikucHVibGlzaChvYmplY3RUeXBlLCB7IGNvbmRpdGlvblRhcmdldDogY29uZGl0aW9uVGFyZ2V0LCBhZGQ6IGZhbHNlLCByZW1vdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gYWxsIGNvbmRpdGlvbiB0YXJnZXRzXHJcbiAgICAgICAgdGhpcy50YXJnZXRzLnNwbGljZSgwKTtcclxuICAgIH07XHJcbiAgICBDb25kaXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENvbmRpdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5Db25kaXRpb24gPSBDb25kaXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRW50aXR5U2VyaWFsaXplciA9IGV4cG9ydHMuRGVmYXVsdFNlcmlhbGl6YXRpb25TZXR0aW5ncyA9IGV4cG9ydHMuUHJvcGVydHlDb252ZXJ0ZXIgPSBleHBvcnRzLklnbm9yZVByb3BlcnR5ID0gdm9pZCAwO1xyXG52YXIgdHlwZV8xID0gcmVxdWlyZShcIi4vdHlwZVwiKTtcclxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XHJcbmV4cG9ydHMuSWdub3JlUHJvcGVydHkgPSB7XHJcbiAgICBrZXk6IFwiaWdub3JlXCIsXHJcbiAgICB2YWx1ZTogXCJpZ25vcmVcIlxyXG59O1xyXG4vKipcclxuICogQWxsb3dzIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSBzZXJpYWxpemVkIG5hbWUgYW5kIHZhbHVlIG9mIGEgbW9kZWwgcHJvcGVydHkuXHJcbiAqL1xyXG52YXIgUHJvcGVydHlDb252ZXJ0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eUNvbnZlcnRlcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGBFbnRpdHlgIGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cclxuICAgICAqIEBwYXJhbSBwcm9wIFRoZSBwcm9wZXJ0eSBiZWluZyBzZXJpYWxpemVkL2Rlc2VyaWFsaXplZC5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgUHJvcGVydHlDb252ZXJ0ZXIucHJvdG90eXBlLnNob3VsZENvbnZlcnQgPSBmdW5jdGlvbiAoY29udGV4dCwgcHJvcCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGBJZ25vcmVQcm9wZXJ0eWAgdG8gcHJldmVudCBzZXJpYWxpemF0aW9uIG9mIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBgRW50aXR5YCBjb250YWluaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gcHJvcCBUaGUgY3VycmVudCBwcm9wZXJ0eSBiZWluZyBzZXJpYWxpemVkLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgb24gdGhlIGVudGl0eSBjdXJyZW50bHkgYmVpbmcgc2VyaWFsaXplZC5cclxuICAgICAqL1xyXG4gICAgUHJvcGVydHlDb252ZXJ0ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCB2YWx1ZSwgcHJvcGVydHksIHNldHRpbmdzKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHsga2V5OiBwcm9wZXJ0eS5uYW1lLCB2YWx1ZTogdmFsdWUgfTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVfMS5pc0VudGl0eVR5cGUocHJvcGVydHkucHJvcGVydHlUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5LmlzTGlzdCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKGVudCkgeyByZXR1cm4gZW50LnNlcmlhbGl6ZShzZXR0aW5ncyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlLnNlcmlhbGl6ZShzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkuaXNMaXN0KVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnZhbHVlID0gdmFsdWUuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBgSWdub3JlUHJvcGVydHlgIHRvIHByZXZlbnQgZGVzZXJpYWxpemF0aW9uIG9mIHRoZSBwcm9wZXJ0eS5cclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBgRW50aXR5YCBjb250YWluaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXHJcbiAgICAgKiBAcGFyYW0gcHJvcCBUaGUgY3VycmVudCBwcm9wZXJ0eSBiZWluZyBkZXNlcmlhbGl6ZWQuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGRlc2VyaWFsaXplLlxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBQcm9wZXJ0eUNvbnZlcnRlci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoY29udGV4dCwgdmFsdWUsIHByb3BlcnR5KSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm9wZXJ0eUNvbnZlcnRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Qcm9wZXJ0eUNvbnZlcnRlciA9IFByb3BlcnR5Q29udmVydGVyO1xyXG5leHBvcnRzLkRlZmF1bHRTZXJpYWxpemF0aW9uU2V0dGluZ3MgPSB7XHJcbiAgICBmb3JjZTogZmFsc2UsXHJcbiAgICB1c2VBbGlhc2VzOiBmYWxzZVxyXG59O1xyXG52YXIgRW50aXR5U2VyaWFsaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVudGl0eVNlcmlhbGl6ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydHlDb252ZXJ0ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydHlJbmplY3RvcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fcHJvcGVydHlBbGlhc2VzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlUmVzb2x2ZXJzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb3BlcnR5IGNvbnZlcnRlcnMgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgaW4gb3JkZXIgb2YgaW5jcmVhc2luZyBzcGVjaWZpY2l0eS5cclxuICAgICAqIElmIHR3byBjb252ZXJ0ZXJzIHdvdWxkIGNvbnZlcnQgYSBwcm9wZXJ0eSwgb25seSB0aGUgb25lIHJlZ2lzdGVyZWQgbGFzdCB3aWxsIGFwcGx5LlxyXG4gICAgICovXHJcbiAgICBFbnRpdHlTZXJpYWxpemVyLnByb3RvdHlwZS5yZWdpc3RlclByb3BlcnR5Q29udmVydGVyID0gZnVuY3Rpb24gKGNvbnZlcnRlcikge1xyXG4gICAgICAgIHRoaXMuX3Byb3BlcnR5Q29udmVydGVycy51bnNoaWZ0KGNvbnZlcnRlcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJ0eSBpbmplY3Rpb25zIHdpbGwgb2NjdXIgd2hlbiBzZXJpYWxpemluZyBlbnRpdGllcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIG9yIGVudGl0aWVzIHdoaWNoXHJcbiAgICAgKiBpbmhlcml0IGZyb20gdGhlIHNwZWNpZmllZCB0eXBlLiBJbmplY3RlZCBwcm9wZXJ0aWVzIHdpbGwgYXBwZWFyIGJlZm9yZSBtb2RlbCBwcm9wZXJ0aWVzIGluIHRoZSBzZXJpYWxpemVkXHJcbiAgICAgKiBvdXRwdXQuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBFaXRoZXIgYSBUeXBlIG9yIHRoZSBmdWxsTmFtZSBvZiBhIFR5cGVcclxuICAgICAqIEBwYXJhbSBpbmplY3RvclxyXG4gICAgICovXHJcbiAgICBFbnRpdHlTZXJpYWxpemVyLnByb3RvdHlwZS5yZWdpc3RlclByb3BlcnR5SW5qZWN0b3IgPSBmdW5jdGlvbiAodHlwZSwgaW5qZWN0b3IpIHtcclxuICAgICAgICB2YXIgaW5qZWN0b3JzID0gdGhpcy5fcHJvcGVydHlJbmplY3RvcnMuZ2V0KHR5cGUpIHx8IFtdO1xyXG4gICAgICAgIGluamVjdG9ycy5wdXNoKGluamVjdG9yKTtcclxuICAgICAgICB0aGlzLl9wcm9wZXJ0eUluamVjdG9ycy5zZXQodHlwZSwgaW5qZWN0b3JzKTtcclxuICAgIH07XHJcbiAgICBFbnRpdHlTZXJpYWxpemVyLnByb3RvdHlwZS5yZWdpc3RlclByb3BlcnR5QWxpYXMgPSBmdW5jdGlvbiAodHlwZSwgYWxpYXMsIHByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgIHZhciBhbGlhc2VzID0gdGhpcy5fcHJvcGVydHlBbGlhc2VzLmdldCh0eXBlKSB8fCB7fTtcclxuICAgICAgICBhbGlhc2VzW2FsaWFzXSA9IHByb3BlcnR5TmFtZTtcclxuICAgICAgICBhbGlhc2VzW3Byb3BlcnR5TmFtZV0gPSBhbGlhcztcclxuICAgICAgICB0aGlzLl9wcm9wZXJ0eUFsaWFzZXMuc2V0KHR5cGUsIGFsaWFzZXMpO1xyXG4gICAgfTtcclxuICAgIEVudGl0eVNlcmlhbGl6ZXIucHJvdG90eXBlLnJlZ2lzdGVyVmFsdWVSZXNvbHZlciA9IGZ1bmN0aW9uIChyZXNvbHZlcikge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlUmVzb2x2ZXJzLnB1c2gocmVzb2x2ZXIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcHJvcGVydHkgaW5qZWN0b3JzIHJlZ2lzdGVyZWQgZm9yIGEgc3BlY2lmaWMgdHlwZSwgaW5jbHVkaW5nIG5hbWUtYmFzZWQgcmVnaXN0cmF0aW9ucy5cclxuICAgICAqIEBwYXJhbSB0eXBlXHJcbiAgICAgKi9cclxuICAgIEVudGl0eVNlcmlhbGl6ZXIucHJvdG90eXBlLmdldEluamVjdG9yc09yRGVmYXVsdCA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9wcm9wZXJ0eUluamVjdG9ycy5nZXQodHlwZSkgfHwgW10pLmNvbmNhdCh0aGlzLl9wcm9wZXJ0eUluamVjdG9ycy5nZXQodHlwZS5mdWxsTmFtZSkgfHwgW10pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBwcm9wZXJ0eSBpbmplY3RvcnMgcmVnaXN0ZXJlZCBmb3IgYSB0eXBlIGFuZCBpdHMgYmFzZSB0eXBlcy5cclxuICAgICAqIEBwYXJhbSB0eXBlXHJcbiAgICAgKi9cclxuICAgIEVudGl0eVNlcmlhbGl6ZXIucHJvdG90eXBlLmdldFByb3BlcnR5SW5qZWN0b3JzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgaW5qZWN0b3JzID0gW107XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpbmplY3RvcnMucHVzaC5hcHBseShpbmplY3RvcnMsIHRoaXMuZ2V0SW5qZWN0b3JzT3JEZWZhdWx0KHR5cGUpKTtcclxuICAgICAgICAgICAgdHlwZSA9IHR5cGUuYmFzZVR5cGU7XHJcbiAgICAgICAgfSB3aGlsZSAodHlwZSk7XHJcbiAgICAgICAgcmV0dXJuIGluamVjdG9ycztcclxuICAgIH07XHJcbiAgICBFbnRpdHlTZXJpYWxpemVyLnByb3RvdHlwZS5zZXJpYWxpemVQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gKGVudGl0eSwgcHJvcGVydHksIHZhbHVlLCBzZXR0aW5ncykge1xyXG4gICAgICAgIHZhciBjb252ZXJ0ZXJzID0gdGhpcy5fcHJvcGVydHlDb252ZXJ0ZXJzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zaG91bGRDb252ZXJ0KGVudGl0eSwgcHJvcGVydHkpOyB9KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnZlcnRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY29udmVydGVyc18xID0gY29udmVydGVyczsgX2kgPCBjb252ZXJ0ZXJzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnZlcnRlciA9IGNvbnZlcnRlcnNfMVtfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IGNvbnZlcnRlci5zZXJpYWxpemUoZW50aXR5LCB2YWx1ZSwgcHJvcGVydHksIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmZvcmNlIHx8IHJlcyAhPT0gZXhwb3J0cy5JZ25vcmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gRW50aXR5U2VyaWFsaXplci5kZWZhdWx0UHJvcGVydHlDb252ZXJ0ZXIuc2VyaWFsaXplKGVudGl0eSwgdmFsdWUsIHByb3BlcnR5LCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCAhPT0gZXhwb3J0cy5JZ25vcmVQcm9wZXJ0eSAmJiBzZXR0aW5ncy51c2VBbGlhc2VzKVxyXG4gICAgICAgICAgICByZXN1bHQua2V5ID0gdGhpcy5nZXRQcm9wZXJ0eUFsaWFzZXMocHJvcGVydHkuY29udGFpbmluZ1R5cGUpW3Byb3BlcnR5Lm5hbWVdIHx8IHJlc3VsdC5rZXk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByb2R1Y2VzIGEgSlNPTi12YWxpZCBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGVudGl0eS5cclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgRW50aXR5U2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKGVudGl0eSwgc2V0dGluZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7IHNldHRpbmdzID0gZXhwb3J0cy5EZWZhdWx0U2VyaWFsaXphdGlvblNldHRpbmdzOyB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIHZhciB0eXBlID0gZW50aXR5Lm1ldGEudHlwZTtcclxuICAgICAgICBoZWxwZXJzXzEuZmxhdE1hcCh0aGlzLmdldFByb3BlcnR5SW5qZWN0b3JzKHR5cGUpLCBmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5pbmplY3QoZW50aXR5KTsgfSlcclxuICAgICAgICAgICAgLmNvbmNhdCh0eXBlLnByb3BlcnRpZXNcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gIXAuaXNDYWxjdWxhdGVkICYmICFwLmlzQ29uc3RhbnQ7IH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIF90aGlzLnNlcmlhbGl6ZVByb3BlcnR5VmFsdWUoZW50aXR5LCBwcm9wLCBwcm9wLnZhbHVlKGVudGl0eSksIHNldHRpbmdzKTsgfSkpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XHJcbiAgICAgICAgICAgIGlmIChwYWlyICYmIHBhaXIgIT09IGV4cG9ydHMuSWdub3JlUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaGFzT3duUHJvcGVydHkocGFpci5rZXkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3BlcnR5ICdcIiArIHBhaXIua2V5ICsgXCInIHdhcyBlbmNvdW50ZXJlZCB0d2ljZSBkdXJpbmcgc2VyaWFsaXphdGlvbi4gTWFrZSBzdXJlIGluamVjdGVkIHByb3BlcnRpZXMgZG8gbm90IGNvbGxpZGUgd2l0aCBtb2RlbCBwcm9wZXJ0aWVzLlwiKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtwYWlyLmtleV0gPSBwYWlyLnZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBFbnRpdHlTZXJpYWxpemVyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZGF0YSwgcHJvcGVydHksIGNvbnRleHQsIGNvbnN0cnVjdEVudGl0eSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGNvbnN0cnVjdEVudGl0eSA9PT0gdm9pZCAwKSB7IGNvbnN0cnVjdEVudGl0eSA9IHRydWU7IH1cclxuICAgICAgICAvLyBBcHBseSBjdXN0b20gY29udmVydGVycyBiZWZvcmUgZGVzZXJpYWxpemluZ1xyXG4gICAgICAgIHZhciBjb252ZXJ0ZXIgPSB0aGlzLl9wcm9wZXJ0eUNvbnZlcnRlcnMuZmluZChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5zaG91bGRDb252ZXJ0KGluc3RhbmNlLCBwcm9wZXJ0eSk7IH0pO1xyXG4gICAgICAgIGlmIChjb252ZXJ0ZXIpXHJcbiAgICAgICAgICAgIGRhdGEgPSBjb252ZXJ0ZXIuZGVzZXJpYWxpemUoaW5zdGFuY2UsIGRhdGEsIHByb3BlcnR5KTtcclxuICAgICAgICBpZiAoZGF0YSA9PT0gZXhwb3J0cy5JZ25vcmVQcm9wZXJ0eSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB2YXIgcmVzb2x2ZUVudGl0eSA9IGZ1bmN0aW9uICh0eXBlLCBzdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgZW50aXR5O1xyXG4gICAgICAgICAgICB2YXIgaWQgPSB0eXBlLm1ldGEuaWRlbnRpZmllciA/IHN0YXRlW3R5cGUubWV0YS5pZGVudGlmaWVyLm5hbWVdIDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKGlkKVxyXG4gICAgICAgICAgICAgICAgZW50aXR5ID0gdHlwZS5tZXRhLmdldChpZCk7XHJcbiAgICAgICAgICAgIGlmICghZW50aXR5KVxyXG4gICAgICAgICAgICAgICAgZW50aXR5ID0gbmV3IHR5cGUoaWQsIHN0YXRlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgcmV0dXJuIGVudGl0eTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEVudGl0aWVzXHJcbiAgICAgICAgaWYgKHR5cGVfMS5pc0VudGl0eVR5cGUocHJvcGVydHkucHJvcGVydHlUeXBlKSkge1xyXG4gICAgICAgICAgICB2YXIgQ2hpbGRFbnRpdHlfMSA9IHByb3BlcnR5LnByb3BlcnR5VHlwZTtcclxuICAgICAgICAgICAgaWYgKCFjb25zdHJ1Y3RFbnRpdHkpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRhdGE7XHJcbiAgICAgICAgICAgIC8vIEVudGl0eSBMaXN0XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5LmlzTGlzdCAmJiBBcnJheS5pc0FycmF5KGRhdGEpKVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcyBpbnN0YW5jZW9mIENoaWxkRW50aXR5XzEgPyBzIDogcmVzb2x2ZUVudGl0eShDaGlsZEVudGl0eV8xLCBzKTsgfSk7XHJcbiAgICAgICAgICAgIC8vIEVudGl0eVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQ2hpbGRFbnRpdHlfMSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0YTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdClcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzb2x2ZUVudGl0eShDaGlsZEVudGl0eV8xLCBkYXRhKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVmFsdWUgTGlzdFxyXG4gICAgICAgIGVsc2UgaWYgKHByb3BlcnR5LmlzTGlzdCAmJiBBcnJheS5pc0FycmF5KGRhdGEpKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGEubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBfdGhpcy5kZXNlcmlhbGl6ZShpbnN0YW5jZSwgaSwgcHJvcGVydHksIGNvbnRleHQpOyB9KTtcclxuICAgICAgICAvLyBWYWx1ZVxyXG4gICAgICAgIGVsc2UgaWYgKHByb3BlcnR5LmZvcm1hdCAmJiBkYXRhICYmIHR5cGVvZiAoZGF0YSkgPT09IFwic3RyaW5nXCIgJiYgZGF0YS5jb25zdHJ1Y3RvciAhPT0gcHJvcGVydHkucHJvcGVydHlUeXBlKVxyXG4gICAgICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmZvcm1hdC5jb252ZXJ0RnJvbVN0cmluZyhkYXRhKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5U2VyaWFsaXplci5wcm90b3R5cGUuZ2V0UHJvcGVydHlBbGlhc2VzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fcHJvcGVydHlBbGlhc2VzLmdldCh0eXBlKSwgdGhpcy5fcHJvcGVydHlBbGlhc2VzLmdldCh0eXBlLmZ1bGxOYW1lKSk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5U2VyaWFsaXplci5wcm90b3R5cGUucmVzb2x2ZVByb3BlcnR5ID0gZnVuY3Rpb24gKGNvbnRleHQsIHByb3BOYW1lKSB7XHJcbiAgICAgICAgdmFyIHByb3AgPSBjb250ZXh0Lm1ldGEudHlwZS5nZXRQcm9wZXJ0eShwcm9wTmFtZSk7XHJcbiAgICAgICAgaWYgKHByb3ApXHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgIHByb3BOYW1lID0gdGhpcy5nZXRQcm9wZXJ0eUFsaWFzZXMoY29udGV4dC5tZXRhLnR5cGUpW3Byb3BOYW1lXTtcclxuICAgICAgICByZXR1cm4gY29udGV4dC5tZXRhLnR5cGUuZ2V0UHJvcGVydHkocHJvcE5hbWUpO1xyXG4gICAgfTtcclxuICAgIEVudGl0eVNlcmlhbGl6ZXIucHJvdG90eXBlLnJlc29sdmVWYWx1ZSA9IGZ1bmN0aW9uIChjb250ZXh0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fdmFsdWVSZXNvbHZlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHZlID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzb2x2ZShjb250ZXh0LCBwcm9wZXJ0eSwgdmFsdWUpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW50aXR5U2VyaWFsaXplci5kZWZhdWx0UHJvcGVydHlDb252ZXJ0ZXIgPSBuZXcgUHJvcGVydHlDb252ZXJ0ZXIoKTtcclxuICAgIHJldHVybiBFbnRpdHlTZXJpYWxpemVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkVudGl0eVNlcmlhbGl6ZXIgPSBFbnRpdHlTZXJpYWxpemVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fc3ByZWFkQXJyYXlzID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5cykgfHwgZnVuY3Rpb24gKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5pc0VudGl0eSA9IGV4cG9ydHMuRW50aXR5ID0gdm9pZCAwO1xyXG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XHJcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xyXG52YXIgaW5pdGlsaXphdGlvbl9jb250ZXh0XzEgPSByZXF1aXJlKFwiLi9pbml0aWxpemF0aW9uLWNvbnRleHRcIik7XHJcbnZhciBvYmplY3RfbWV0YV8xID0gcmVxdWlyZShcIi4vb2JqZWN0LW1ldGFcIik7XHJcbnZhciBwcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vcHJvcGVydHlcIik7XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG52YXIgZW50aXR5X3NlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuL2VudGl0eS1zZXJpYWxpemVyXCIpO1xyXG52YXIgRW50aXR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW50aXR5KHR5cGUsIGlkLCBwcm9wZXJ0aWVzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBXYXJuIGFib3V0IGRpcmVjdCBjYWxsIGluIGRldiBidWlsZD9cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoRW50aXR5LmN0b3JEZXB0aCA9PT0gMClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW50aXR5IGNvbnN0cnVjdG9yIHNob3VsZCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5LlwiKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NvbnRleHRcIiwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBudWxsIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhY2Nlc3NlZFwiLCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBuZXcgZXZlbnRzXzEuRXZlbnQoKSB9KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2hhbmdlZFwiLCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBuZXcgZXZlbnRzXzEuRXZlbnQoKSB9KTtcclxuICAgICAgICAgICAgdmFyIGlzTmV3XzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIHR5cGUuYXNzZXJ0VmFsaWRJZChpZCk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2FzIGlkIHByb3ZpZGVkIGFzIHVuZGVmaW5lZCwgb3Igbm90IHByb3ZpZGVkIGF0IGFsbD9cclxuICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCAmJiB0eXBlb2YgaWQgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllcyA9IGlkO1xyXG4gICAgICAgICAgICAgICAgaWQgPSB0eXBlLm5ld0lkKCk7XHJcbiAgICAgICAgICAgICAgICBpc05ld18xID0gY29udGV4dCA/IGNvbnRleHQuaXNOZXdEb2N1bWVudCA6IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSWYgY29udGV4dCB3YXMgcHJvdmlkZWQsIGl0IHNob3VsZCBiZSB0aGUgbGFzdCBhcmd1bWVudFxyXG4gICAgICAgICAgICBjb250ZXh0ID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIGluaXRpbGl6YXRpb25fY29udGV4dF8xLkluaXRpYWxpemF0aW9uQ29udGV4dCkpXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gbmV3IGluaXRpbGl6YXRpb25fY29udGV4dF8xLkluaXRpYWxpemF0aW9uQ29udGV4dChpc05ld18xKTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IG5ldyBvYmplY3RfbWV0YV8xLk9iamVjdE1ldGEodHlwZSwgdGhpcywgaWQsIGlzTmV3XzEpIH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX2ZpZWxkc19fXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IHt9IH0pO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfX3BlbmRpbmdJbml0X19cIiwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZToge30gfSk7XHJcbiAgICAgICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXdseSBjb25zdHJ1Y3RlZCBpbnN0YW5jZVxyXG4gICAgICAgICAgICB0eXBlLnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGV4aXN0aW5nIGVudGl0eSB3aXRoIHByb3ZpZGVkIHByb3BlcnR5IHZhbHVlc1xyXG4gICAgICAgICAgICBpZiAoIWlzTmV3XzEgJiYgcHJvcGVydGllcykge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBwYXVzZSBwcm9jZXNzaW5nIG9mIGNhbGxiYWNrcyB0byBwcmV2ZW50IHB1Ymxpc2hpbmcgZW50aXR5IGV2ZW50cyB3aGlsZSBzdGlsbCBwcm9jZXNzaW5nIHRoZSBzdGF0ZSBncmFwaFxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5leGVjdXRlKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmluaXQocHJvcGVydGllcywgY29udGV4dCk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJhaXNlIHRoZSBpbml0TmV3IG9yIGluaXRFeGlzdGluZyBldmVudCBvbiB0aGlzIHR5cGUgYW5kIGFsbCBiYXNlIHR5cGVzXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGV4dC53aGVuUmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB2YWx1ZXMgb2YgbmV3IGVudGl0eSBmb3IgcHJvdmlkZWQgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05ld18xICYmIHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVdpdGhDb250ZXh0KGNvbnRleHQsIHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSB0eXBlOyB0OyB0ID0gdC5iYXNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZXdfMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuaW5pdE5ldy5wdWJsaXNoKHQsIHsgZW50aXR5OiBfdGhpcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdC5pbml0RXhpc3RpbmcucHVibGlzaCh0LCB7IGVudGl0eTogX3RoaXMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQud2hlblJlYWR5KHJlc29sdmUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEVudGl0eS5nZXRTb3J0ZWRQcm9wZXJ0eURhdGEgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xyXG4gICAgICAgIHJldHVybiBoZWxwZXJzXzEuZW50cmllcyhwcm9wZXJ0aWVzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIoYlsxXSBpbnN0YW5jZW9mIEVudGl0eSkgLSBOdW1iZXIoYVsxXSBpbnN0YW5jZW9mIEVudGl0eSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHByb3BlcnR5LCBjb250ZXh0LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChFbnRpdHkuY3RvckRlcHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVudGl0eS5pbml0KCkgc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvcGVydGllcztcclxuICAgICAgICAvLyBDb252ZXJ0IHByb3BlcnR5L3ZhbHVlIHBhaXIgdG8gYSBwcm9wZXJ0eSBkaWN0aW9uYXJ5XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgcHJvcGVydGllcyA9IChfYSA9IHt9LCBfYVtwcm9wZXJ0eV0gPSB2YWx1ZSwgX2EpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnR5O1xyXG4gICAgICAgIHZhciBpbml0aWFsaXplZFByb3BzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHByb3BOYW1lLCBzdGF0ZSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHRoaXNfMS5zZXJpYWxpemVyLnJlc29sdmVQcm9wZXJ0eSh0aGlzXzEsIHByb3BOYW1lKTtcclxuICAgICAgICAgICAgaWYgKHByb3AgJiYgIXByb3AuaXNDYWxjdWxhdGVkICYmICFwcm9wLmlzQ29uc3RhbnQpIHtcclxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkUHJvcHMuYWRkKHByb3ApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlUmVzb2x1dGlvbiA9IGNvbnRleHQudHJ5UmVzb2x2ZVZhbHVlKHRoaXNfMSwgcHJvcCwgc3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlUmVzb2x1dGlvbilcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlc29sdXRpb24udGhlbihmdW5jdGlvbiAoYXN5bmNTdGF0ZSkgeyByZXR1cm4gX3RoaXMuaW5pdFByb3AocHJvcCwgYXN5bmNTdGF0ZSwgY29udGV4dCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNfMS5pbml0UHJvcChwcm9wLCBzdGF0ZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzEgPSB0aGlzO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYiA9IEVudGl0eS5nZXRTb3J0ZWRQcm9wZXJ0eURhdGEocHJvcGVydGllcyk7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBfYyA9IF9iW19pXSwgcHJvcE5hbWUgPSBfY1swXSwgc3RhdGUgPSBfY1sxXTtcclxuICAgICAgICAgICAgX2xvb3BfMShwcm9wTmFtZSwgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXNzIGFsbCB1bnNwZWNpZmllZCBwcm9wZXJ0aWVzIHRocm91Z2ggdGhlIGRlc2VyaWFsaXplciB0byBhbGxvdyBpbml0aWFsaXphdGlvbiBsb2dpYyB2aWEgY29udmVydGVyc1xyXG4gICAgICAgIGZvciAodmFyIF9kID0gMCwgX2UgPSB0aGlzLm1ldGEudHlwZS5wcm9wZXJ0aWVzLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gIWluaXRpYWxpemVkUHJvcHMuaGFzKHApOyB9KTsgX2QgPCBfZS5sZW5ndGg7IF9kKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSBfZVtfZF07XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZV8xID0gdGhpcy5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHRoaXMsIHVuZGVmaW5lZCwgcHJvcCwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZV8xICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eV8xLlByb3BlcnR5JGluaXQocHJvcCwgdGhpcywgdmFsdWVfMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVudGl0eS5wcm90b3R5cGUuaW5pdFByb3AgPSBmdW5jdGlvbiAocHJvcCwgc3RhdGUsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSB0aGlzLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUodGhpcywgc3RhdGUsIHByb3AsIGNvbnRleHQpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBwcm9wZXJ0eV8xLlByb3BlcnR5JGluaXQocHJvcCwgdGhpcywgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIEVudGl0eS5wcm90b3R5cGUudXBkYXRlV2l0aENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCwgc3RhdGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBoYWRDb250ZXh0ID0gISF0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyByZWVudHJhbnQgdXBkYXRlcyBvZiB0aGUgc2FtZSBlbnRpdHkgZm9yIGEgZ2l2ZW4gY29udGV4dFxyXG4gICAgICAgIGlmICh0aGlzLl9jb250ZXh0ID09PSBjb250ZXh0KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gRG9uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGNvbnRleHRcclxuICAgICAgICBpZiAoIXRoaXMuX2NvbnRleHQpXHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIC8vIEVuc3VyZSBwcm92aWRlZCBjb250ZXh0IHdhaXRzIG9uIHRoZSBleGlzdGluZyBjb250ZXh0IHRvIGJlIHJlYWR5XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY29udGV4dCAhPT0gY29udGV4dClcclxuICAgICAgICAgICAgY29udGV4dC53YWl0KHRoaXMuX2NvbnRleHQucmVhZHkpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKHN0YXRlKTtcclxuICAgICAgICBpZiAoY29udGV4dCAhPT0gbnVsbCAmJiAhaGFkQ29udGV4dCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LndoZW5SZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbnRpdHkuY3JlYXRlT3JVcGRhdGUgPSBmdW5jdGlvbiAodHlwZSwgc3RhdGUsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgaWQgPSB0eXBlXzEuZ2V0SWRGcm9tU3RhdGUodHlwZSwgc3RhdGUpO1xyXG4gICAgICAgIHZhciBpc05ldyA9ICFpZDtcclxuICAgICAgICBpZiAoIWNvbnRleHQpXHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBuZXcgaW5pdGlsaXphdGlvbl9jb250ZXh0XzEuSW5pdGlhbGl6YXRpb25Db250ZXh0KGlzTmV3KTtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIHBhdXNlIHByb2Nlc3Npbmcgb2YgY2FsbGJhY2tzIHRvIHByZXZlbnQgcHVibGlzaGluZyBlbnRpdHkgZXZlbnRzIHdoaWxlIHN0aWxsIHByb2Nlc3NpbmdcclxuICAgICAgICAvLyB0aGUgc3RhdGUgZ3JhcGhcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjb250ZXh0LmV4ZWN1dGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpZCAmJiB0eXBlLmdldChpZCk7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIHN0YXRlIHRvIHRoZSBleGlzdGluZyBvYmplY3RcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZVdpdGhDb250ZXh0KGNvbnRleHQsIHN0YXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENhc3QgdGhlIGpzdHlwZSB0byBhbnkgc28gd2UgY2FuIGNhbGwgdGhlIGludGVybmFsIGNvbnN0cnVjdG9yIHNpZ25hdHVyZSB0aGF0IHRha2VzIGEgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBwdXQgdGhlIGNvbnRleHQgb24gdGhlIHB1YmxpYyBjb25zdHJ1Y3RvciBpbnRlcmZhY2VcclxuICAgICAgICAgICAgICAgIHZhciBDdG9yID0gdHlwZS5qc3R5cGU7XHJcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgYW4gaW5zdGFuY2UgdXNpbmcgdGhlIGtub3duIGlkIGlmIGl0IGlzIHByZXNlbnRcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gKGlkID8gbmV3IEN0b3IoaWQsIHN0YXRlLCBjb250ZXh0KSA6IG5ldyBDdG9yKHN0YXRlLCBjb250ZXh0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH07XHJcbiAgICBFbnRpdHkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcHJvcGVydGllcztcclxuICAgICAgICAvLyBDb252ZXJ0IHByb3BlcnR5L3ZhbHVlIHBhaXIgdG8gYSBwcm9wZXJ0eSBkaWN0aW9uYXJ5XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgcHJvcGVydGllcyA9IChfYSA9IHt9LCBfYVtwcm9wZXJ0eV0gPSB2YWx1ZSwgX2EpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnR5O1xyXG4gICAgICAgIGlmICghdGhpcy5fY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgd2FzTmV3XzEgPSB0aGlzLm1ldGEuaXNOZXc7XHJcbiAgICAgICAgICAgIHZhciBjb250ZXh0XzEgPSBuZXcgaW5pdGlsaXphdGlvbl9jb250ZXh0XzEuSW5pdGlhbGl6YXRpb25Db250ZXh0KHRydWUpO1xyXG4gICAgICAgICAgICBjb250ZXh0XzEuZXhlY3V0ZShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51cGRhdGVXaXRoQ29udGV4dChjb250ZXh0XzEsIHByb3BlcnRpZXMpOyB9KTtcclxuICAgICAgICAgICAgdmFyIG1hcmtQZXJzaXN0ZWRXaGVuSWRBc3NpZ25lZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3YXNOZXdfMSAmJiAhX3RoaXMubWV0YS5pc05ldylcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXJrUGVyc2lzdGVkKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIGNhbGwgbWFya1BlcnNpc3RlZFdoZW5JZEFzc2lnbmVkIHVzaW5nIHdoZW5SZWFkeSBhbmQgYWZ0ZXIgdGhlIHByb21pc2UgcmVzb2x2ZXMgdG8gZW5zdXJlIG1vZGVscyB3aXRoIG5vIGFzeW5jXHJcbiAgICAgICAgICAgIC8vIGJlaGF2aW9yIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb3V0Y29tZSB1cG9uIHJldHVybmluZyBmcm9tIHVwZGF0ZSgpXHJcbiAgICAgICAgICAgIGNvbnRleHRfMS53aGVuUmVhZHkobWFya1BlcnNpc3RlZFdoZW5JZEFzc2lnbmVkKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRfMS5yZWFkeS50aGVuKG1hcmtQZXJzaXN0ZWRXaGVuSWRBc3NpZ25lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc3RhdGUpIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSB0aGlzXzIuc2VyaWFsaXplci5yZXNvbHZlUHJvcGVydHkodGhpc18yLCBwcm9wTmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChwcm9wICYmICFwcm9wLmlzQ2FsY3VsYXRlZCAmJiAhcHJvcC5pc0NvbnN0YW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVSZXNvbHV0aW9uID0gY29udGV4dC50cnlSZXNvbHZlVmFsdWUodGhpc18yLCBwcm9wLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVSZXNvbHV0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlUmVzb2x1dGlvbi50aGVuKGZ1bmN0aW9uIChhc3luY1N0YXRlKSB7IHJldHVybiBfdGhpcy5zZXRQcm9wKHByb3AsIGFzeW5jU3RhdGUpOyB9KTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzXzIuc2V0UHJvcChwcm9wLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciB0aGlzXzIgPSB0aGlzO1xyXG4gICAgICAgIC8vIFNldCB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXNcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9iID0gRW50aXR5LmdldFNvcnRlZFByb3BlcnR5RGF0YShwcm9wZXJ0aWVzKTsgX2kgPCBfYi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIF9jID0gX2JbX2ldLCBwcm9wTmFtZSA9IF9jWzBdLCBzdGF0ZSA9IF9jWzFdO1xyXG4gICAgICAgICAgICBfbG9vcF8yKHByb3BOYW1lLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250ZXh0LnJlYWR5O1xyXG4gICAgfTtcclxuICAgIEVudGl0eS5wcm90b3R5cGUuc2V0UHJvcCA9IGZ1bmN0aW9uIChwcm9wLCBzdGF0ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBwcm9wLnZhbHVlKHRoaXMpO1xyXG4gICAgICAgIGlmICh0eXBlXzEuaXNFbnRpdHlUeXBlKHByb3AucHJvcGVydHlUeXBlKSkge1xyXG4gICAgICAgICAgICB2YXIgQ2hpbGRFbnRpdHlfMSA9IHByb3AucHJvcGVydHlUeXBlO1xyXG4gICAgICAgICAgICBpZiAocHJvcC5pc0xpc3QgJiYgQXJyYXkuaXNBcnJheShzdGF0ZSkgJiYgQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuc3BsaWNlKDApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZm9yRWFjaChmdW5jdGlvbiAocywgaWR4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHMgaW5zdGFuY2VvZiBDaGlsZEVudGl0eV8xKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBfdGhpcy5zZXJpYWxpemVyLmRlc2VyaWFsaXplKF90aGlzLCBzLCBwcm9wLCBfdGhpcy5fY29udGV4dCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQoSWdub3JlUHJvcGVydHkpIGdvdCBhc3NpZ25lZCwgc28gZG8gbm90IHNldCB0aGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9kaWZ5aW5nL3JlcGxhY2luZyBleGlzdGluZyBsaXN0IGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IGN1cnJlbnRWYWx1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpdGVtIGlzIGEgc3RhdGUgb2JqZWN0LCBjcmVhdGUvdXBkYXRlIHRoZSBlbnRpdHkgdXNpbmcgdGhlIHN0YXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzIGluc3RhbmNlb2YgQ2hpbGRFbnRpdHlfMSkgJiYgdHlwZW9mIHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdEl0ZW0gPSBjdXJyZW50VmFsdWVbaWR4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZW50aXR5IGlzIGEgbm9uLXBvb2xlZCB0eXBlLCB1cGRhdGUgaW4gcGxhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZW50aXR5IGlkIG1hdGNoZXMgdGhlIGlkIGluIHRoZSBzdGF0ZSwgdXBkYXRlIGluIHBsYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFDaGlsZEVudGl0eV8xLm1ldGEuaWRlbnRpZmllciB8fCB0eXBlXzEuZ2V0SWRGcm9tU3RhdGUoQ2hpbGRFbnRpdHlfMS5tZXRhLCBzKSA9PT0gbGlzdEl0ZW0ubWV0YS5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEl0ZW0udXBkYXRlV2l0aENvbnRleHQoX3RoaXMuX2NvbnRleHQsIHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnNwbGljZShpZHgsIDEsIEVudGl0eS5jcmVhdGVPclVwZGF0ZShDaGlsZEVudGl0eV8xLm1ldGEsIHMsIF90aGlzLl9jb250ZXh0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzIGluc3RhbmNlb2YgQ2hpbGRFbnRpdHlfMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuc3BsaWNlKGlkeCwgMSwgcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUHJvdmlkZWQgc3RhdGUsXCIsIHMsIFwiLCBpcyBub3QgdmFsaWQgZm9yIHR5cGUgXCIgKyBDaGlsZEVudGl0eV8xLm1ldGEuZnVsbE5hbWUgKyBcIltdLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBsaXN0IGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocyBpbnN0YW5jZW9mIENoaWxkRW50aXR5XzEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUucHVzaChzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnB1c2goRW50aXR5LmNyZWF0ZU9yVXBkYXRlKENoaWxkRW50aXR5XzEubWV0YSwgcywgX3RoaXMuX2NvbnRleHQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGl0ZW1zIGZyb20gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUuc3BsaWNlKHN0YXRlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBNYXJrIHByb3BlcnR5IHBlbmRpbmdJbml0ID0gZmFsc2UsIHNpbmNlIHZhbHVlIGlzIG5vdCBhc3NpZ25lZCBzbyB0aGUgc2V0dGVyIGlzIG5vdCBjYWxsZWRcclxuICAgICAgICAgICAgICAgIHByb3BlcnR5XzEuUHJvcGVydHkkcGVuZGluZ0luaXQodGhpcywgcHJvcCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlIGluc3RhbmNlb2YgQ2hpbGRFbnRpdHlfMSlcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RhdGU7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBkZXNlcmlhbGl6ZSB0aGUgc3RhdGVcclxuICAgICAgICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IHRoaXMuc2VyaWFsaXplci5kZXNlcmlhbGl6ZSh0aGlzLCBzdGF0ZSwgcHJvcCwgdGhpcy5fY29udGV4dCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gVW5kZWZpbmVkKElnbm9yZVByb3BlcnR5KSBnb3QgYXNzaWduZWQsIHNvIGRvIG5vdCBzZXQgdGhlIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1N0YXRlICE9PSBcInVuZGVmaW5lZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gbmV3U3RhdGU7XHJcbiAgICAgICAgICAgICAgICAvLyBHb3QgbnVsbCwgc28gYXNzaWduIG51bGwgdG8gdGhlIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAvLyBHb3QgYSB2YWxpZCBpbnN0YW5jZSwgc28gdXNlIGl0XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSBpbnN0YW5jZW9mIENoaWxkRW50aXR5XzEpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIC8vIEdvdCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBvYmplY3QsIHNvIGp1c3QgdXNlIGl0IGFuZCBleHBlY3QgdG8gZ2V0IGEgZG93bi1zdHJlYW0gZXJyb3JcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdGF0ZSAhPT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0YXRlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFZhbHVlICYmICF0eXBlXzEuZ2V0SWRGcm9tU3RhdGUoQ2hpbGRFbnRpdHlfMS5tZXRhLCBzdGF0ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlLnVwZGF0ZVdpdGhDb250ZXh0KHRoaXMuX2NvbnRleHQsIHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIC8vIEdvdCBhbiBvYmplY3QsIHNvIGF0dGVtcHQgdG8gZmV0Y2ggb3IgY3JlYXRlIGFuZCBhc3NpZ24gdGhlIHN0YXRlXHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBFbnRpdHkuY3JlYXRlT3JVcGRhdGUoQ2hpbGRFbnRpdHlfMS5tZXRhLCBzdGF0ZSwgdGhpcy5fY29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJvcC5pc0xpc3QgJiYgQXJyYXkuaXNBcnJheShzdGF0ZSkgJiYgQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZS5zcGxpY2UuYXBwbHkoY3VycmVudFZhbHVlLCBfX3NwcmVhZEFycmF5cyhbMCwgY3VycmVudFZhbHVlLmxlbmd0aF0sIHN0YXRlLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gX3RoaXMuc2VyaWFsaXplci5kZXNlcmlhbGl6ZShfdGhpcywgcywgcHJvcCwgX3RoaXMuX2NvbnRleHQpOyB9KSkpO1xyXG4gICAgICAgICAgICAvLyBNYXJrIHByb3BlcnR5IHBlbmRpbmdJbml0ID0gZmFsc2UsIHNpbmNlIHZhbHVlIGlzIG5vdCBhc3NpZ25lZCBzbyB0aGUgc2V0dGVyIGlzIG5vdCBjYWxsZWRcclxuICAgICAgICAgICAgcHJvcGVydHlfMS5Qcm9wZXJ0eSRwZW5kaW5nSW5pdCh0aGlzLCBwcm9wLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUodGhpcywgc3RhdGUsIHByb3AsIHRoaXMuX2NvbnRleHQpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHlfMS5Qcm9wZXJ0eSRzZXR0ZXIocHJvcCwgdGhpcywgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbnRpdHkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1ldGEudHlwZS5nZXRQcm9wZXJ0eShwcm9wZXJ0eSkudmFsdWUodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChmb3JtYXQsIGZvcm1hdEV2YWwpIHtcclxuICAgICAgICAvLyBHZXQgdGhlIGVudGl0eSBmb3JtYXQgdG8gdXNlXHJcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IG51bGw7XHJcbiAgICAgICAgaWYgKGZvcm1hdCkge1xyXG4gICAgICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLm1ldGEudHlwZS5tb2RlbC5nZXRGb3JtYXQodGhpcy5jb25zdHJ1Y3RvciwgZm9ybWF0LCBmb3JtYXRFdmFsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvcm1hdHRlciA9IHRoaXMubWV0YS50eXBlLmZvcm1hdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXNlIHRoZSBmb3JtYXR0ZXIsIGlmIGF2YWlsYWJsZSwgdG8gY3JlYXRlIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cclxuICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXIuY29udmVydCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ldGEudHlwZS5mdWxsTmFtZSArIFwifFwiICsgdGhpcy5tZXRhLmlkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRW50aXR5LnByb3RvdHlwZSwgXCJzZXJpYWxpemVyXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWV0YS50eXBlLm1vZGVsLnNlcmlhbGl6ZXI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9kdWNlcyBhIEpTT04tdmFsaWQgb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBlbnRpdHkuXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIEVudGl0eS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSB2b2lkIDApIHsgc2V0dGluZ3MgPSBlbnRpdHlfc2VyaWFsaXplcl8xLkRlZmF1bHRTZXJpYWxpemF0aW9uU2V0dGluZ3M7IH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVyLnNlcmlhbGl6ZSh0aGlzLCBzZXR0aW5ncyk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5LnByb3RvdHlwZS5tYXJrUGVyc2lzdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5tZXRhLnR5cGUuaWRlbnRpZmllciB8fCAhdGhpcy5tZXRhLnR5cGUuaWRlbnRpZmllci52YWx1ZSh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHZhciBfcGVyc2lzdCA9IGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKGVudGl0eSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGVudGl0eSk7XHJcbiAgICAgICAgICAgIGVudGl0eS5tZXRhLmlzTmV3ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIHZpc2l0IHJlZmVyZW5jZSBwcm9wZXJ0aWVzIHdpdGggbm9uLWlkZW50aWZ5aW5nIHR5cGVzXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBlbnRpdHkubWV0YS50eXBlLnByb3BlcnRpZXMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiB0eXBlXzEuaXNFbnRpdHlUeXBlKHAucHJvcGVydHlUeXBlKSAmJiAhcC5wcm9wZXJ0eVR5cGUubWV0YS5pZGVudGlmaWVyOyB9KTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnR5LnZhbHVlKGVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gX3BlcnNpc3QoaXRlbSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgX3BlcnNpc3QodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBfcGVyc2lzdCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBFbnRpdHkuY3RvckRlcHRoID0gMDtcclxuICAgIHJldHVybiBFbnRpdHk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRW50aXR5ID0gRW50aXR5O1xyXG5mdW5jdGlvbiBpc0VudGl0eShvYmopIHtcclxuICAgIHJldHVybiBvYmogJiYgb2JqLm1ldGEgJiYgb2JqLm1ldGEudHlwZSAmJiBvYmoubWV0YS50eXBlLmpzdHlwZSAmJiB0eXBlXzEuaXNFbnRpdHlUeXBlKG9iai5tZXRhLnR5cGUuanN0eXBlKTtcclxufVxyXG5leHBvcnRzLmlzRW50aXR5ID0gaXNFbnRpdHk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRXZlbnRTY29wZSA9IGV4cG9ydHMuRVZFTlRfU0NPUEVfREVGQVVMVF9TRVRUSU5HUyA9IHZvaWQgMDtcclxudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxuZXhwb3J0cy5FVkVOVF9TQ09QRV9ERUZBVUxUX1NFVFRJTkdTID0ge1xyXG4gICAgbWF4RXhpdGluZ1RyYW5zZmVyQ291bnQ6IDEwMCxcclxuICAgIG1heERlcHRoOiAxMDAwXHJcbn07XHJcbnZhciBfX2xhc3RFdmVudFNjb3BlSWQgPSAwO1xyXG52YXIgRXZlbnRTY29wZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50U2NvcGUocGFyZW50LCBtYXhFeGl0aW5nVHJhbnNmZXJDb3VudCwgbWF4RGVwdGgsIGlzQWN0aXZlKSB7XHJcbiAgICAgICAgaWYgKGlzQWN0aXZlID09PSB2b2lkIDApIHsgaXNBY3RpdmUgPSBmYWxzZTsgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gaXNBY3RpdmU7XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHsgbWF4RXhpdGluZ1RyYW5zZmVyQ291bnQ6IG1heEV4aXRpbmdUcmFuc2ZlckNvdW50LCBtYXhEZXB0aDogbWF4RGVwdGggfTtcclxuICAgICAgICB0aGlzLm9uRXJyb3IgPSBuZXcgZXZlbnRzXzEuRXZlbnQoKTtcclxuICAgICAgICB0aGlzLl91aWQgPSArK19fbGFzdEV2ZW50U2NvcGVJZDtcclxuICAgICAgICB0aGlzLl9kZXB0aCA9IHBhcmVudCA9PT0gbnVsbCA/IDEgOiBwYXJlbnQuX2RlcHRoICsgMTtcclxuICAgICAgICB0aGlzLl9vbkV4aXQgPSBuZXcgZXZlbnRzXzEuRXZlbnQoKTtcclxuICAgIH1cclxuICAgIEV2ZW50U2NvcGUuY3JlYXRlID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EubWF4RXhpdGluZ1RyYW5zZmVyQ291bnQsIG1heEV4aXRpbmdUcmFuc2ZlckNvdW50ID0gX2IgPT09IHZvaWQgMCA/IGV4cG9ydHMuRVZFTlRfU0NPUEVfREVGQVVMVF9TRVRUSU5HUy5tYXhFeGl0aW5nVHJhbnNmZXJDb3VudCA6IF9iLCBfYyA9IF9hLm1heERlcHRoLCBtYXhEZXB0aCA9IF9jID09PSB2b2lkIDAgPyBleHBvcnRzLkVWRU5UX1NDT1BFX0RFRkFVTFRfU0VUVElOR1MubWF4RGVwdGggOiBfYztcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50U2NvcGUobnVsbCwgbWF4RXhpdGluZ1RyYW5zZmVyQ291bnQsIG1heERlcHRoLCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGV2ZW50IHNjb3BlLCBwZXJmb3JtcyB0aGUgYWN0aW9uLCB0aGVuIGV4aXRzIHRoZSBzY29wZVxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBhY3Rpb24gdG8gcGVyZm9ybSB3aXRoaW4gdGhlIG5ldyBzY29wZVxyXG4gICAgICovXHJcbiAgICBFdmVudFNjb3BlLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIHNjb3BlID0gbmV3IEV2ZW50U2NvcGUodGhpcy5jdXJyZW50LCB0aGlzLnNldHRpbmdzLm1heEV4aXRpbmdUcmFuc2ZlckNvdW50LCB0aGlzLnNldHRpbmdzLm1heERlcHRoLCB0cnVlKTtcclxuICAgICAgICB2YXIgaXNEaXNwb3NpbmcgPSBmYWxzZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBzY29wZTtcclxuICAgICAgICAgICAgaWYgKHNjb3BlLl9kZXB0aCA+PSB0aGlzLnNldHRpbmdzLm1heERlcHRoKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhjZWVkZWQgbWF4IHNjb3BlIGRlcHRoLlwiKTtcclxuICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFja1xyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAvLyBEaXNwb3NlIG9mIHRoZSBldmVudCBzY29wZVxyXG4gICAgICAgICAgICBpc0Rpc3Bvc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5kaXNwb3NlKHsgYWJvcnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBpZiAoIWlzRGlzcG9zaW5nKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LmRpc3Bvc2UoeyBhYm9ydDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgdmFyIGVycm9yRXZlbnQgPSB0aGlzLm9uRXJyb3IucHVibGlzaCh0aGlzLCB7IGVycm9yOiBlIH0pO1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JFdmVudCA9PT0gdW5kZWZpbmVkIHx8ICFlcnJvckV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZClcclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAvLyBSb2xsIGJhY2sgdG8gdGhlIGNsb3Nlc3QgYWN0aXZlIHNjb3BlXHJcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnQgJiYgIXRoaXMuY3VycmVudC5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZXMgdG8gdGhlIFwiZXhpdFwiIGV2ZW50IG9mIHRoZSBjdXJyZW50IHNjb3BlLCBvciBpbnZva2VzIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGlzIG5vdCBhIGN1cnJlbnQgc2NvcGVcclxuICAgICAqIEBwYXJhbSBoYW5kbGVyIFRoZSBldmVudCBoYW5kbGVyIHRvIGludm9rZSB3aGVuIGV4aXRlZFxyXG4gICAgICovXHJcbiAgICBFdmVudFNjb3BlLnByb3RvdHlwZS5vbkV4aXQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gSW1tZWRpYXRlbHkgaW52b2tlIHRoZSBjYWxsYmFja1xyXG4gICAgICAgICAgICBoYW5kbGVyKHsgYWJvcnQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50LmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IGV2ZW50IHNjb3BlIGNhbm5vdCBiZSBpbmFjdGl2ZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGV4aXQgZXZlbnRcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Ll9vbkV4aXQuc3Vic2NyaWJlKGhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFNjb3BlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EuYWJvcnQsIGFib3J0ID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBldmVudCBzY29wZSBjYW5ub3QgYmUgZXhpdGVkIGJlY2F1c2UgaXQgaXMgbm90IGFjdGl2ZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChhYm9ydCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25FeGl0LnB1Ymxpc2godGhpcywgeyBhYm9ydDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleGl0U3Vic2NyaXB0aW9ucyA9IGhlbHBlcnNfMS5nZXRFdmVudFN1YnNjcmlwdGlvbnModGhpcy5fb25FeGl0KTtcclxuICAgICAgICAgICAgICAgIGlmIChleGl0U3Vic2NyaXB0aW9ucyAmJiBleGl0U3Vic2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcGFyZW50IHNjb3BlLCB0aGVuIGdvIGFoZWFkIGFuZCBleGVjdXRlIHRoZSAnZXhpdCcgZXZlbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgPT09IG51bGwgfHwgIXRoaXMucGFyZW50LmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB0aGUgaW5pdGlhbCBcInZlcnNpb25cIiBiZWZvcmUgc3RhcnRpbmcgdG8gY2FsbCBzdWJzY3JpYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9leGl0RXZlbnRWZXJzaW9uID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52b2tlIGFsbCBzdWJzY3JpYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkV4aXQucHVibGlzaCh0aGlzLCB7IGFib3J0OiBmYWxzZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsZXRlIHRoZSBmaWVsZCB0byBpbmRpY2F0ZSB0aGF0IHJhaXNpbmcgdGhlIGV4aXQgZXZlbnQgc3VjZWVkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V4aXRFdmVudFZlcnNpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBtb3ZlIHN1YnNjcmliZXJzIHRvIHRoZSBwYXJlbnQgc2NvcGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlY2VpdmVFeGl0RXZlbnRTdWJzY3JpYmVycyhleGl0U3Vic2NyaXB0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSh7IGFib3J0OiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgZXZlbnRzIHRvIGVuc3VyZSB0aGF0IHRoZXkgYXJlbid0IGluYWR2ZXJ0YW50bHkgcmFpc2VkIGFnYWluIHRocm91Z2ggdGhpcyBzY29wZVxyXG4gICAgICAgICAgICB0aGlzLl9vbkV4aXQuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBldmVudCBzY29wZSBpcyBubyBsb25nZXIgYWN0aXZlXHJcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTY29wZS5wcm90b3R5cGUucmVjZWl2ZUV4aXRFdmVudFN1YnNjcmliZXJzID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBtYXhOZXN0aW5nID0gdGhpcy5zZXR0aW5ncy5tYXhFeGl0aW5nVHJhbnNmZXJDb3VudCAtIDE7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V4aXRFdmVudFZlcnNpb24gPj0gbWF4TmVzdGluZykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGNlZWRlZCBtYXggc2NvcGUgZXZlbnQgdHJhbnNmZXIuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNb3ZlIHN1YnNjcmliZXJzIHRvIHRoZSBwYXJlbnQgc2NvcGVcclxuICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHN1YikgeyByZXR1cm4gX3RoaXMuX29uRXhpdC5zdWJzY3JpYmUoc3ViLmhhbmRsZXIpOyB9KTtcclxuICAgICAgICBpZiAodGhpcy5fZXhpdEV2ZW50VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2V4aXRFdmVudFZlcnNpb24rKztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTY29wZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIgKyAodGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC50b1N0cmluZygpICsgXCItPlwiIDogXCJcIikgKyB0aGlzLl91aWQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50U2NvcGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRXZlbnRTY29wZSA9IEV2ZW50U2NvcGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRXZlbnQgPSBleHBvcnRzLmNyZWF0ZUV2ZW50T2JqZWN0ID0gZXhwb3J0cy5FdmVudE9iamVjdEltcGwgPSB2b2lkIDA7XHJcbnZhciBmdW5jdG9yXzEgPSByZXF1aXJlKFwiLi9mdW5jdG9yXCIpO1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxudmFyIEV2ZW50T2JqZWN0SW1wbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50T2JqZWN0SW1wbCgpIHtcclxuICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgRXZlbnRPYmplY3RJbXBsLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50T2JqZWN0SW1wbDtcclxufSgpKTtcclxuZXhwb3J0cy5FdmVudE9iamVjdEltcGwgPSBFdmVudE9iamVjdEltcGw7XHJcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50T2JqZWN0KGFyZ3MpIHtcclxuICAgIHZhciBldmVudE9iamVjdCA9IG5ldyBFdmVudE9iamVjdEltcGwoKTtcclxuICAgIGZvciAodmFyIHByb3AgaW4gYXJncykge1xyXG4gICAgICAgIGlmIChoZWxwZXJzXzEuaGFzT3duUHJvcGVydHkoYXJncywgcHJvcCkpIHtcclxuICAgICAgICAgICAgZXZlbnRPYmplY3RbcHJvcF0gPSBhcmdzW3Byb3BdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBldmVudE9iamVjdDtcclxufVxyXG5leHBvcnRzLmNyZWF0ZUV2ZW50T2JqZWN0ID0gY3JlYXRlRXZlbnRPYmplY3Q7XHJcbnZhciBFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50KHN1YnNjcmlwdGlvbkNoYW5nZWQpIHtcclxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNoYW5nZWQgPSBzdWJzY3JpcHRpb25DaGFuZ2VkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEV2ZW50LnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKHRoaXNPYmplY3QsIGFyZ3MpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZnVuYykge1xyXG4gICAgICAgICAgICAvLyBObyBzdWJzY3JpYmVyc1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBldmVudE9iamVjdCA9IGNyZWF0ZUV2ZW50T2JqZWN0KGFyZ3MpO1xyXG4gICAgICAgIHRoaXMuZnVuYy5jYWxsKHRoaXNPYmplY3QsIGV2ZW50T2JqZWN0KTtcclxuICAgICAgICByZXR1cm4gZXZlbnRPYmplY3Q7XHJcbiAgICB9O1xyXG4gICAgRXZlbnQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZ1bmMpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7IHZhbHVlOiBmdW5jdG9yXzEuRnVuY3RvciRjcmVhdGUoKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mdW5jLmFkZChoYW5kbGVyKTtcclxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DaGFuZ2VkKVxyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNoYW5nZWQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnQucHJvdG90eXBlLnN1YnNjcmliZU9uZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZ1bmMpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZnVuY1wiLCB7IHZhbHVlOiBmdW5jdG9yXzEuRnVuY3RvciRjcmVhdGUoKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mdW5jLmFkZChoYW5kbGVyLCBudWxsLCB0cnVlKTtcclxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DaGFuZ2VkKVxyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNoYW5nZWQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnQucHJvdG90eXBlLmhhc1N1YnNjcmliZXJzID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZnVuYykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmdW5jdG9ySXRlbXMgPSAodGhpcy5mdW5jLl9mdW5jcyk7XHJcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIgPyBmdW5jdG9ySXRlbXMuc29tZShmdW5jdGlvbiAoaSkgeyByZXR1cm4gaS5mbiA9PT0gaGFuZGxlcjsgfSkgOiBmdW5jdG9ySXRlbXMubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICBFdmVudC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5mdW5jKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHN1YnNjcmliZXJzXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mdW5jLnJlbW92ZShoYW5kbGVyKTtcclxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25DaGFuZ2VkKVxyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbkNoYW5nZWQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5mdW5jKSB7XHJcbiAgICAgICAgICAgIC8vIE5vIHN1YnNjcmliZXJzXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mdW5jLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uQ2hhbmdlZClcclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25DaGFuZ2VkKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudDtcclxufSgpKTtcclxuZXhwb3J0cy5FdmVudCA9IEV2ZW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkZvcm1hdEVycm9yID0gdm9pZCAwO1xyXG52YXIgY29uZGl0aW9uX3R5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbmRpdGlvbi10eXBlXCIpO1xyXG52YXIgcHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5XCIpO1xyXG52YXIgY29uZGl0aW9uXzEgPSByZXF1aXJlKFwiLi9jb25kaXRpb25cIik7XHJcbnZhciBGb3JtYXRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZvcm1hdEVycm9yKGZvcm1hdCwgbWVzc2FnZSwgaW52YWxpZFZhbHVlKSB7XHJcbiAgICAgICAgaWYgKEZvcm1hdEVycm9yLkNvbmRpdGlvblR5cGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgRm9ybWF0RXJyb3IuQ29uZGl0aW9uVHlwZSA9IG5ldyBjb25kaXRpb25fdHlwZV8xLkVycm9yQ29uZGl0aW9uVHlwZShcIkZvcm1hdEVycm9yXCIsIFwiVGhlIHZhbHVlIGlzIG5vdCBwcm9wZXJseSBmb3JtYXR0ZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICB0aGlzLm1lc3NhZ2VUZW1wbGF0ZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkVmFsdWUgPSBpbnZhbGlkVmFsdWU7XHJcbiAgICB9XHJcbiAgICBGb3JtYXRFcnJvci5wcm90b3R5cGUuY3JlYXRlQ29uZGl0aW9uID0gZnVuY3Rpb24gKHRhcmdldCwgcHJvcCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBjb25kaXRpb25fMS5Db25kaXRpb24oRm9ybWF0RXJyb3IuQ29uZGl0aW9uVHlwZSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMubWVzc2FnZVRlbXBsYXRlLnJlcGxhY2UoXCJ7cHJvcGVydHl9XCIsIHByb3BlcnR5XzEuZXZhbHVhdGVMYWJlbChwcm9wLCB0YXJnZXQpKTsgfSwgdGFyZ2V0LCB0aGlzLmZvcm1hdCwgW3Byb3BdKTtcclxuICAgIH07XHJcbiAgICBGb3JtYXRFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52YWxpZFZhbHVlO1xyXG4gICAgfTtcclxuICAgIEZvcm1hdEVycm9yLkNvbmRpdGlvblR5cGUgPSBudWxsO1xyXG4gICAgcmV0dXJuIEZvcm1hdEVycm9yO1xyXG59KCkpO1xyXG5leHBvcnRzLkZvcm1hdEVycm9yID0gRm9ybWF0RXJyb3I7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmNyZWF0ZUZvcm1hdCA9IGV4cG9ydHMuTW9kZWxGb3JtYXQgPSBleHBvcnRzLkN1c3RvbUZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0ID0gZXhwb3J0cy5nZXRGb3JtYXRUZW1wbGF0ZVBhcnNlciA9IHZvaWQgMDtcclxudmFyIGZvcm1hdF9lcnJvcl8xID0gcmVxdWlyZShcIi4vZm9ybWF0LWVycm9yXCIpO1xyXG52YXIgcHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5XCIpO1xyXG52YXIgcHJvcGVydHlfY2hhaW5fMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5LWNoYWluXCIpO1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxudmFyIG1vZGVsXzEgPSByZXF1aXJlKFwiLi9tb2RlbFwiKTtcclxudmFyIGdsb2JhbGl6YXRpb25fMSA9IHJlcXVpcmUoXCIuL2dsb2JhbGl6YXRpb25cIik7XHJcbmV4cG9ydHMuZ2V0Rm9ybWF0VGVtcGxhdGVQYXJzZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAvXFxbKFtfYS16QS1aXFx1MDBhYVxcdTAwYjVcXHUwMGJhXFx1MDBjMC1cXHUwMGQ2XFx1MDBkOC1cXHUwMGY2XFx1MDBmOC1cXHUwMmI4XFx1MDJiYi1cXHUwMmMxXFx1MDJkMC1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlZVxcdTAzNzAtXFx1MDM3M1xcdTAzNzYtXFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTIzXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjEtXFx1MDY0YVxcdTA2NjAtXFx1MDY2OVxcdTA2NmUtXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1LVxcdTA2ZTZcXHUwNmVlLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2MwLVxcdTA3ZWFcXHUwN2Y0LVxcdTA3ZjVcXHUwN2ZhXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTY2LVxcdTA5NmZcXHUwOTcxLVxcdTA5NzJcXHUwOTdiLVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmLVxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWU2LVxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmLVxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyLVxcdTBhMzNcXHUwYTM1LVxcdTBhMzZcXHUwYTM4LVxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE2Ni1cXHUwYTZmXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMi1cXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwLVxcdTBhZTFcXHUwYWU2LVxcdTBhZWZcXHUwYjA1LVxcdTBiMGNcXHUwYjBmLVxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyLVxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Yy1cXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI2Ni1cXHUwYjZmXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5LVxcdTBiOWFcXHUwYjljXFx1MGI5ZS1cXHUwYjlmXFx1MGJhMy1cXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBiZTYtXFx1MGJlZlxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNTlcXHUwYzYwLVxcdTBjNjFcXHUwYzY2LVxcdTBjNmZcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTAtXFx1MGNlMVxcdTBjZTYtXFx1MGNlZlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQyOFxcdTBkMmEtXFx1MGQzOVxcdTBkM2RcXHUwZDYwLVxcdTBkNjFcXHUwZDY2LVxcdTBkNmZcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMi1cXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU1MC1cXHUwZTU5XFx1MGU4MS1cXHUwZTgyXFx1MGU4NFxcdTBlODctXFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhLVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyLVxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZDAtXFx1MGVkOVxcdTBlZGMtXFx1MGVkZFxcdTBmMDBcXHUwZjIwLVxcdTBmMjlcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGJcXHUxMDAwLVxcdTEwMmFcXHUxMDNmLVxcdTEwNDlcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NS1cXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwOTAtXFx1MTA5OVxcdTEwYTAtXFx1MTBjNVxcdTEwZDAtXFx1MTBmYVxcdTEwZmNcXHUxMTAwLVxcdTExNTlcXHUxMTVmLVxcdTExYTJcXHUxMWE4LVxcdTExZjlcXHUxMjAwLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3NlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTdlMC1cXHUxN2U5XFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE5MDAtXFx1MTkxY1xcdTE5NDYtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhOVxcdTE5YzEtXFx1MTljN1xcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNlxcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiODMtXFx1MWJhMFxcdTFiYWUtXFx1MWJiOVxcdTFjMDAtXFx1MWMyM1xcdTFjNDAtXFx1MWM0OVxcdTFjNGQtXFx1MWM3ZFxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5NFxcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTgzLVxcdTIxODRcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjNmZcXHUyYzcxLVxcdTJjN2RcXHUyYzgwLVxcdTJjZTRcXHUyZDAwLVxcdTJkMjVcXHUyZDMwLVxcdTJkNjVcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA2XFx1MzAzMS1cXHUzMDM1XFx1MzAzYi1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWI3XFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmMzXFx1YTAwMC1cXHVhNDhjXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjJiXFx1YTY0MC1cXHVhNjVmXFx1YTY2Mi1cXHVhNjZlXFx1YTY4MC1cXHVhNjk3XFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhjXFx1YTdmYi1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThkMC1cXHVhOGQ5XFx1YTkwMC1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE1MC1cXHVhYTU5XFx1YWMwMC1cXHVkN2EzXFx1ZjkwMC1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZhXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjEwLVxcdWZmMTlcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNdW18uMC05YS16QS1aXFx1MDBhYVxcdTAwYjVcXHUwMGJhXFx1MDBjMC1cXHUwMGQ2XFx1MDBkOC1cXHUwMGY2XFx1MDBmOC1cXHUwMmI4XFx1MDJiYi1cXHUwMmMxXFx1MDJkMC1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlZVxcdTAzNzAtXFx1MDM3M1xcdTAzNzYtXFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTIzXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjEtXFx1MDY0YVxcdTA2NjAtXFx1MDY2OVxcdTA2NmUtXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1LVxcdTA2ZTZcXHUwNmVlLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2MwLVxcdTA3ZWFcXHUwN2Y0LVxcdTA3ZjVcXHUwN2ZhXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTY2LVxcdTA5NmZcXHUwOTcxLVxcdTA5NzJcXHUwOTdiLVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmLVxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWU2LVxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmLVxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyLVxcdTBhMzNcXHUwYTM1LVxcdTBhMzZcXHUwYTM4LVxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE2Ni1cXHUwYTZmXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMi1cXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwLVxcdTBhZTFcXHUwYWU2LVxcdTBhZWZcXHUwYjA1LVxcdTBiMGNcXHUwYjBmLVxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyLVxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Yy1cXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI2Ni1cXHUwYjZmXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5LVxcdTBiOWFcXHUwYjljXFx1MGI5ZS1cXHUwYjlmXFx1MGJhMy1cXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBiZTYtXFx1MGJlZlxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNTlcXHUwYzYwLVxcdTBjNjFcXHUwYzY2LVxcdTBjNmZcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTAtXFx1MGNlMVxcdTBjZTYtXFx1MGNlZlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQyOFxcdTBkMmEtXFx1MGQzOVxcdTBkM2RcXHUwZDYwLVxcdTBkNjFcXHUwZDY2LVxcdTBkNmZcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMi1cXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU1MC1cXHUwZTU5XFx1MGU4MS1cXHUwZTgyXFx1MGU4NFxcdTBlODctXFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhLVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyLVxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZDAtXFx1MGVkOVxcdTBlZGMtXFx1MGVkZFxcdTBmMDBcXHUwZjIwLVxcdTBmMjlcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGJcXHUxMDAwLVxcdTEwMmFcXHUxMDNmLVxcdTEwNDlcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NS1cXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwOTAtXFx1MTA5OVxcdTEwYTAtXFx1MTBjNVxcdTEwZDAtXFx1MTBmYVxcdTEwZmNcXHUxMTAwLVxcdTExNTlcXHUxMTVmLVxcdTExYTJcXHUxMWE4LVxcdTExZjlcXHUxMjAwLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3NlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTdlMC1cXHUxN2U5XFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE5MDAtXFx1MTkxY1xcdTE5NDYtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhOVxcdTE5YzEtXFx1MTljN1xcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNlxcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiODMtXFx1MWJhMFxcdTFiYWUtXFx1MWJiOVxcdTFjMDAtXFx1MWMyM1xcdTFjNDAtXFx1MWM0OVxcdTFjNGQtXFx1MWM3ZFxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5NFxcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTgzLVxcdTIxODRcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjNmZcXHUyYzcxLVxcdTJjN2RcXHUyYzgwLVxcdTJjZTRcXHUyZDAwLVxcdTJkMjVcXHUyZDMwLVxcdTJkNjVcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA2XFx1MzAzMS1cXHUzMDM1XFx1MzAzYi1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWI3XFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmMzXFx1YTAwMC1cXHVhNDhjXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjJiXFx1YTY0MC1cXHVhNjVmXFx1YTY2Mi1cXHVhNjZlXFx1YTY4MC1cXHVhNjk3XFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhjXFx1YTdmYi1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThkMC1cXHVhOGQ5XFx1YTkwMC1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE1MC1cXHVhYTU5XFx1YWMwMC1cXHVkN2EzXFx1ZjkwMC1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZhXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjEwLVxcdWZmMTlcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNdKikoOiguKz8pKT9cXF0vaWc7IH07XHJcbnZhciBtZXRhUGF0aFBhcnNlciA9IC9eKC4qXFwufCltZXRhKFxcLi4qfCkkLztcclxudmFyIEZvcm1hdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEZvcm1hdChtb2RlbCwgc3BlY2lmaWVyLCBkZXNjcmlwdGlvbiwgbnVsbFN0cmluZywgdW5kZWZpbmVkU3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uID09PSB2b2lkIDApIHsgZGVzY3JpcHRpb24gPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKG51bGxTdHJpbmcgPT09IHZvaWQgMCkgeyBudWxsU3RyaW5nID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICh1bmRlZmluZWRTdHJpbmcgPT09IHZvaWQgMCkgeyB1bmRlZmluZWRTdHJpbmcgPSB1bmRlZmluZWQ7IH1cclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xyXG4gICAgICAgICAgICBpZiAoIW1vZGVsIHx8ICEobW9kZWwgaW5zdGFuY2VvZiBtb2RlbF8xLk1vZGVsKSlcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIG11c3QgYmUgcHJvdmlkZWQuXCIpO1xyXG4gICAgICAgICAgICBpZiAoIXNwZWNpZmllciB8fCB0eXBlb2Ygc3BlY2lmaWVyICE9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9ybWF0IHNwZWNpZmllciBzdHJpbmcgbXVzdCBiZSBwcm92aWRlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcclxuICAgICAgICB0aGlzLnNwZWNpZmllciA9IHNwZWNpZmllcjtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XHJcbiAgICAgICAgdGhpcy5udWxsU3RyaW5nID0gbnVsbFN0cmluZyB8fCBcIlwiO1xyXG4gICAgICAgIHRoaXMudW5kZWZpbmVkU3RyaW5nID0gdW5kZWZpbmVkU3RyaW5nIHx8IFwiXCI7XHJcbiAgICB9XHJcbiAgICBGb3JtYXQucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuZGVmaW5lZFN0cmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udWxsU3RyaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgZm9ybWF0X2Vycm9yXzEuRm9ybWF0RXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbC5pbnZhbGlkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRUb1N0cmluZyh2YWwpO1xyXG4gICAgfTtcclxuICAgIEZvcm1hdC5wcm90b3R5cGUuY29udmVydEJhY2sgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIGlmICh0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHRoaXMubnVsbFN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0ID09PSB0aGlzLnVuZGVmaW5lZFN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50cmltKCk7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydEZyb21TdHJpbmcodGV4dCk7XHJcbiAgICB9O1xyXG4gICAgRm9ybWF0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zcGVjaWZpZXI7XHJcbiAgICB9O1xyXG4gICAgRm9ybWF0LmNyZWF0ZSA9IGZ1bmN0aW9uIChtb2RlbCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRm9ybWF0KG1vZGVsLCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBGb3JtYXQuZnJvbVRlbXBsYXRlID0gZnVuY3Rpb24gKHR5cGUsIHRlbXBsYXRlLCBmb3JtYXRFdmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNb2RlbEZvcm1hdCh0eXBlLCB0ZW1wbGF0ZSwgZm9ybWF0RXZhbCk7XHJcbiAgICB9O1xyXG4gICAgRm9ybWF0Lmhhc1Rva2VucyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLmdldEZvcm1hdFRlbXBsYXRlUGFyc2VyKCkudGVzdCh0ZW1wbGF0ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZvcm1hdDtcclxufSgpKTtcclxuZXhwb3J0cy5Gb3JtYXQgPSBGb3JtYXQ7XHJcbnZhciBDdXN0b21Gb3JtYXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ3VzdG9tRm9ybWF0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ3VzdG9tRm9ybWF0KG1vZGVsLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbW9kZWwsIG9wdGlvbnMuc3BlY2lmaWVyLCBvcHRpb25zLmRlc2NyaXB0aW9uLCBvcHRpb25zLm51bGxTdHJpbmcsIG9wdGlvbnMudW5kZWZpbmVkU3RyaW5nKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmN1c3RvbUNvbnZlcnQgPSBvcHRpb25zLmNvbnZlcnQ7XHJcbiAgICAgICAgX3RoaXMuY3VzdG9tQ29udmVydEJhY2sgPSBvcHRpb25zLmNvbnZlcnRCYWNrO1xyXG4gICAgICAgIF90aGlzLnBhdGhzID0gb3B0aW9ucy5wYXRocztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBDdXN0b21Gb3JtYXQucHJvdG90eXBlLmNvbnZlcnRUb1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY3VzdG9tQ29udmVydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21Db252ZXJ0KHZhbCk7XHJcbiAgICB9O1xyXG4gICAgQ3VzdG9tRm9ybWF0LnByb3RvdHlwZS5jb252ZXJ0RnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmN1c3RvbUNvbnZlcnRCYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21Db252ZXJ0QmFjayh0ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgZm9ybWF0X2Vycm9yXzEuRm9ybWF0RXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZvcm1hdEVycm9yID0gbmV3IGZvcm1hdF9lcnJvcl8xLkZvcm1hdEVycm9yKHRoaXMsIHRoaXMuZGVzY3JpcHRpb24gP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5nZXRSZXNvdXJjZShcImZvcm1hdC13aXRoLWRlc2NyaXB0aW9uXCIpLnJlcGxhY2UoXCJ7ZGVzY3JpcHRpb259XCIsIHRoaXMuZGVzY3JpcHRpb24pIDpcclxuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuZ2V0UmVzb3VyY2UoXCJmb3JtYXQtd2l0aG91dC1kZXNjcmlwdGlvblwiKSwgdGV4dCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRFcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEN1c3RvbUZvcm1hdDtcclxufShGb3JtYXQpKTtcclxuZXhwb3J0cy5DdXN0b21Gb3JtYXQgPSBDdXN0b21Gb3JtYXQ7XHJcbnZhciBNb2RlbEZvcm1hdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNb2RlbEZvcm1hdCwgX3N1cGVyKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxuICAgIGZ1bmN0aW9uIE1vZGVsRm9ybWF0KHR5cGUsIHNwZWNpZmllciwgZm9ybWF0RXZhbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHR5cGUubW9kZWwsIHNwZWNpZmllcikgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICBfdGhpcy5mb3JtYXRFdmFsID0gZm9ybWF0RXZhbDtcclxuICAgICAgICAvLyBDb21waWxlIHRoZSBtb2RlbCBmb3JtYXQgd2hlbiB0aGUgbW9kZWwgaXMgcmVhZHlcclxuICAgICAgICBfdGhpcy5tb2RlbC5yZWFkeShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jb21waWxlKCk7IH0sIHsgZW5xdWV1ZVdoaWxlUHJvY2Vzc2luZzogZmFsc2UgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTW9kZWxGb3JtYXQucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRva2Vucykge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGhzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudG9rZW5zID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUgPSB0aGlzLnNwZWNpZmllcjtcclxuICAgICAgICAgICAgLy8gUmVwbGFjZSBlc2NhcGVkIFxcLCBbIG9yIF0gY2hhcmFjdGVycyB3aXRoIHBsYWNlaG9sZGVyc1xyXG4gICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlLnJlcGxhY2UoL1xcXFxcXFxcL2csIFwiXFx1MDAwMFwiKS5yZXBsYWNlKC9cXFxcXFxbL2csIFwiXFx1MDAwMVwiKS5yZXBsYWNlKC9cXFxcXFxdL2csIFwiXFx1MDAwMlwiKTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgdmFyIGZvcm1hdFRlbXBsYXRlUGFyc2VyID0gZXhwb3J0cy5nZXRGb3JtYXRUZW1wbGF0ZVBhcnNlcigpO1xyXG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBmb3JtYXRUZW1wbGF0ZVBhcnNlci5leGVjKHRlbXBsYXRlKTtcclxuICAgICAgICAgICAgLy8gUHJvY2VzcyBlYWNoIHRva2VuIG1hdGNoXHJcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBtYXRjaFsxXTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eVBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgLy8gU2VlIGlmIHRoZSBwYXRoIHJlcHJlc2VudHMgYSBwcm9wZXJ0eSBwYXRoIGluIHRoZSBtb2RlbFxyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5RGVmYXVsdEZvcm1hdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIERldGVjdCBwcm9wZXJ0eSBwYXRoIGZvbGxvd2VkIGJ5IFwiLm1ldGEuLi5cIlxyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5UGF0aCA9IHByb3BlcnR5UGF0aC5yZXBsYWNlKG1ldGFQYXRoUGFyc2VyLCBcIiQxXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc01ldGFQYXRoID0gcHJvcGVydHlQYXRoLmxlbmd0aCA+IDAgJiYgcHJvcGVydHlQYXRoLmxlbmd0aCA8IHBhdGgubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxvd0Zvcm1hdCA9ICFpc01ldGFQYXRoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01ldGFQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5UGF0aCA9IHByb3BlcnR5UGF0aC5zdWJzdHJpbmcoMCwgcHJvcGVydHlQYXRoLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHByb3BlcnR5IHBhdGggcmVtYWlucywgdGhlbiBhdHRlbXB0IHRvIGZpbmQgYSBkZWZhdWx0IGZvcm1hdCBhbmQgcGF0aHMgZm9yIHRoZSBmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMudHlwZS5nZXRQYXRoKHByb3BlcnR5UGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhbGxvdyBmb3JtYXRzIGZvciBhIHByb3BlcnR5IHBhdGggdGhhdCBpcyBub3QgZm9sbG93ZWQgYnkgXCIubWV0YS4uLlwiXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGRlZmF1bHQgcHJvcGVydHkgZm9ybWF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgcHJvcGVydHlfMS5Qcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eURlZmF1bHRGb3JtYXQgPSBwcm9wZXJ0eS5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5IGluc3RhbmNlb2YgcHJvcGVydHlfY2hhaW5fMS5Qcm9wZXJ0eUNoYWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0UHJvcGVydHkgPSBwcm9wZXJ0eS5sYXN0UHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5RGVmYXVsdEZvcm1hdCA9IGxhc3RQcm9wZXJ0eS5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgdGFyZ2V0IGZvcm1hdCBpcyBjb21waWxlZCBzbyB3ZSBjYW4gY29sbGVjdCBpdHMgcGF0aHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlEZWZhdWx0Rm9ybWF0IGluc3RhbmNlb2YgTW9kZWxGb3JtYXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5RGVmYXVsdEZvcm1hdC5jb21waWxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhdGggcmVmZXJlbmNlcyBvbmUgb3IgbW9yZSBlbnRpdHkgcHJvcGVydGllcywgaW5jbHVkZSBwYXRocyBmb3IgdGhlIHByb3BlcnR5IGZvcm1hdC4gT3RoZXJ3aXNlLCBqdXN0IGFkZCB0aGUgcGF0aC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlEZWZhdWx0Rm9ybWF0ICYmIHByb3BlcnR5RGVmYXVsdEZvcm1hdCBpbnN0YW5jZW9mIEZvcm1hdCAmJiBwcm9wZXJ0eURlZmF1bHRGb3JtYXQgIT09IHRoaXMgJiYgcHJvcGVydHlEZWZhdWx0Rm9ybWF0LnBhdGhzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMucGF0aHMsIHByb3BlcnR5RGVmYXVsdEZvcm1hdC5wYXRocy5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIHByb3BlcnR5UGF0aCArIFwiLlwiICsgcDsgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRocy5wdXNoKHByb3BlcnR5UGF0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXRzIGFyZSBub3QgYWxsb3dlZCwgc28ganVzdCBhZGQgdGhlIHBhdGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGF0aHMucHVzaChwcm9wZXJ0eVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdG9rZW4gZm9yIHRoZSBjdXJyZW50IG1hdGNoLCBpbmNsdWRpbmcgdGhlIHByZWZpeCwgcGF0aCBhbmQgZm9ybWF0XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHRlbXBsYXRlLnN1YnN0cmluZyhpbmRleCwgZm9ybWF0VGVtcGxhdGVQYXJzZXIubGFzdEluZGV4IC0gbWF0Y2hbMF0ubGVuZ3RoKS5yZXBsYWNlKC9cXHUwMDAwL2csIFwiXFxcXFwiKS5yZXBsYWNlKC9cXHUwMDAxL2csIFwiW1wiKS5yZXBsYWNlKC9cXHUwMDAyL2csIFwiXVwiKSxcclxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogbWF0Y2hbM10gPyBtYXRjaFszXS5yZXBsYWNlKC9cXHUwMDAwL2csIFwiXFxcXFwiKS5yZXBsYWNlKC9cXHUwMDAxL2csIFwiW1wiKS5yZXBsYWNlKC9cXHUwMDAyL2csIFwiXVwiKSA6IHByb3BlcnR5RGVmYXVsdEZvcm1hdFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBUcmFjayB0aGUgbGFzdCBpbmRleCBhbmQgZmluZCB0aGUgbmV4dCBtYXRjaFxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXRUZW1wbGF0ZVBhcnNlci5sYXN0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGZvcm1hdFRlbXBsYXRlUGFyc2VyLmV4ZWModGVtcGxhdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYW55IHRyYWlsaW5nIGxpdGVyYWwgdGV4dCBhcyBhIHRva2VuIHdpdGhvdXQgYSBwYXRoXHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRlbXBsYXRlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4OiB0ZW1wbGF0ZS5zdWJzdHJpbmcoaW5kZXgpLnJlcGxhY2UoL1xcdTAwMDAvZywgXCJcXFxcXCIpLnJlcGxhY2UoL1xcdTAwMDEvZywgXCJbXCIpLnJlcGxhY2UoL1xcdTAwMDIvZywgXCJdXCIpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbEZvcm1hdC5wcm90b3R5cGUuY29udmVydFRvU3RyaW5nID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnZlcnRUb2tlbnMgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgX3RoaXMudG9rZW5zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gX3RoaXMudG9rZW5zW2luZGV4XTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5wcmVmaXgpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdG9rZW4ucHJlZml4O1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLnBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBoZWxwZXJzXzEuZXZhbFBhdGgob2JqLCB0b2tlbi5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLmZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0ID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4uZm9ybWF0IGluc3RhbmNlb2YgRm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSB0b2tlbi5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuLmZvcm1hdCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gdG9rZW4uZm9ybWF0ID0gb2JqLm1ldGEudHlwZS5tb2RlbC5nZXRGb3JtYXQodmFsdWUuY29uc3RydWN0b3IsIHRva2VuLmZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmb3JtYXQuY29udmVydCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5mb3JtYXRFdmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLmZvcm1hdEV2YWwodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5qb2luKFwiLCBcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpXHJcbiAgICAgICAgICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBjb252ZXJ0VG9rZW5zKGl0ZW0pOyB9KS5qb2luKFwiLCBcIik7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gY29udmVydFRva2VucyhvYmopO1xyXG4gICAgfTtcclxuICAgIE1vZGVsRm9ybWF0LnByb3RvdHlwZS5jb252ZXJ0RnJvbVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBmcm9tIGEgZm9ybWF0IHN0cmluZyBiYWNrIHRvIGFuIGVudGl0eS5cIik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vZGVsRm9ybWF0O1xyXG59KEZvcm1hdCkpO1xyXG5leHBvcnRzLk1vZGVsRm9ybWF0ID0gTW9kZWxGb3JtYXQ7XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdChtb2RlbCwgdHlwZSwgZm9ybWF0KSB7XHJcbiAgICBpZiAodHlwZSA9PT0gRGF0ZSkge1xyXG4gICAgICAgIC8vIEFkZCBzdXBwb3J0IGZvciBnIGFuZCBHIHRoYXQgYXJlIG5vdCBuYXRpdmVseSBzdXBwb3J0ZWQgYnkgdGhlIGZvcm1hdCBhbmQgcGFyc2UgbWV0aG9kc1xyXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwiZ1wiKVxyXG4gICAgICAgICAgICBmb3JtYXQgPSBnbG9iYWxpemF0aW9uXzEuZXhwYW5kRGF0ZUZvcm1hdChtb2RlbC4kY3VsdHVyZS5kYXRlVGltZUZvcm1hdCwgXCJkXCIpICsgXCIgXCIgKyBnbG9iYWxpemF0aW9uXzEuZXhwYW5kRGF0ZUZvcm1hdChtb2RlbC4kY3VsdHVyZS5kYXRlVGltZUZvcm1hdCwgXCJ0XCIpO1xyXG4gICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJHXCIpXHJcbiAgICAgICAgICAgIGZvcm1hdCA9IGdsb2JhbGl6YXRpb25fMS5leHBhbmREYXRlRm9ybWF0KG1vZGVsLiRjdWx0dXJlLmRhdGVUaW1lRm9ybWF0LCBcImRcIikgKyBcIiBcIiArIGdsb2JhbGl6YXRpb25fMS5leHBhbmREYXRlRm9ybWF0KG1vZGVsLiRjdWx0dXJlLmRhdGVUaW1lRm9ybWF0LCBcIlRcIik7XHJcbiAgICAgICAgcmV0dXJuIEZvcm1hdC5jcmVhdGUobW9kZWwsIHtcclxuICAgICAgICAgICAgc3BlY2lmaWVyOiBmb3JtYXQsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxyXG4gICAgICAgICAgICBwYXRoczogW10sXHJcbiAgICAgICAgICAgIGNvbnZlcnQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsb2JhbGl6YXRpb25fMS5mb3JtYXREYXRlKHZhbHVlLCBmb3JtYXQsIG1vZGVsLiRjdWx0dXJlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29udmVydEJhY2s6IGZ1bmN0aW9uIChzdHIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRlO1xyXG4gICAgICAgICAgICAgICAgLy8gVGltZSB2YWx1ZSwgc2V0IGRlZmF1bHQgZGF0ZSB0byAxLzEvMTk3MCB0byBlYXNpbHkgY29tcGFyZSB0aW1lIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJ0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZUZvcm1hdCA9IGdsb2JhbGl6YXRpb25fMS5leHBhbmREYXRlRm9ybWF0KG1vZGVsLiRjdWx0dXJlLmRhdGVUaW1lRm9ybWF0LCBcImRcIikgKyBcIiBcIiArIGdsb2JhbGl6YXRpb25fMS5leHBhbmREYXRlRm9ybWF0KG1vZGVsLiRjdWx0dXJlLmRhdGVUaW1lRm9ybWF0LCBcInRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0RGF0ZSA9IGdsb2JhbGl6YXRpb25fMS5mb3JtYXREYXRlKG5ldyBEYXRlKDE5NzAsIDAsIDEpLCBcImRcIiwgbW9kZWwuJGN1bHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBnbG9iYWxpemF0aW9uXzEucGFyc2VEYXRlKHN0YXJ0RGF0ZSArIFwiIFwiICsgc3RyLCBtb2RlbC4kY3VsdHVyZSwgW3RpbWVGb3JtYXRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gZ2xvYmFsaXphdGlvbl8xLnBhcnNlRGF0ZShzdHIsIG1vZGVsLiRjdWx0dXJlLCBbZm9ybWF0XSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgZm9ybWF0XCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xyXG4gICAgICAgIHZhciBpc0N1cnJlbmN5Rm9ybWF0ID0gZm9ybWF0Lm1hdGNoKC9bJGNdKy9pKTtcclxuICAgICAgICB2YXIgaXNQZXJjZW50YWdlRm9ybWF0ID0gZm9ybWF0Lm1hdGNoKC9bJXBdKy9pKTtcclxuICAgICAgICB2YXIgaXNJbnRlZ2VyRm9ybWF0ID0gZm9ybWF0Lm1hdGNoKC9bZG5mZ10wL2kpO1xyXG4gICAgICAgIHJldHVybiBGb3JtYXQuY3JlYXRlKG1vZGVsLCB7XHJcbiAgICAgICAgICAgIHNwZWNpZmllcjogZm9ybWF0LFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogaXNDdXJyZW5jeUZvcm1hdCA/IG1vZGVsLmdldFJlc291cmNlKFwiZm9ybWF0LWN1cnJlbmN5XCIpIDogaXNQZXJjZW50YWdlRm9ybWF0ID8gbW9kZWwuZ2V0UmVzb3VyY2UoXCJmb3JtYXQtcGVyY2VudGFnZVwiKSA6IGlzSW50ZWdlckZvcm1hdCA/IG1vZGVsLmdldFJlc291cmNlKFwiZm9ybWF0LWludGVnZXJcIikgOiBtb2RlbC5nZXRSZXNvdXJjZShcImZvcm1hdC1kZWNpbWFsXCIpLFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGJyb3dzZXIgZm9ybWF0dGluZyBmb3IgZ2VuZXJhbCBmb3JtYXRcclxuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gXCJnXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1c2UgdGhlIGxvY2FsaXplZCBmb3JtYXRcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbG9iYWxpemF0aW9uXzEuZm9ybWF0TnVtYmVyKHZhbCwgZm9ybWF0LCBtb2RlbC4kY3VsdHVyZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnZlcnRCYWNrOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2xvYmFsaXphdGlvbl8xLnBhcnNlTnVtYmVyKHN0ciwgZ2xvYmFsaXphdGlvbl8xLmdldE51bWJlclN0eWxlKGZvcm1hdCksIG1vZGVsLiRjdWx0dXJlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc05hTihyZXN1bHQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZm9ybWF0XCIpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZSA9PT0gQm9vbGVhbikge1xyXG4gICAgICAgIC8vIEZvcm1hdCBzdHJpbmdzIHVzZWQgZm9yIHRydWUsIGZhbHNlLCBhbmQgbnVsbCAob3IgdW5kZWZpbmVkKSB2YWx1ZXNcclxuICAgICAgICB2YXIgdHJ1ZUZvcm1hdF8xLCBmYWxzZUZvcm1hdF8xLCBudWxsRm9ybWF0XzE7XHJcbiAgICAgICAgaWYgKGZvcm1hdCAmJiBmb3JtYXQudG9Mb3dlckNhc2UoKSA9PT0gXCJnXCIpIHtcclxuICAgICAgICAgICAgdHJ1ZUZvcm1hdF8xID0gXCJUcnVlXCI7XHJcbiAgICAgICAgICAgIGZhbHNlRm9ybWF0XzEgPSBcIkZhbHNlXCI7XHJcbiAgICAgICAgICAgIG51bGxGb3JtYXRfMSA9IFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0cyA9IGZvcm1hdC5zcGxpdChcIjtcIik7XHJcbiAgICAgICAgICAgIHRydWVGb3JtYXRfMSA9IGZvcm1hdHMubGVuZ3RoID4gMCA/IGZvcm1hdHNbMF0gOiBcIlwiO1xyXG4gICAgICAgICAgICBmYWxzZUZvcm1hdF8xID0gZm9ybWF0cy5sZW5ndGggPiAxID8gZm9ybWF0c1sxXSA6IFwiXCI7XHJcbiAgICAgICAgICAgIG51bGxGb3JtYXRfMSA9IGZvcm1hdHMubGVuZ3RoID4gMiA/IGZvcm1hdHNbMl0gOiBcIlwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBzdHJpbmcgbWF0Y2hlcyB0aGUgZ2l2ZW4gZm9ybWF0IG9wdGlvblxyXG4gICAgICAgICAqIEBwYXJhbSBzdHIgVGhlIHRleHQgdG8gY2hlY2tcclxuICAgICAgICAgKiBAcGFyYW0gZm9ybWF0VmFsdWUgVGhlIHRydWUgb3IgZmFsc2UgZm9ybWF0IG9wdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHZhciBpc0Zvcm1hdE1hdGNoXzEgPSBmdW5jdGlvbiAoc3RyLCBmb3JtYXRWYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyLnRyaW0oKS50b0xvd2VyQ2FzZSgpID09PSBmb3JtYXRWYWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBGb3JtYXQuY3JlYXRlKG1vZGVsLCB7XHJcbiAgICAgICAgICAgIHNwZWNpZmllcjogZm9ybWF0LFxyXG4gICAgICAgICAgICBjb252ZXJ0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVGb3JtYXRfMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VGb3JtYXRfMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsRm9ybWF0XzE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnZlcnRCYWNrOiBmdW5jdGlvbiAoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNGb3JtYXRNYXRjaF8xKHN0ciwgdHJ1ZUZvcm1hdF8xKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRm9ybWF0TWF0Y2hfMShzdHIsIGZhbHNlRm9ybWF0XzEpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJXQVJOOiBVbmFibGUgdG8gY3JlYXRlIGZvcm1hdCBmb3IgdHlwZSAnXCIgKyBoZWxwZXJzXzEuZ2V0Q29uc3RydWN0b3JOYW1lKHR5cGUpICsgXCInLlwiKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNyZWF0ZUZvcm1hdCA9IGNyZWF0ZUZvcm1hdDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5GdW5jdG9yJGNsZWFyID0gZXhwb3J0cy5GdW5jdG9yJGlzRW1wdHkgPSBleHBvcnRzLkZ1bmN0b3IkcmVtb3ZlID0gZXhwb3J0cy5GdW5jdG9yJGFkZCA9IGV4cG9ydHMuRnVuY3Rvckl0ZW0kbmV3ID0gZXhwb3J0cy5GdW5jdG9yJGNyZWF0ZSA9IHZvaWQgMDtcclxuZnVuY3Rpb24gRnVuY3RvciRjcmVhdGUocmV0dXJucykge1xyXG4gICAgaWYgKHJldHVybnMgPT09IHZvaWQgMCkgeyByZXR1cm5zID0gZmFsc2U7IH1cclxuICAgIHZhciBmdW5jcyA9IFtdO1xyXG4gICAgLy8gVE9ETzogRGV0ZWN0IGZ1bmN0b3IgaW52b2NhdGlvbiByZXN1bHRpbmcgaW4gY29udGludWFsbHkgYWRkaW5nIHN1YnNjcmliZXJzXHJcbiAgICBmdW5jdGlvbiBGdW5jdG9yJGZuKCkge1xyXG4gICAgICAgIHZhciByZXR1cm5zQXJyYXk7XHJcbiAgICAgICAgaWYgKHJldHVybnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuc0FycmF5ID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnVuY3MubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBmdW5jc1tpXTtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgcmUtcnVuIG9uZS10aW1lIHN1YnNjcmlwdGlvbnMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhcHBsaWVkLlxyXG4gICAgICAgICAgICBpZiAoaXRlbS5hcHBsaWVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBlaXRoZXIgbm8gZmlsdGVyIG9yIHRoZSBmaWx0ZXIgcGFzc2VzLlxyXG4gICAgICAgICAgICBpZiAoIWl0ZW0uZmlsdGVyIHx8IGl0ZW0uZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIGhhbmRsZXIgaXMgc2V0IHRvIGV4ZWN1dGUgb25jZSxcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgaGFuZGxlciBiZWZvcmUgY2FsbGluZy5cclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLm9uY2UgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXJrIGFzIGFwcGxpZWQgYnV0IGxlYXZlIGl0ZW0gaW4gYXJyYXkgdG8gYXZvaWQgcG90ZW50aWFsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvYmxlbXMgZHVlIHRvIHJlLWVudHJ5IGludG8gZXZlbnQgaW52YWxpZGF0aW5nIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGV4LiBJbiBzb21lIGNhc2VzIHJlLWVudHJ5IHdvdWxkIGJlIGEgcmVkLWZsYWcsIGJ1dCBmb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyBcImdsb2JhbFwiIGV2ZW50cywgd2hlcmUgdGhlIGNvbnRleHQgb2YgdGhlIGV2ZW50IGlzIGRlcml2ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBhcmd1bWVudHMsIHRoZSBldmVudCBjb3VsZCBlYXNpbHkgYmUgcmUtZW50ZXJlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGEgZGlmZmVyZW50IGNvbnRleHQgd2l0aCBkaWZmZXJlbnQgYXJndW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uYXBwbGllZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBoYW5kbGVyIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblZhbHVlID0gaXRlbS5mbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJldHVybnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm5zQXJyYXkucHVzaChyZXR1cm5WYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJldHVybnMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJldHVybnNBcnJheTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICB2YXIgZiA9IEZ1bmN0b3IkZm47XHJcbiAgICBmLl9mdW5jcyA9IGZ1bmNzO1xyXG4gICAgZi5hZGQgPSBGdW5jdG9yJGFkZDtcclxuICAgIGYucmVtb3ZlID0gRnVuY3RvciRyZW1vdmU7XHJcbiAgICBmLmlzRW1wdHkgPSBGdW5jdG9yJGlzRW1wdHk7XHJcbiAgICBmLmNsZWFyID0gRnVuY3RvciRjbGVhcjtcclxuICAgIHJldHVybiBmO1xyXG59XHJcbmV4cG9ydHMuRnVuY3RvciRjcmVhdGUgPSBGdW5jdG9yJGNyZWF0ZTtcclxuZnVuY3Rpb24gRnVuY3Rvckl0ZW0kbmV3KGZuLCBmaWx0ZXIsIG9uY2UpIHtcclxuICAgIGlmIChmaWx0ZXIgPT09IHZvaWQgMCkgeyBmaWx0ZXIgPSBudWxsOyB9XHJcbiAgICBpZiAob25jZSA9PT0gdm9pZCAwKSB7IG9uY2UgPSBmYWxzZTsgfVxyXG4gICAgdmFyIGl0ZW0gPSB7IGZuOiBmbiB9O1xyXG4gICAgaWYgKGZpbHRlciAhPSBudWxsKSB7XHJcbiAgICAgICAgaXRlbS5maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICB9XHJcbiAgICBpZiAob25jZSAhPSBudWxsKSB7XHJcbiAgICAgICAgaXRlbS5vbmNlID0gb25jZTtcclxuICAgIH1cclxuICAgIHJldHVybiBpdGVtO1xyXG59XHJcbmV4cG9ydHMuRnVuY3Rvckl0ZW0kbmV3ID0gRnVuY3Rvckl0ZW0kbmV3O1xyXG5mdW5jdGlvbiBGdW5jdG9yJGFkZChmbiwgZmlsdGVyLCBvbmNlKSB7XHJcbiAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0gbnVsbDsgfVxyXG4gICAgaWYgKG9uY2UgPT09IHZvaWQgMCkgeyBvbmNlID0gZmFsc2U7IH1cclxuICAgIHZhciBpdGVtID0gRnVuY3Rvckl0ZW0kbmV3KGZuLCBmaWx0ZXIsIG9uY2UpO1xyXG4gICAgdGhpcy5fZnVuY3MucHVzaChpdGVtKTtcclxufVxyXG5leHBvcnRzLkZ1bmN0b3IkYWRkID0gRnVuY3RvciRhZGQ7XHJcbmZ1bmN0aW9uIEZ1bmN0b3IkcmVtb3ZlKGZuKSB7XHJcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICBpZiAodGhpcy5fZnVuY3NbaV0uZm4gPT09IGZuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Z1bmNzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuRnVuY3RvciRyZW1vdmUgPSBGdW5jdG9yJHJlbW92ZTtcclxuZnVuY3Rpb24gRnVuY3RvciRpc0VtcHR5KGFyZ3MpIHtcclxuICAgIGlmIChhcmdzID09PSB2b2lkIDApIHsgYXJncyA9IG51bGw7IH1cclxuICAgIHJldHVybiAhdGhpcy5fZnVuY3Muc29tZShmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5hcHBsaWVkICE9PSB0cnVlICYmICghYXJncyB8fCAhaXRlbS5maWx0ZXIgfHwgaXRlbS5maWx0ZXIuYXBwbHkodGhpcywgYXJncykpOyB9LCB0aGlzKTtcclxufVxyXG5leHBvcnRzLkZ1bmN0b3IkaXNFbXB0eSA9IEZ1bmN0b3IkaXNFbXB0eTtcclxuZnVuY3Rpb24gRnVuY3RvciRjbGVhcigpIHtcclxuICAgIHRoaXMuX2Z1bmNzLmxlbmd0aCA9IDA7XHJcbn1cclxuZXhwb3J0cy5GdW5jdG9yJGNsZWFyID0gRnVuY3RvciRjbGVhcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIVxyXG4gKiBCYXNlZCBvbiBwb3J0aW9ucyBvZiBNaWNyb3NvZnRBamF4LmRlYnVnLmpzICh2My4wLjMxMTA2LjEpIGZyb20gU3lzdGVtLldlYi5FeHRlbnNpb25zLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DdWx0dXJlSW5mbyA9IGV4cG9ydHMuZm9ybWF0TnVtYmVyID0gZXhwb3J0cy5fcGFyc2VOdW1iZXIgPSBleHBvcnRzLnBhcnNlTnVtYmVyID0gZXhwb3J0cy5nZXROdW1iZXJTdHlsZSA9IGV4cG9ydHMuZm9ybWF0RGF0ZSA9IGV4cG9ydHMucGFyc2VEYXRlID0gZXhwb3J0cy5leHBhbmREYXRlRm9ybWF0ID0gdm9pZCAwO1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxuLyoqXHJcbiAqIEludGVybmFsbHkgdXNlZCByZXNvdXJjZSBzdHJpbmdzXHJcbiAqIFRPRE86IE1ha2UgdGhlc2UgbG9jYWxpemFibGUgcmVzb3VyY2VzP1xyXG4gKi9cclxudmFyIFJlcyA9IHtcclxuICAgIFwiZm9ybWF0XCI6IFwiT25lIG9mIHRoZSBpZGVudGlmaWVkIGl0ZW1zIHdhcyBpbiBhbiBpbnZhbGlkIGZvcm1hdC5cIixcclxuICAgIFwiZm9ybWF0QmFkRm9ybWF0U3BlY2lmaWVyXCI6IFwiRm9ybWF0IHNwZWNpZmllciB3YXMgaW52YWxpZC5cIixcclxuICAgIFwiZm9ybWF0SW52YWxpZFN0cmluZ1wiOiBcIklucHV0IHN0cmluZyB3YXMgbm90IGluIGEgY29ycmVjdCBmb3JtYXQuXCJcclxufTtcclxuLyoqXHJcbiAqIEEgY2xhc3MgZm9yIGJ1aWxkaW5nIGEgc3RyaW5nIHByb2dyYW1tYXRpY2FsbHlcclxuICovXHJcbnZhciBTdHJpbmdCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nQnVpbGRlcihpbml0aWFsVGV4dCkge1xyXG4gICAgICAgIHRoaXMuX3BhcnRzID0gKHR5cGVvZiAoaW5pdGlhbFRleHQpICE9PSBcInVuZGVmaW5lZFwiICYmIGluaXRpYWxUZXh0ICE9PSBudWxsICYmIGluaXRpYWxUZXh0ICE9PSBcIlwiKSA/IFtpbml0aWFsVGV4dC50b1N0cmluZygpXSA6IFtdO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0ge307XHJcbiAgICAgICAgdGhpcy5fbGVuID0gMDtcclxuICAgIH1cclxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uICh0ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fcGFydHMucHVzaCh0ZXh0KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRMaW5lID0gZnVuY3Rpb24gKHRleHQpIHtcclxuICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKCgodHlwZW9mICh0ZXh0KSA9PT0gXCJ1bmRlZmluZWRcIikgfHwgKHRleHQgPT09IG51bGwpIHx8ICh0ZXh0ID09PSBcIlwiKSkgPyBcIlxcclxcblwiIDogKHRleHQgKyBcIlxcclxcblwiKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFydHMgPSBbXTtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2xlbiA9IDA7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGFydHMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpID09PSBcIlwiO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNlcGFyYXRvcikge1xyXG4gICAgICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCBcIlwiO1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMuX3BhcnRzO1xyXG4gICAgICAgIGlmICh0aGlzLl9sZW4gIT09IHBhcnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLl9sZW4gPSBwYXJ0cy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLl92YWx1ZTtcclxuICAgICAgICBpZiAodHlwZW9mICh2YWxbc2VwYXJhdG9yXSkgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0eXBlb2YgKHBhcnRzW2ldKSA9PT0gXCJ1bmRlZmluZWRcIikgfHwgKHBhcnRzW2ldID09PSBcIlwiKSB8fCAocGFydHNbaV0gPT09IG51bGwpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFsW3NlcGFyYXRvcl0gPSB0aGlzLl9wYXJ0cy5qb2luKHNlcGFyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWxbc2VwYXJhdG9yXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RyaW5nQnVpbGRlcjtcclxufSgpKTtcclxuLyoqXHJcbiAqIFN1YmNsYXNzIG9mIGVycm9yIGZvciBpbnZhbGlkIGZvcm1hdCBzdHJpbmdzXHJcbiAqL1xyXG52YXIgRm9ybWF0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRm9ybWF0RXJyb3IsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGb3JtYXRFcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZGlzcGxheU1lc3NhZ2UgPSBcIlN5cy5Gb3JtYXRFeGNlcHRpb246IFwiICsgKG1lc3NhZ2UgfHwgUmVzLmZvcm1hdCk7XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkaXNwbGF5TWVzc2FnZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5uYW1lID0gXCJTeXMuRm9ybWF0RXhjZXB0aW9uXCI7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEZvcm1hdEVycm9yO1xyXG59KEVycm9yKSk7XHJcbmZ1bmN0aW9uIGRhdGUkYXBwZW5kUHJlT3JQb3N0TWF0Y2gocHJlTWF0Y2gsIHN0ckJ1aWxkZXIpIHtcclxuICAgIHZhciBxdW90ZUNvdW50ID0gMDtcclxuICAgIHZhciBlc2NhcGVkID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwcmVNYXRjaC5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGMgPSBwcmVNYXRjaC5jaGFyQXQoaSk7XHJcbiAgICAgICAgc3dpdGNoIChjKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCInXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZClcclxuICAgICAgICAgICAgICAgICAgICBzdHJCdWlsZGVyLmFwcGVuZChcIidcIik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcXVvdGVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XHJcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZClcclxuICAgICAgICAgICAgICAgICAgICBzdHJCdWlsZGVyLmFwcGVuZChcIlxcXFxcIik7XHJcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gIWVzY2FwZWQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHN0ckJ1aWxkZXIuYXBwZW5kKGMpO1xyXG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHF1b3RlQ291bnQ7XHJcbn1cclxuZnVuY3Rpb24gZXhwYW5kRGF0ZUZvcm1hdChkdGYsIGZvcm1hdCkge1xyXG4gICAgaWYgKCFmb3JtYXQpIHtcclxuICAgICAgICBmb3JtYXQgPSBcIkZcIjtcclxuICAgIH1cclxuICAgIHZhciBsZW4gPSBmb3JtYXQubGVuZ3RoO1xyXG4gICAgaWYgKGxlbiA9PT0gMSkge1xyXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHRmW1wiU2hvcnREYXRlUGF0dGVyblwiXTtcclxuICAgICAgICAgICAgY2FzZSBcIkRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkdGZbXCJMb25nRGF0ZVBhdHRlcm5cIl07XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHRmW1wiU2hvcnRUaW1lUGF0dGVyblwiXTtcclxuICAgICAgICAgICAgY2FzZSBcIlRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkdGZbXCJMb25nVGltZVBhdHRlcm5cIl07XHJcbiAgICAgICAgICAgIGNhc2UgXCJmXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHRmW1wiTG9uZ0RhdGVQYXR0ZXJuXCJdICsgXCIgXCIgKyBkdGZbXCJTaG9ydFRpbWVQYXR0ZXJuXCJdO1xyXG4gICAgICAgICAgICBjYXNlIFwiRlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR0ZltcIkZ1bGxEYXRlVGltZVBhdHRlcm5cIl07XHJcbiAgICAgICAgICAgIGNhc2UgXCJnXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHRmW1wiU2hvcnREYXRlUGF0dGVyblwiXSArIFwiIFwiICsgZHRmW1wiU2hvcnRUaW1lUGF0dGVyblwiXTtcclxuICAgICAgICAgICAgY2FzZSBcIkdcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBkdGZbXCJTaG9ydERhdGVQYXR0ZXJuXCJdICsgXCIgXCIgKyBkdGZbXCJMb25nVGltZVBhdHRlcm5cIl07XHJcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZHRmW1wiTW9udGhEYXlQYXR0ZXJuXCJdO1xyXG4gICAgICAgICAgICBjYXNlIFwic1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR0ZltcIlNvcnRhYmxlRGF0ZVRpbWVQYXR0ZXJuXCJdO1xyXG4gICAgICAgICAgICBjYXNlIFwiWVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwieVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGR0ZltcIlllYXJNb250aFBhdHRlcm5cIl07XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoUmVzLmZvcm1hdEludmFsaWRTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKChsZW4gPT09IDIpICYmIChmb3JtYXQuY2hhckF0KDApID09PSBcIiVcIikpIHtcclxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQuY2hhckF0KDEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxufVxyXG5leHBvcnRzLmV4cGFuZERhdGVGb3JtYXQgPSBleHBhbmREYXRlRm9ybWF0O1xyXG5mdW5jdGlvbiBleHBhbmRZZWFyKGR0ZiwgeWVhcikge1xyXG4gICAgdmFyIG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICB2YXIgZXJhID0gZ2V0RXJhKG5vdyk7XHJcbiAgICBpZiAoeWVhciA8IDEwMCkge1xyXG4gICAgICAgIHZhciBjdXJyID0gZ2V0RXJhWWVhcihub3csIGR0ZiwgZXJhKTtcclxuICAgICAgICB5ZWFyICs9IGN1cnIgLSAoY3VyciAlIDEwMCk7XHJcbiAgICAgICAgaWYgKHllYXIgPiBkdGYuQ2FsZW5kYXIuVHdvRGlnaXRZZWFyTWF4KSB7XHJcbiAgICAgICAgICAgIHllYXIgLT0gMTAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB5ZWFyO1xyXG59XHJcbmZ1bmN0aW9uIGdldEVyYShkYXRlLCBlcmFzKSB7XHJcbiAgICBpZiAoIWVyYXMpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgc3RhcnQ7XHJcbiAgICB2YXIgdGlja3MgPSBkYXRlLmdldFRpbWUoKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcclxuICAgICAgICBzdGFydCA9IGVyYXNbaSArIDJdO1xyXG4gICAgICAgIGlmICgoc3RhcnQgPT09IG51bGwpIHx8ICh0aWNrcyA+PSBzdGFydCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZnVuY3Rpb24gZ2V0RXJhWWVhcihkYXRlLCBkdGYsIGVyYSwgc29ydGFibGUpIHtcclxuICAgIHZhciB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xyXG4gICAgaWYgKCFzb3J0YWJsZSAmJiBkdGYuRXJhcykge1xyXG4gICAgICAgIHllYXIgLT0gZHRmLkVyYXNbZXJhICsgM107XHJcbiAgICB9XHJcbiAgICByZXR1cm4geWVhcjtcclxufVxyXG5mdW5jdGlvbiBnZXREYXRlUGFyc2VSZWdFeHAoZHRmLCBmb3JtYXQpIHtcclxuICAgIC8vIEdldCBvciBpbml0aWFsaXplIHRoZSByZWdleCBjYWNoZVxyXG4gICAgdmFyIGNhY2hlO1xyXG4gICAgaWYgKCEoY2FjaGUgPSBkdGYuX3BhcnNlUmVnRXhwKSkge1xyXG4gICAgICAgIGNhY2hlID0gZHRmLl9wYXJzZVJlZ0V4cCA9IHt9O1xyXG4gICAgfVxyXG4gICAgLy8gUmV0dXJuIGEgY2FjaGVkIGZvcm1hdCBpZiBhdmFpbGFibGVcclxuICAgIGlmIChjYWNoZVtmb3JtYXRdKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlW2Zvcm1hdF07XHJcbiAgICB9XHJcbiAgICB2YXIgZXhwRm9ybWF0ID0gZXhwYW5kRGF0ZUZvcm1hdChkdGYsIGZvcm1hdCk7XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcclxuICAgIGV4cEZvcm1hdCA9IGV4cEZvcm1hdC5yZXBsYWNlKC8oW1xcXlxcJFxcLlxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxce1xcfV0pL2csIFwiXFxcXFxcXFwkMVwiKTtcclxuICAgIHZhciByZWdleHAgPSBuZXcgU3RyaW5nQnVpbGRlcihcIl5cIik7XHJcbiAgICB2YXIgZ3JvdXBzID0gW107XHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgdmFyIHF1b3RlQ291bnQgPSAwO1xyXG4gICAgdmFyIHRva2VuUmVnRXhwID0gZ2V0RGF0ZVRva2VuUmVnRXhwKCk7XHJcbiAgICB2YXIgbWF0Y2g7XHJcbiAgICB3aGlsZSAoKG1hdGNoID0gdG9rZW5SZWdFeHAuZXhlYyhleHBGb3JtYXQpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHZhciBwcmVNYXRjaCA9IGV4cEZvcm1hdC5zbGljZShpbmRleCwgbWF0Y2guaW5kZXgpO1xyXG4gICAgICAgIGluZGV4ID0gdG9rZW5SZWdFeHAubGFzdEluZGV4O1xyXG4gICAgICAgIHF1b3RlQ291bnQgKz0gZGF0ZSRhcHBlbmRQcmVPclBvc3RNYXRjaChwcmVNYXRjaCwgcmVnZXhwKTtcclxuICAgICAgICBpZiAoKHF1b3RlQ291bnQgJSAyKSA9PT0gMSkge1xyXG4gICAgICAgICAgICByZWdleHAuYXBwZW5kKG1hdGNoWzBdKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN3aXRjaCAobWF0Y2hbMF0pIHtcclxuICAgICAgICAgICAgY2FzZSBcImRkZGRcIjpcclxuICAgICAgICAgICAgY2FzZSBcImRkZFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiTU1NTVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiTU1NXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZ1wiOlxyXG4gICAgICAgICAgICBjYXNlIFwiZ1wiOlxyXG4gICAgICAgICAgICAgICAgcmVnZXhwLmFwcGVuZChcIihcXFxcRCspXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ0dFwiOlxyXG4gICAgICAgICAgICBjYXNlIFwidFwiOlxyXG4gICAgICAgICAgICAgICAgcmVnZXhwLmFwcGVuZChcIihcXFxcRCopXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XHJcbiAgICAgICAgICAgICAgICByZWdleHAuYXBwZW5kKFwiKFxcXFxkezR9KVwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZmZmXCI6XHJcbiAgICAgICAgICAgICAgICByZWdleHAuYXBwZW5kKFwiKFxcXFxkezN9KVwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZmZcIjpcclxuICAgICAgICAgICAgICAgIHJlZ2V4cC5hcHBlbmQoXCIoXFxcXGR7Mn0pXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmXCI6XHJcbiAgICAgICAgICAgICAgICByZWdleHAuYXBwZW5kKFwiKFxcXFxkKVwiKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZGRcIjpcclxuICAgICAgICAgICAgY2FzZSBcImRcIjpcclxuICAgICAgICAgICAgY2FzZSBcIk1NXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ5eVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwieVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwiSEhcIjpcclxuICAgICAgICAgICAgY2FzZSBcIkhcIjpcclxuICAgICAgICAgICAgY2FzZSBcImhoXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJtbVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwibVwiOlxyXG4gICAgICAgICAgICBjYXNlIFwic3NcIjpcclxuICAgICAgICAgICAgY2FzZSBcInNcIjpcclxuICAgICAgICAgICAgICAgIHJlZ2V4cC5hcHBlbmQoXCIoXFxcXGRcXFxcZD8pXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ6enpcIjpcclxuICAgICAgICAgICAgICAgIHJlZ2V4cC5hcHBlbmQoXCIoWystXT9cXFxcZFxcXFxkPzpcXFxcZHsyfSlcIik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInp6XCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJ6XCI6XHJcbiAgICAgICAgICAgICAgICByZWdleHAuYXBwZW5kKFwiKFsrLV0/XFxcXGRcXFxcZD8pXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCIvXCI6XHJcbiAgICAgICAgICAgICAgICByZWdleHAuYXBwZW5kKFwiKFxcXFxcIiArIGR0Zi5EYXRlU2VwYXJhdG9yICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyb3Vwcy5wdXNoKG1hdGNoWzBdKTtcclxuICAgIH1cclxuICAgIGRhdGUkYXBwZW5kUHJlT3JQb3N0TWF0Y2goZXhwRm9ybWF0LnNsaWNlKGluZGV4KSwgcmVnZXhwKTtcclxuICAgIHJlZ2V4cC5hcHBlbmQoXCIkXCIpO1xyXG4gICAgdmFyIHJlZ2V4cFN0ciA9IHJlZ2V4cC50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgXCJcXFxccytcIik7XHJcbiAgICB2YXIgcGFyc2VSZWdFeHAgPSB7IHJlZ0V4cDogcmVnZXhwU3RyLCBncm91cHM6IGdyb3VwcyB9O1xyXG4gICAgY2FjaGVbZm9ybWF0XSA9IHBhcnNlUmVnRXhwO1xyXG4gICAgcmV0dXJuIHBhcnNlUmVnRXhwO1xyXG59XHJcbjtcclxuZnVuY3Rpb24gZ2V0RGF0ZVRva2VuUmVnRXhwKCkge1xyXG4gICAgcmV0dXJuIC9cXC98ZGRkZHxkZGR8ZGR8ZHxNTU1NfE1NTXxNTXxNfHl5eXl8eXl8eXxoaHxofEhIfEh8bW18bXxzc3xzfHR0fHR8ZmZmfGZmfGZ8enp6fHp6fHp8Z2d8Zy9nO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYXMgYSBkYXRlXHJcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdGV4dCB0byBwYXJzZVxyXG4gKiBAcGFyYW0gY3VsdHVyZUluZm8gVGhlIGN1bHR1cmVcclxuICogQHBhcmFtIGZvcm1hdHMgQW4gb3B0aW9uYWwgbGlzdCBvZiBmb3JtYXRzIHRvIHVzZVxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VEYXRlKHZhbHVlLCBjdWx0dXJlSW5mbywgZm9ybWF0cykge1xyXG4gICAgdmFyIGZvcm1hdHNTcGVjaWZpZWQgPSBmYWxzZTtcclxuICAgIC8vIFRyeSB0byBwYXJzZSB1c2luZyBmb3JtYXQgc3RyaW5ncyBpZiBzcGVjaWZpZWRcclxuICAgIGlmIChmb3JtYXRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JtYXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSBmb3JtYXRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXRzU3BlY2lmaWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gcGFyc2VEYXRlRXhhY3QodmFsdWUsIGZvcm1hdCwgY3VsdHVyZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBVc2UgdGhlIGN1bHR1cmUncyBkYXRlL3RpbWUgZm9ybWF0cyBpZiBmb3JtYXRzIHdlcmUgbm90IHNwZWNpZmllZFxyXG4gICAgaWYgKCFmb3JtYXRzU3BlY2lmaWVkKSB7XHJcbiAgICAgICAgZm9ybWF0cyA9IGN1bHR1cmVJbmZvLl9nZXREYXRlVGltZUZvcm1hdHMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSBwYXJzZURhdGVFeGFjdCh2YWx1ZSwgZm9ybWF0c1tpXSwgY3VsdHVyZUluZm8pO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmV4cG9ydHMucGFyc2VEYXRlID0gcGFyc2VEYXRlO1xyXG5mdW5jdGlvbiBwYXJzZURhdGVFeGFjdCh2YWx1ZSwgZm9ybWF0LCBjdWx0dXJlSW5mbykge1xyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XHJcbiAgICB2YXIgZHRmID0gY3VsdHVyZUluZm8uZGF0ZVRpbWVGb3JtYXQ7XHJcbiAgICB2YXIgcGFyc2VJbmZvID0gZ2V0RGF0ZVBhcnNlUmVnRXhwKGR0ZiwgZm9ybWF0KTtcclxuICAgIHZhciBtYXRjaCA9IG5ldyBSZWdFeHAocGFyc2VJbmZvLnJlZ0V4cCkuZXhlYyh2YWx1ZSk7XHJcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB2YXIgZ3JvdXBzID0gcGFyc2VJbmZvLmdyb3VwcztcclxuICAgIHZhciBlcmEgPSBudWxsO1xyXG4gICAgdmFyIHllYXIgPSBudWxsO1xyXG4gICAgdmFyIG1vbnRoID0gbnVsbDtcclxuICAgIHZhciBkYXRlID0gbnVsbDtcclxuICAgIHZhciB3ZWVrRGF5ID0gbnVsbDtcclxuICAgIHZhciBob3VyID0gMDtcclxuICAgIHZhciBob3VyT2Zmc2V0O1xyXG4gICAgdmFyIG1pbiA9IDA7XHJcbiAgICB2YXIgc2VjID0gMDtcclxuICAgIHZhciBtc2VjID0gMDtcclxuICAgIHZhciB0ek1pbk9mZnNldCA9IG51bGw7XHJcbiAgICB2YXIgcG1Ib3VyID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7IGorKykge1xyXG4gICAgICAgIHZhciBtYXRjaEdyb3VwID0gbWF0Y2hbaiArIDFdO1xyXG4gICAgICAgIGlmIChtYXRjaEdyb3VwKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZ3JvdXBzW2pdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IHBhcnNlSW50KG1hdGNoR3JvdXAsIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGUgPCAxKSB8fCAoZGF0ZSA+IDMxKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiTU1NTVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoID0gY3VsdHVyZUluZm8uX2dldE1vbnRoSW5kZXgobWF0Y2hHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChtb250aCA8IDApIHx8IChtb250aCA+IDExKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiTU1NXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9udGggPSBjdWx0dXJlSW5mby5fZ2V0TW9udGhJbmRleChtYXRjaEdyb3VwLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG1vbnRoIDwgMCkgfHwgKG1vbnRoID4gMTEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiTU1cIjpcclxuICAgICAgICAgICAgICAgICAgICBtb250aCA9IHBhcnNlSW50KG1hdGNoR3JvdXAsIDEwKSAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChtb250aCA8IDApIHx8IChtb250aCA+IDExKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwieVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInl5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgeWVhciA9IGV4cGFuZFllYXIoZHRmLCBwYXJzZUludChtYXRjaEdyb3VwLCAxMCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoeWVhciA8IDApIHx8ICh5ZWFyID4gOTk5OSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInl5eXlcIjpcclxuICAgICAgICAgICAgICAgICAgICB5ZWFyID0gcGFyc2VJbnQobWF0Y2hHcm91cCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoeWVhciA8IDApIHx8ICh5ZWFyID4gOTk5OSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImhcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJoaFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGhvdXIgPSBwYXJzZUludChtYXRjaEdyb3VwLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhvdXIgPT09IDEyKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3VyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGhvdXIgPCAwKSB8fCAoaG91ciA+IDExKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiSFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkhIXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgaG91ciA9IHBhcnNlSW50KG1hdGNoR3JvdXAsIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGhvdXIgPCAwKSB8fCAoaG91ciA+IDIzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1tXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWluID0gcGFyc2VJbnQobWF0Y2hHcm91cCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobWluIDwgMCkgfHwgKG1pbiA+IDU5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic1wiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcInNzXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgc2VjID0gcGFyc2VJbnQobWF0Y2hHcm91cCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2VjIDwgMCkgfHwgKHNlYyA+IDU5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidHRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwcGVyVG9rZW4gPSBtYXRjaEdyb3VwLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG1Ib3VyID0gKHVwcGVyVG9rZW4gPT09IGR0Zi5QTURlc2lnbmF0b3IudG9VcHBlckNhc2UoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwbUhvdXIgJiYgKHVwcGVyVG9rZW4gIT09IGR0Zi5BTURlc2lnbmF0b3IudG9VcHBlckNhc2UoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImZcIjpcclxuICAgICAgICAgICAgICAgICAgICBtc2VjID0gcGFyc2VJbnQobWF0Y2hHcm91cCwgMTApICogMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobXNlYyA8IDApIHx8IChtc2VjID4gOTk5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmZcIjpcclxuICAgICAgICAgICAgICAgICAgICBtc2VjID0gcGFyc2VJbnQobWF0Y2hHcm91cCwgMTApICogMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChtc2VjIDwgMCkgfHwgKG1zZWMgPiA5OTkpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJmZmZcIjpcclxuICAgICAgICAgICAgICAgICAgICBtc2VjID0gcGFyc2VJbnQobWF0Y2hHcm91cCwgMTApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobXNlYyA8IDApIHx8IChtc2VjID4gOTk5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGRkZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHdlZWtEYXkgPSBjdWx0dXJlSW5mby5fZ2V0RGF5SW5kZXgobWF0Y2hHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh3ZWVrRGF5IDwgMCkgfHwgKHdlZWtEYXkgPiA2KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGRkXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgd2Vla0RheSA9IGN1bHR1cmVJbmZvLl9nZXREYXlJbmRleChtYXRjaEdyb3VwLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHdlZWtEYXkgPCAwKSB8fCAod2Vla0RheSA+IDYpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ6enpcIjpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0cyA9IG1hdGNoR3JvdXAuc3BsaXQoLzovKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0cy5sZW5ndGggIT09IDIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvdXJPZmZzZXQgPSBwYXJzZUludChvZmZzZXRzWzBdLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChob3VyT2Zmc2V0IDwgLTEyKSB8fCAoaG91ck9mZnNldCA+IDEzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbk9mZnNldCA9IHBhcnNlSW50KG9mZnNldHNbMV0sIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKG1pbk9mZnNldCA8IDApIHx8IChtaW5PZmZzZXQgPiA1OSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHR6TWluT2Zmc2V0ID0gKGhvdXJPZmZzZXQgKiA2MCkgKyAobWF0Y2hHcm91cC5zdGFydHNXaXRoKFwiLVwiKSA/IC1taW5PZmZzZXQgOiBtaW5PZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInpcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ6elwiOlxyXG4gICAgICAgICAgICAgICAgICAgIGhvdXJPZmZzZXQgPSBwYXJzZUludChtYXRjaEdyb3VwLCAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChob3VyT2Zmc2V0IDwgLTEyKSB8fCAoaG91ck9mZnNldCA+IDEzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdHpNaW5PZmZzZXQgPSBob3VyT2Zmc2V0ICogNjA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ1wiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImdnXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyYU5hbWUgPSBtYXRjaEdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZXJhTmFtZSB8fCAhZHRmLkVyYXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGVyYU5hbWUgPSBlcmFOYW1lLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZHRmLkVyYXMubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcmFOYW1lID09PSBkdGYuRXJhc1tpICsgMV0udG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJhID0gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcmEgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKCk7XHJcbiAgICB2YXIgZGVmYXVsdFllYXI7XHJcbiAgICB2YXIgY29udmVydCA9IGR0Zi5DYWxlbmRhci5jb252ZXJ0O1xyXG4gICAgLy8gSWYgbm9uZSBhcmUgc3BlY2lmaWVkLCBzZXQgdG8gdG9kYXlzIGRhdGUgdG8gMS8xLzE5NzBcclxuICAgIGlmICh5ZWFyID09IG51bGwgJiYgbW9udGggPT0gbnVsbCAmJiBkYXRlID09IG51bGwpIHtcclxuICAgICAgICB5ZWFyID0gMTk3MDtcclxuICAgICAgICBtb250aCA9IDA7XHJcbiAgICAgICAgZGF0ZSA9IDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoY29udmVydCkge1xyXG4gICAgICAgICAgICBkZWZhdWx0WWVhciA9IGNvbnZlcnQuZnJvbUdyZWdvcmlhbihyZXN1bHQpWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVmYXVsdFllYXIgPSByZXN1bHQuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHllYXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgeWVhciA9IGRlZmF1bHRZZWFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkdGYuRXJhcykge1xyXG4gICAgICAgICAgICB5ZWFyICs9IGR0Zi5FcmFzWyhlcmEgfHwgMCkgKyAzXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vbnRoID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vbnRoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGNvbnZlcnQpIHtcclxuICAgICAgICByZXN1bHQgPSBjb252ZXJ0LnRvR3JlZ29yaWFuKHllYXIsIG1vbnRoLCBkYXRlKTtcclxuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdC5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgZGF0ZSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdC5nZXREYXRlKCkgIT09IGRhdGUpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmICgod2Vla0RheSAhPT0gbnVsbCkgJiYgKHJlc3VsdC5nZXREYXkoKSAhPT0gd2Vla0RheSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBtSG91ciAmJiAoaG91ciA8IDEyKSkge1xyXG4gICAgICAgIGhvdXIgKz0gMTI7XHJcbiAgICB9XHJcbiAgICByZXN1bHQuc2V0SG91cnMoaG91ciwgbWluLCBzZWMsIG1zZWMpO1xyXG4gICAgaWYgKHR6TWluT2Zmc2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGFkanVzdGVkTWluID0gcmVzdWx0LmdldE1pbnV0ZXMoKSAtICh0ek1pbk9mZnNldCArIHJlc3VsdC5nZXRUaW1lem9uZU9mZnNldCgpKTtcclxuICAgICAgICByZXN1bHQuc2V0SG91cnMocmVzdWx0LmdldEhvdXJzKCkgKyBwYXJzZUludCgoYWRqdXN0ZWRNaW4gLyA2MCkudG9TdHJpbmcoKSwgMTApLCBhZGp1c3RlZE1pbiAlIDYwKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtKSB7XHJcbiAgICBpZiAobnVtIDwgMTApIHtcclxuICAgICAgICByZXR1cm4gXCIwXCIgKyBudW07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtLnRvU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm9zKG51bSkge1xyXG4gICAgaWYgKG51bSA8IDEwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiMDBcIiArIG51bTtcclxuICAgIH1cclxuICAgIGlmIChudW0gPCAxMDApIHtcclxuICAgICAgICByZXR1cm4gXCIwXCIgKyBudW07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtLnRvU3RyaW5nKCk7XHJcbn1cclxuZnVuY3Rpb24gcGFkWWVhcih5ZWFyKSB7XHJcbiAgICBpZiAoeWVhciA8IDEwKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiMDAwXCIgKyB5ZWFyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoeWVhciA8IDEwMCkge1xyXG4gICAgICAgIHJldHVybiBcIjAwXCIgKyB5ZWFyO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoeWVhciA8IDEwMDApIHtcclxuICAgICAgICByZXR1cm4gXCIwXCIgKyB5ZWFyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHllYXIudG9TdHJpbmcoKTtcclxufVxyXG4vKipcclxuICogRm9ybWF0cyBhIGRhdGUgYXMgdGV4dCB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0IHN0cmluZyBhbmQgY3VsdHVyZVxyXG4gKiBAcGFyYW0gZGF0ZSBUaGUgZGF0ZSB0byBmb3JtYXRcclxuICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHNwZWNpZmllclxyXG4gKiBAcGFyYW0gY3VsdHVyZUluZm8gVGhlIGN1bHR1cmVcclxuICovXHJcbmZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCBjdWx0dXJlSW5mbykge1xyXG4gICAgaWYgKCFkYXRlKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgdmFyIGR0ZiA9IGN1bHR1cmVJbmZvLmRhdGVUaW1lRm9ybWF0O1xyXG4gICAgdmFyIGNvbnZlcnQgPSBkdGYuQ2FsZW5kYXIuY29udmVydDtcclxuICAgIGlmICghZm9ybWF0IHx8ICFmb3JtYXQubGVuZ3RoIHx8IChmb3JtYXQgPT09IFwiaVwiKSkge1xyXG4gICAgICAgIGlmIChjdWx0dXJlSW5mbyAmJiBjdWx0dXJlSW5mby5uYW1lLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoY29udmVydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSwgZHRmLkZ1bGxEYXRlVGltZVBhdHRlcm4sIGN1bHR1cmVJbmZvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcmFEYXRlID0gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVyYSA9IGdldEVyYShkYXRlLCBkdGYuRXJhcyk7XHJcbiAgICAgICAgICAgICAgICBlcmFEYXRlLnNldEZ1bGxZZWFyKGdldEVyYVllYXIoZGF0ZSwgZHRmLCBlcmEpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcmFEYXRlLnRvTG9jYWxlU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGVyYXMgPSBkdGYuRXJhcztcclxuICAgIHZhciBzb3J0YWJsZSA9IChmb3JtYXQgPT09IFwic1wiKTtcclxuICAgIGZvcm1hdCA9IGV4cGFuZERhdGVGb3JtYXQoZHRmLCBmb3JtYXQpO1xyXG4gICAgdmFyIHJldCA9IG5ldyBTdHJpbmdCdWlsZGVyKCk7XHJcbiAgICB2YXIgaG91cjtcclxuICAgIHZhciBmb3VuZERheTtcclxuICAgIHZhciBjaGVja2VkRGF5O1xyXG4gICAgdmFyIGRheVBhcnRSZWdFeHAgPSAvKFteZF18XikoZHxkZCkoW15kXXwkKS9nO1xyXG4gICAgdmFyIGhhc0RheSA9IGZ1bmN0aW9uIGhhc0RheSgpIHtcclxuICAgICAgICBpZiAoZm91bmREYXkgfHwgY2hlY2tlZERheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm91bmREYXk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvdW5kRGF5ID0gZGF5UGFydFJlZ0V4cC50ZXN0KGZvcm1hdCk7XHJcbiAgICAgICAgY2hlY2tlZERheSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kRGF5O1xyXG4gICAgfTtcclxuICAgIHZhciBxdW90ZUNvdW50ID0gMDtcclxuICAgIHZhciB0b2tlblJlZ0V4cCA9IGdldERhdGVUb2tlblJlZ0V4cCgpO1xyXG4gICAgdmFyIGNvbnZlcnRlZDtcclxuICAgIGlmICghc29ydGFibGUgJiYgY29udmVydCkge1xyXG4gICAgICAgIGNvbnZlcnRlZCA9IGNvbnZlcnQuZnJvbUdyZWdvcmlhbihkYXRlKTtcclxuICAgIH1cclxuICAgIGZvciAoOzspIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0b2tlblJlZ0V4cC5sYXN0SW5kZXg7XHJcbiAgICAgICAgdmFyIGFyID0gdG9rZW5SZWdFeHAuZXhlYyhmb3JtYXQpO1xyXG4gICAgICAgIHZhciBwcmVNYXRjaCA9IGZvcm1hdC5zbGljZShpbmRleCwgYXIgPyBhci5pbmRleCA6IGZvcm1hdC5sZW5ndGgpO1xyXG4gICAgICAgIHF1b3RlQ291bnQgKz0gZGF0ZSRhcHBlbmRQcmVPclBvc3RNYXRjaChwcmVNYXRjaCwgcmV0KTtcclxuICAgICAgICBpZiAoIWFyKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKHF1b3RlQ291bnQgJSAyKSA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXQuYXBwZW5kKGFyWzBdKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBnZXREYXRlUGFydCA9IGZ1bmN0aW9uIGdldERhdGVQYXJ0KGRhdGUsIHBhcnQpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnZlcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRlZFtwYXJ0XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIGRhdGUuZ2V0TW9udGgoKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzd2l0Y2ggKGFyWzBdKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJkZGRkXCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGR0Zi5EYXlOYW1lc1tkYXRlLmdldERheSgpXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRkZFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0LmFwcGVuZChkdGYuQWJicmV2aWF0ZWREYXlOYW1lc1tkYXRlLmdldERheSgpXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRkXCI6XHJcbiAgICAgICAgICAgICAgICBmb3VuZERheSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGFkZExlYWRpbmdaZXJvKGdldERhdGVQYXJ0KGRhdGUsIDIpKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcImRcIjpcclxuICAgICAgICAgICAgICAgIGZvdW5kRGF5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoZ2V0RGF0ZVBhcnQoZGF0ZSwgMikudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIk1NTU1cIjpcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoKGR0Zi5Nb250aEdlbml0aXZlTmFtZXMgJiYgaGFzRGF5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBkdGYuTW9udGhHZW5pdGl2ZU5hbWVzW2dldERhdGVQYXJ0KGRhdGUsIDEpXVxyXG4gICAgICAgICAgICAgICAgICAgIDogZHRmLk1vbnRoTmFtZXNbZ2V0RGF0ZVBhcnQoZGF0ZSwgMSldKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiTU1NXCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKChkdGYuQWJicmV2aWF0ZWRNb250aEdlbml0aXZlTmFtZXMgJiYgaGFzRGF5KCkpXHJcbiAgICAgICAgICAgICAgICAgICAgPyBkdGYuQWJicmV2aWF0ZWRNb250aEdlbml0aXZlTmFtZXNbZ2V0RGF0ZVBhcnQoZGF0ZSwgMSldXHJcbiAgICAgICAgICAgICAgICAgICAgOiBkdGYuQWJicmV2aWF0ZWRNb250aE5hbWVzW2dldERhdGVQYXJ0KGRhdGUsIDEpXSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIk1NXCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGFkZExlYWRpbmdaZXJvKGdldERhdGVQYXJ0KGRhdGUsIDEpICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJNXCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKChnZXREYXRlUGFydChkYXRlLCAxKSArIDEpLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKHBhZFllYXIoY29udmVydGVkID8gY29udmVydGVkWzBdIDogZ2V0RXJhWWVhcihkYXRlLCBkdGYsIGdldEVyYShkYXRlLCBlcmFzKSwgc29ydGFibGUpKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInl5XCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGFkZExlYWRpbmdaZXJvKChjb252ZXJ0ZWQgPyBjb252ZXJ0ZWRbMF0gOiBnZXRFcmFZZWFyKGRhdGUsIGR0ZiwgZ2V0RXJhKGRhdGUsIGVyYXMpLCBzb3J0YWJsZSkpICUgMTAwKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInlcIjpcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoKChjb252ZXJ0ZWQgPyBjb252ZXJ0ZWRbMF0gOiBnZXRFcmFZZWFyKGRhdGUsIGR0ZiwgZ2V0RXJhKGRhdGUsIGVyYXMpLCBzb3J0YWJsZSkpICUgMTAwKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiaGhcIjpcclxuICAgICAgICAgICAgICAgIGhvdXIgPSBkYXRlLmdldEhvdXJzKCkgJSAxMjtcclxuICAgICAgICAgICAgICAgIGlmIChob3VyID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGhvdXIgPSAxMjtcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoYWRkTGVhZGluZ1plcm8oaG91cikpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJoXCI6XHJcbiAgICAgICAgICAgICAgICBob3VyID0gZGF0ZS5nZXRIb3VycygpICUgMTI7XHJcbiAgICAgICAgICAgICAgICBpZiAoaG91ciA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBob3VyID0gMTI7XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGhvdXIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIkhIXCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGFkZExlYWRpbmdaZXJvKGRhdGUuZ2V0SG91cnMoKSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJIXCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGRhdGUuZ2V0SG91cnMoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibW1cIjpcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoYWRkTGVhZGluZ1plcm8oZGF0ZS5nZXRNaW51dGVzKCkpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwibVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0LmFwcGVuZChkYXRlLmdldE1pbnV0ZXMoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic3NcIjpcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoYWRkTGVhZGluZ1plcm8oZGF0ZS5nZXRTZWNvbmRzKCkpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwic1wiOlxyXG4gICAgICAgICAgICAgICAgcmV0LmFwcGVuZChkYXRlLmdldFNlY29uZHMoKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwidHRcIjpcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoKGRhdGUuZ2V0SG91cnMoKSA8IDEyKSA/IGR0Zi5BTURlc2lnbmF0b3IgOiBkdGYuUE1EZXNpZ25hdG9yKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwidFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0LmFwcGVuZCgoKGRhdGUuZ2V0SG91cnMoKSA8IDEyKSA/IGR0Zi5BTURlc2lnbmF0b3IgOiBkdGYuUE1EZXNpZ25hdG9yKS5jaGFyQXQoMCkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmXCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpKS5jaGFyQXQoMCkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJmZlwiOlxyXG4gICAgICAgICAgICAgICAgcmV0LmFwcGVuZChhZGRMZWFkaW5nWmVyb3MoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSkuc3Vic3RyKDAsIDIpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiZmZmXCI6XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKGFkZExlYWRpbmdaZXJvcyhkYXRlLmdldE1pbGxpc2Vjb25kcygpKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInpcIjpcclxuICAgICAgICAgICAgICAgIGhvdXIgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLyA2MDtcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoKChob3VyIDw9IDApID8gXCIrXCIgOiBcIi1cIikgKyBNYXRoLmZsb29yKE1hdGguYWJzKGhvdXIpKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcInp6XCI6XHJcbiAgICAgICAgICAgICAgICBob3VyID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC8gNjA7XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKCgoaG91ciA8PSAwKSA/IFwiK1wiIDogXCItXCIpICsgYWRkTGVhZGluZ1plcm8oTWF0aC5mbG9vcihNYXRoLmFicyhob3VyKSkpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwienp6XCI6XHJcbiAgICAgICAgICAgICAgICBob3VyID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC8gNjA7XHJcbiAgICAgICAgICAgICAgICByZXQuYXBwZW5kKCgoaG91ciA8PSAwKSA/IFwiK1wiIDogXCItXCIpICsgYWRkTGVhZGluZ1plcm8oTWF0aC5mbG9vcihNYXRoLmFicyhob3VyKSkpICtcclxuICAgICAgICAgICAgICAgICAgICBcIjpcIiArIGFkZExlYWRpbmdaZXJvKE1hdGguYWJzKGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAlIDYwKSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCJnXCI6XHJcbiAgICAgICAgICAgIGNhc2UgXCJnZ1wiOlxyXG4gICAgICAgICAgICAgICAgaWYgKGR0Zi5FcmFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0LmFwcGVuZChkdGYuRXJhc1tnZXRFcmEoZGF0ZSwgZXJhcykgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIi9cIjpcclxuICAgICAgICAgICAgICAgIHJldC5hcHBlbmQoZHRmLkRhdGVTZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldC50b1N0cmluZygpO1xyXG59XHJcbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGZvcm1hdERhdGU7XHJcbmZ1bmN0aW9uIGdldE51bWJlclN0eWxlKGZvcm1hdCkge1xyXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8IFwiXCI7XHJcbiAgICBpZiAoZm9ybWF0Lm1hdGNoKC9bJGNdKy9pKSlcclxuICAgICAgICByZXR1cm4gXCJDdXJyZW5jeVwiO1xyXG4gICAgaWYgKGZvcm1hdC5tYXRjaCgvWyVwXSsvaSkpXHJcbiAgICAgICAgcmV0dXJuIFwiUGVyY2VudFwiO1xyXG4gICAgaWYgKGZvcm1hdC5tYXRjaCgvW2RuZmddMC9pKSlcclxuICAgICAgICByZXR1cm4gXCJJbnRlZ2VyXCI7XHJcbiAgICByZXR1cm4gXCJOdW1iZXJcIjtcclxufVxyXG5leHBvcnRzLmdldE51bWJlclN0eWxlID0gZ2V0TnVtYmVyU3R5bGU7XHJcbmZ1bmN0aW9uIHBhcnNlTnVtYmVyKHZhbHVlLCBzdHlsZSwgY3VsdHVyZUluZm8pIHtcclxuICAgIC8vIEhhbmRsZSB1c2Ugb2YgKCkgdG8gZGVub3RlIG5lZ2F0aXZlIG51bWJlcnNcclxuICAgIHZhciBzaWduID0gMTtcclxuICAgIGlmICh2YWx1ZS5tYXRjaCgvXlxcKC4qXFwpJC8pKSB7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgc2lnbiA9IC0xO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIC8vIFJlbW92ZSBjdXJyZW5jeSBzeW1ib2xzIGJlZm9yZSBwYXJzaW5nXHJcbiAgICBpZiAoc3R5bGUgPT09IFwiQ3VycmVuY3lcIikge1xyXG4gICAgICAgIHJlc3VsdCA9IF9wYXJzZU51bWJlcih2YWx1ZS5yZXBsYWNlKGN1bHR1cmVJbmZvLm51bWJlckZvcm1hdC5DdXJyZW5jeVN5bWJvbCwgXCJcIiksIGN1bHR1cmVJbmZvKSAqIHNpZ247XHJcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBkZWNpbWFsIHBsYWNlLCBjaGVjayB0aGUgcHJlY2lzaW9uIGlzbnQgZ3JlYXRlciB0aGFuIGFsbG93ZWQgZm9yIGN1cnJlbmN5LlxyXG4gICAgICAgIC8vIEZsb2F0aW5nIHBvaW50cyBpbiBqcyBjYW4gYmUgc2tld2VkIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgd2UgYXJlIGp1c3QgY2hlY2tpbmcgdGhlIGRlY2ltYWxzIGluc3RlYWQgb2YgbXVsdGlwbHlpbmcgcmVzdWx0cy5cclxuICAgICAgICB2YXIgcmVzdWx0dmFsdWUgPSByZXN1bHQudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAocmVzdWx0dmFsdWUuaW5kZXhPZihcIi5cIikgPiAtMSAmJiAocmVzdWx0dmFsdWUubGVuZ3RoIC0gKHJlc3VsdHZhbHVlLmluZGV4T2YoXCIuXCIpICsgMSkpID4gY3VsdHVyZUluZm8ubnVtYmVyRm9ybWF0LkN1cnJlbmN5RGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmVtb3ZlIHBlcmNlbnRhZ2Ugc3ltYm9scyBiZWZvcmUgcGFyc2luZyBhbmQgZGl2aWRlIGJ5IDEwMFxyXG4gICAgZWxzZSBpZiAoc3R5bGUgPT09IFwiUGVyY2VudFwiKVxyXG4gICAgICAgIHJlc3VsdCA9IF9wYXJzZU51bWJlcih2YWx1ZS5yZXBsYWNlKGN1bHR1cmVJbmZvLm51bWJlckZvcm1hdC5QZXJjZW50U3ltYm9sLCBcIlwiKSwgY3VsdHVyZUluZm8pIC8gMTAwICogc2lnbjtcclxuICAgIC8vIEVuc3VyZSBpbnRlZ2VycyBhcmUgYWN0dWFsIHdob2xlIG51bWJlcnNcclxuICAgIGVsc2UgaWYgKHN0eWxlID09PSBcIkludGVnZXJcIiAmJiAhaXNJbnRlZ2VyKF9wYXJzZU51bWJlcih2YWx1ZSwgY3VsdHVyZUluZm8pKSlcclxuICAgICAgICByZXN1bHQgPSBOYU47XHJcbiAgICAvLyBKdXN0IHBhcnNlIGEgc2ltcGxlIG51bWJlclxyXG4gICAgZWxzZVxyXG4gICAgICAgIHJlc3VsdCA9IF9wYXJzZU51bWJlcih2YWx1ZSwgY3VsdHVyZUluZm8pICogc2lnbjtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy5wYXJzZU51bWJlciA9IHBhcnNlTnVtYmVyO1xyXG5mdW5jdGlvbiBpc0ludGVnZXIob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIChvYmopID09PSBcIm51bWJlclwiICYmICFpc05hTihvYmopICYmIC9eLT9bMC05XXsxLDEwfSQvLnRlc3Qob2JqLnRvU3RyaW5nKCkpICYmIChvYmogPj0gLTIxNDc0ODM2NDggJiYgb2JqIDw9IDIxNDc0ODM2NDcpO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZXMgdGhlIGdpdmVuIHRleHQgYXMgYSBudW1iZXJcclxuICogQHBhcmFtIHZhbHVlIFRoZSB0ZXh0IHRvIHBhcnNlXHJcbiAqIEBwYXJhbSBjdWx0dXJlSW5mbyBUaGUgY3VsdHVyZVxyXG4gKi9cclxuZnVuY3Rpb24gX3BhcnNlTnVtYmVyKHZhbHVlLCBjdWx0dXJlSW5mbykge1xyXG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XHJcbiAgICBpZiAodmFsdWUubWF0Y2goL15bKy1dP2luZmluaXR5JC9pKSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZS5tYXRjaCgvXjB4W2EtZjAtOV0rJC9pKSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgbnVtRm9ybWF0ID0gY3VsdHVyZUluZm8ubnVtYmVyRm9ybWF0O1xyXG4gICAgdmFyIHNpZ25JbmZvID0gcGFyc2VOdW1iZXJOZWdhdGl2ZVBhdHRlcm4odmFsdWUsIG51bUZvcm1hdCwgbnVtRm9ybWF0Lk51bWJlck5lZ2F0aXZlUGF0dGVybik7XHJcbiAgICB2YXIgc2lnbiA9IHNpZ25JbmZvWzBdO1xyXG4gICAgdmFyIG51bSA9IHNpZ25JbmZvWzFdO1xyXG4gICAgaWYgKChzaWduID09PSBcIlwiKSAmJiAobnVtRm9ybWF0Lk51bWJlck5lZ2F0aXZlUGF0dGVybiAhPT0gMSkpIHtcclxuICAgICAgICBzaWduSW5mbyA9IHBhcnNlTnVtYmVyTmVnYXRpdmVQYXR0ZXJuKHZhbHVlLCBudW1Gb3JtYXQsIDEpO1xyXG4gICAgICAgIHNpZ24gPSBzaWduSW5mb1swXTtcclxuICAgICAgICBudW0gPSBzaWduSW5mb1sxXTtcclxuICAgIH1cclxuICAgIGlmIChzaWduID09PSBcIlwiKVxyXG4gICAgICAgIHNpZ24gPSBcIitcIjtcclxuICAgIHZhciBleHBvbmVudDtcclxuICAgIHZhciBpbnRBbmRGcmFjdGlvbjtcclxuICAgIHZhciBleHBvbmVudFBvcyA9IG51bS5pbmRleE9mKFwiZVwiKTtcclxuICAgIGlmIChleHBvbmVudFBvcyA8IDApXHJcbiAgICAgICAgZXhwb25lbnRQb3MgPSBudW0uaW5kZXhPZihcIkVcIik7XHJcbiAgICBpZiAoZXhwb25lbnRQb3MgPCAwKSB7XHJcbiAgICAgICAgaW50QW5kRnJhY3Rpb24gPSBudW07XHJcbiAgICAgICAgZXhwb25lbnQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaW50QW5kRnJhY3Rpb24gPSBudW0uc3Vic3RyKDAsIGV4cG9uZW50UG9zKTtcclxuICAgICAgICBleHBvbmVudCA9IG51bS5zdWJzdHIoZXhwb25lbnRQb3MgKyAxKTtcclxuICAgIH1cclxuICAgIHZhciBpbnRlZ2VyO1xyXG4gICAgdmFyIGZyYWN0aW9uO1xyXG4gICAgdmFyIGRlY2ltYWxQb3MgPSBpbnRBbmRGcmFjdGlvbi5pbmRleE9mKG51bUZvcm1hdC5OdW1iZXJEZWNpbWFsU2VwYXJhdG9yKTtcclxuICAgIGlmIChkZWNpbWFsUG9zIDwgMCkge1xyXG4gICAgICAgIGludGVnZXIgPSBpbnRBbmRGcmFjdGlvbjtcclxuICAgICAgICBmcmFjdGlvbiA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpbnRlZ2VyID0gaW50QW5kRnJhY3Rpb24uc3Vic3RyKDAsIGRlY2ltYWxQb3MpO1xyXG4gICAgICAgIGZyYWN0aW9uID0gaW50QW5kRnJhY3Rpb24uc3Vic3RyKGRlY2ltYWxQb3MgKyBudW1Gb3JtYXQuTnVtYmVyRGVjaW1hbFNlcGFyYXRvci5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgaW50ZWdlciA9IGludGVnZXIuc3BsaXQobnVtRm9ybWF0Lk51bWJlckdyb3VwU2VwYXJhdG9yKS5qb2luKFwiXCIpO1xyXG4gICAgdmFyIGFsdE51bUdyb3VwU2VwYXJhdG9yID0gbnVtRm9ybWF0Lk51bWJlckdyb3VwU2VwYXJhdG9yLnJlcGxhY2UoL1xcdTAwQTAvZywgXCIgXCIpO1xyXG4gICAgaWYgKG51bUZvcm1hdC5OdW1iZXJHcm91cFNlcGFyYXRvciAhPT0gYWx0TnVtR3JvdXBTZXBhcmF0b3IpIHtcclxuICAgICAgICBpbnRlZ2VyID0gaW50ZWdlci5zcGxpdChhbHROdW1Hcm91cFNlcGFyYXRvcikuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHZhciBwID0gc2lnbiArIGludGVnZXI7XHJcbiAgICBpZiAoZnJhY3Rpb24gIT09IG51bGwpIHtcclxuICAgICAgICBwICs9IFwiLlwiICsgZnJhY3Rpb247XHJcbiAgICB9XHJcbiAgICBpZiAoZXhwb25lbnQgIT09IG51bGwpIHtcclxuICAgICAgICB2YXIgZXhwU2lnbkluZm8gPSBwYXJzZU51bWJlck5lZ2F0aXZlUGF0dGVybihleHBvbmVudCwgbnVtRm9ybWF0LCAxKTtcclxuICAgICAgICBpZiAoZXhwU2lnbkluZm9bMF0gPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgZXhwU2lnbkluZm9bMF0gPSBcIitcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcCArPSBcImVcIiArIGV4cFNpZ25JbmZvWzBdICsgZXhwU2lnbkluZm9bMV07XHJcbiAgICB9XHJcbiAgICBpZiAocC5tYXRjaCgvXlsrLV0/XFxkKlxcLj9cXGQqKGVbKy1dP1xcZCspPyQvKSkge1xyXG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE51bWJlci5OYU47XHJcbn1cclxuZXhwb3J0cy5fcGFyc2VOdW1iZXIgPSBfcGFyc2VOdW1iZXI7XHJcbjtcclxuZnVuY3Rpb24gcGFyc2VOdW1iZXJOZWdhdGl2ZVBhdHRlcm4odmFsdWUsIG51bWJlckZvcm1hdEluZm8sIG51bWJlck5lZ2F0aXZlUGF0dGVybikge1xyXG4gICAgdmFyIG5lZyA9IG51bWJlckZvcm1hdEluZm8uTmVnYXRpdmVTaWduO1xyXG4gICAgdmFyIHBvcyA9IG51bWJlckZvcm1hdEluZm8uUG9zaXRpdmVTaWduO1xyXG4gICAgc3dpdGNoIChudW1iZXJOZWdhdGl2ZVBhdHRlcm4pIHtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgIG5lZyA9IFwiIFwiICsgbmVnO1xyXG4gICAgICAgICAgICBwb3MgPSBcIiBcIiArIHBvcztcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5lbmRzV2l0aChuZWcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiLVwiLCB2YWx1ZS5zdWJzdHIoMCwgdmFsdWUubGVuZ3RoIC0gbmVnLmxlbmd0aCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLmVuZHNXaXRoKHBvcykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXCIrXCIsIHZhbHVlLnN1YnN0cigwLCB2YWx1ZS5sZW5ndGggLSBwb3MubGVuZ3RoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBuZWcgKz0gXCIgXCI7XHJcbiAgICAgICAgICAgIHBvcyArPSBcIiBcIjtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKG5lZykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXCItXCIsIHZhbHVlLnN1YnN0cihuZWcubGVuZ3RoKV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuc3RhcnRzV2l0aChwb3MpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiK1wiLCB2YWx1ZS5zdWJzdHIocG9zLmxlbmd0aCldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoXCIoXCIpICYmIHZhbHVlLmVuZHNXaXRoKFwiKVwiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcIi1cIiwgdmFsdWUuc3Vic3RyKDEsIHZhbHVlLmxlbmd0aCAtIDIpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBbXCJcIiwgdmFsdWVdO1xyXG59XHJcbjtcclxuZnVuY3Rpb24gemVyb1BhZChzdHIsIGNvdW50LCBsZWZ0KSB7XHJcbiAgICBmb3IgKHZhciBsID0gc3RyLmxlbmd0aDsgbCA8IGNvdW50OyBsKyspIHtcclxuICAgICAgICBzdHIgPSAobGVmdCA/IChcIjBcIiArIHN0cikgOiAoc3RyICsgXCIwXCIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHI7XHJcbn1cclxuZnVuY3Rpb24gZXhwYW5kTnVtYmVyKG51bWJlciwgcHJlY2lzaW9uLCBncm91cFNpemVzLCBzZXAsIGRlY2ltYWxDaGFyKSB7XHJcbiAgICB2YXIgY3VyU2l6ZSA9IGdyb3VwU2l6ZXNbMF07XHJcbiAgICB2YXIgY3VyR3JvdXBJbmRleCA9IDE7XHJcbiAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XHJcbiAgICB2YXIgcm91bmRlZCA9IChNYXRoLnJvdW5kKG51bWJlciAqIGZhY3RvcikgLyBmYWN0b3IpO1xyXG4gICAgaWYgKCFpc0Zpbml0ZShyb3VuZGVkKSkge1xyXG4gICAgICAgIHJvdW5kZWQgPSBudW1iZXI7XHJcbiAgICB9XHJcbiAgICBudW1iZXIgPSByb3VuZGVkO1xyXG4gICAgdmFyIG51bWJlclN0cmluZyA9IG51bWJlci50b1N0cmluZygpO1xyXG4gICAgdmFyIHJpZ2h0ID0gXCJcIjtcclxuICAgIHZhciBleHBvbmVudDtcclxuICAgIHZhciBzcGxpdCA9IG51bWJlclN0cmluZy5zcGxpdCgvZS9pKTtcclxuICAgIG51bWJlclN0cmluZyA9IHNwbGl0WzBdO1xyXG4gICAgZXhwb25lbnQgPSAoc3BsaXQubGVuZ3RoID4gMSA/IHBhcnNlSW50KHNwbGl0WzFdKSA6IDApO1xyXG4gICAgc3BsaXQgPSBudW1iZXJTdHJpbmcuc3BsaXQoXCIuXCIpO1xyXG4gICAgbnVtYmVyU3RyaW5nID0gc3BsaXRbMF07XHJcbiAgICByaWdodCA9IHNwbGl0Lmxlbmd0aCA+IDEgPyBzcGxpdFsxXSA6IFwiXCI7XHJcbiAgICBpZiAoZXhwb25lbnQgPiAwKSB7XHJcbiAgICAgICAgcmlnaHQgPSB6ZXJvUGFkKHJpZ2h0LCBleHBvbmVudCwgZmFsc2UpO1xyXG4gICAgICAgIG51bWJlclN0cmluZyArPSByaWdodC5zbGljZSgwLCBleHBvbmVudCk7XHJcbiAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoZXhwb25lbnQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwb25lbnQgPCAwKSB7XHJcbiAgICAgICAgZXhwb25lbnQgPSAtZXhwb25lbnQ7XHJcbiAgICAgICAgbnVtYmVyU3RyaW5nID0gemVyb1BhZChudW1iZXJTdHJpbmcsIGV4cG9uZW50ICsgMSwgdHJ1ZSk7XHJcbiAgICAgICAgcmlnaHQgPSBudW1iZXJTdHJpbmcuc2xpY2UoLWV4cG9uZW50LCBudW1iZXJTdHJpbmcubGVuZ3RoKSArIHJpZ2h0O1xyXG4gICAgICAgIG51bWJlclN0cmluZyA9IG51bWJlclN0cmluZy5zbGljZSgwLCAtZXhwb25lbnQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHByZWNpc2lvbiA+IDApIHtcclxuICAgICAgICBpZiAocmlnaHQubGVuZ3RoID4gcHJlY2lzaW9uKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc2xpY2UoMCwgcHJlY2lzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gemVyb1BhZChyaWdodCwgcHJlY2lzaW9uLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJpZ2h0ID0gZGVjaW1hbENoYXIgKyByaWdodDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJpZ2h0ID0gXCJcIjtcclxuICAgIH1cclxuICAgIHZhciBzdHJpbmdJbmRleCA9IG51bWJlclN0cmluZy5sZW5ndGggLSAxO1xyXG4gICAgdmFyIHJldCA9IFwiXCI7XHJcbiAgICB3aGlsZSAoc3RyaW5nSW5kZXggPj0gMCkge1xyXG4gICAgICAgIGlmIChjdXJTaXplID09PSAwIHx8IGN1clNpemUgPiBzdHJpbmdJbmRleCkge1xyXG4gICAgICAgICAgICBpZiAocmV0Lmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyU3RyaW5nLnNsaWNlKDAsIHN0cmluZ0luZGV4ICsgMSkgKyBzZXAgKyByZXQgKyByaWdodDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlclN0cmluZy5zbGljZSgwLCBzdHJpbmdJbmRleCArIDEpICsgcmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXQubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgcmV0ID0gbnVtYmVyU3RyaW5nLnNsaWNlKHN0cmluZ0luZGV4IC0gY3VyU2l6ZSArIDEsIHN0cmluZ0luZGV4ICsgMSkgKyBzZXAgKyByZXQ7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXQgPSBudW1iZXJTdHJpbmcuc2xpY2Uoc3RyaW5nSW5kZXggLSBjdXJTaXplICsgMSwgc3RyaW5nSW5kZXggKyAxKTtcclxuICAgICAgICBzdHJpbmdJbmRleCAtPSBjdXJTaXplO1xyXG4gICAgICAgIGlmIChjdXJHcm91cEluZGV4IDwgZ3JvdXBTaXplcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY3VyU2l6ZSA9IGdyb3VwU2l6ZXNbY3VyR3JvdXBJbmRleF07XHJcbiAgICAgICAgICAgIGN1ckdyb3VwSW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVtYmVyU3RyaW5nLnNsaWNlKDAsIHN0cmluZ0luZGV4ICsgMSkgKyBzZXAgKyByZXQgKyByaWdodDtcclxufVxyXG4vKipcclxuICogRm9ybWF0cyBhIG51bWJlciBhcyB0ZXh0IHVzaW5nIHRoZSBnaXZlbiBmb3JtYXQgc3RyaW5nIGFuZCBjdWx0dXJlXHJcbiAqIEBwYXJhbSBudW1iZXIgVGhlIG51bWJlciB0byBmb3JtYXRcclxuICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHNwZWNpZmllclxyXG4gKiBAcGFyYW0gY3VsdHVyZUluZm8gVGhlIGN1bHR1cmVcclxuICovXHJcbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIGZvcm1hdCwgY3VsdHVyZUluZm8pIHtcclxuICAgIGlmICh0eXBlb2YgbnVtYmVyICE9PSBcIm51bWJlclwiIHx8IGlzTmFOKG51bWJlcikpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICBpZiAoIWZvcm1hdCB8fCAoZm9ybWF0Lmxlbmd0aCA9PT0gMCkgfHwgKGZvcm1hdCA9PT0gXCJpXCIpKSB7XHJcbiAgICAgICAgaWYgKGN1bHR1cmVJbmZvICYmIChjdWx0dXJlSW5mby5uYW1lLmxlbmd0aCA+IDApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIudG9Mb2NhbGVTdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgX3BlcmNlbnRQb3NpdGl2ZVBhdHRlcm4gPSBbXCJuICVcIiwgXCJuJVwiLCBcIiVuXCJdO1xyXG4gICAgdmFyIF9wZXJjZW50TmVnYXRpdmVQYXR0ZXJuID0gW1wiLW4gJVwiLCBcIi1uJVwiLCBcIi0lblwiXTtcclxuICAgIHZhciBfbnVtYmVyTmVnYXRpdmVQYXR0ZXJuID0gW1wiKG4pXCIsIFwiLW5cIiwgXCItIG5cIiwgXCJuLVwiLCBcIm4gLVwiXTtcclxuICAgIHZhciBfY3VycmVuY3lQb3NpdGl2ZVBhdHRlcm4gPSBbXCIkblwiLCBcIm4kXCIsIFwiJCBuXCIsIFwibiAkXCJdO1xyXG4gICAgdmFyIF9jdXJyZW5jeU5lZ2F0aXZlUGF0dGVybiA9IFtcIigkbilcIiwgXCItJG5cIiwgXCIkLW5cIiwgXCIkbi1cIiwgXCIobiQpXCIsIFwiLW4kXCIsIFwibi0kXCIsIFwibiQtXCIsIFwiLW4gJFwiLCBcIi0kIG5cIiwgXCJuICQtXCIsIFwiJCBuLVwiLCBcIiQgLW5cIiwgXCJuLSAkXCIsIFwiKCQgbilcIiwgXCIobiAkKVwiXTtcclxuICAgIHZhciBuZiA9IGN1bHR1cmVJbmZvLm51bWJlckZvcm1hdDtcclxuICAgIHZhciBudW0gPSBNYXRoLmFicyhudW1iZXIpO1xyXG4gICAgaWYgKCFmb3JtYXQpXHJcbiAgICAgICAgZm9ybWF0ID0gXCJEXCI7XHJcbiAgICB2YXIgcHJlY2lzaW9uID0gLTE7XHJcbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA+IDEpXHJcbiAgICAgICAgcHJlY2lzaW9uID0gcGFyc2VJbnQoZm9ybWF0LnNsaWNlKDEpLCAxMCk7XHJcbiAgICB2YXIgcGF0dGVybjtcclxuICAgIHN3aXRjaCAoZm9ybWF0LmNoYXJBdCgwKSkge1xyXG4gICAgICAgIGNhc2UgXCJkXCI6XHJcbiAgICAgICAgY2FzZSBcIkRcIjpcclxuICAgICAgICAgICAgcGF0dGVybiA9IFwiblwiO1xyXG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgbnVtID0gemVyb1BhZChcIlwiICsgbnVtLCBwcmVjaXNpb24sIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChudW1iZXIgPCAwKVxyXG4gICAgICAgICAgICAgICAgbnVtID0gLW51bTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcImNcIjpcclxuICAgICAgICBjYXNlIFwiQ1wiOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyIDwgMClcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBfY3VycmVuY3lOZWdhdGl2ZVBhdHRlcm5bbmYuQ3VycmVuY3lOZWdhdGl2ZVBhdHRlcm5dO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gX2N1cnJlbmN5UG9zaXRpdmVQYXR0ZXJuW25mLkN1cnJlbmN5UG9zaXRpdmVQYXR0ZXJuXTtcclxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBuZi5DdXJyZW5jeURlY2ltYWxEaWdpdHM7XHJcbiAgICAgICAgICAgIG51bSA9IGV4cGFuZE51bWJlcihNYXRoLmFicyhudW1iZXIpLCBwcmVjaXNpb24sIG5mLkN1cnJlbmN5R3JvdXBTaXplcywgbmYuQ3VycmVuY3lHcm91cFNlcGFyYXRvciwgbmYuQ3VycmVuY3lEZWNpbWFsU2VwYXJhdG9yKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBcIm5cIjpcclxuICAgICAgICBjYXNlIFwiTlwiOlxyXG4gICAgICAgICAgICBpZiAobnVtYmVyIDwgMClcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBfbnVtYmVyTmVnYXRpdmVQYXR0ZXJuW25mLk51bWJlck5lZ2F0aXZlUGF0dGVybl07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBcIm5cIjtcclxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBuZi5OdW1iZXJEZWNpbWFsRGlnaXRzO1xyXG4gICAgICAgICAgICBudW0gPSBleHBhbmROdW1iZXIoTWF0aC5hYnMobnVtYmVyKSwgcHJlY2lzaW9uLCBuZi5OdW1iZXJHcm91cFNpemVzLCBuZi5OdW1iZXJHcm91cFNlcGFyYXRvciwgbmYuTnVtYmVyRGVjaW1hbFNlcGFyYXRvcik7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJwXCI6XHJcbiAgICAgICAgY2FzZSBcIlBcIjpcclxuICAgICAgICAgICAgaWYgKG51bWJlciA8IDApXHJcbiAgICAgICAgICAgICAgICBwYXR0ZXJuID0gX3BlcmNlbnROZWdhdGl2ZVBhdHRlcm5bbmYuUGVyY2VudE5lZ2F0aXZlUGF0dGVybl07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBfcGVyY2VudFBvc2l0aXZlUGF0dGVybltuZi5QZXJjZW50UG9zaXRpdmVQYXR0ZXJuXTtcclxuICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSBuZi5QZXJjZW50RGVjaW1hbERpZ2l0cztcclxuICAgICAgICAgICAgbnVtID0gZXhwYW5kTnVtYmVyKE1hdGguYWJzKG51bWJlcikgKiAxMDAsIHByZWNpc2lvbiwgbmYuUGVyY2VudEdyb3VwU2l6ZXMsIG5mLlBlcmNlbnRHcm91cFNlcGFyYXRvciwgbmYuUGVyY2VudERlY2ltYWxTZXBhcmF0b3IpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXJyb3IoUmVzLmZvcm1hdEJhZEZvcm1hdFNwZWNpZmllcik7XHJcbiAgICB9XHJcbiAgICB2YXIgcmVnZXggPSAvbnxcXCR8LXwlL2c7XHJcbiAgICB2YXIgcmV0ID0gXCJcIjtcclxuICAgIGZvciAoOzspIHtcclxuICAgICAgICB2YXIgaW5kZXggPSByZWdleC5sYXN0SW5kZXg7XHJcbiAgICAgICAgdmFyIGFyID0gcmVnZXguZXhlYyhwYXR0ZXJuKTtcclxuICAgICAgICByZXQgKz0gcGF0dGVybi5zbGljZShpbmRleCwgYXIgPyBhci5pbmRleCA6IHBhdHRlcm4ubGVuZ3RoKTtcclxuICAgICAgICBpZiAoIWFyKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBzd2l0Y2ggKGFyWzBdKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJuXCI6XHJcbiAgICAgICAgICAgICAgICByZXQgKz0gbnVtO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgXCIkXCI6XHJcbiAgICAgICAgICAgICAgICByZXQgKz0gbmYuQ3VycmVuY3lTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBcIi1cIjpcclxuICAgICAgICAgICAgICAgIGlmICgvWzEtOV0vLnRlc3QobnVtLnRvU3RyaW5nKCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9IG5mLk5lZ2F0aXZlU2lnbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFwiJVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0ICs9IG5mLlBlcmNlbnRTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcbmV4cG9ydHMuZm9ybWF0TnVtYmVyID0gZm9ybWF0TnVtYmVyO1xyXG5mdW5jdGlvbiB0b1VwcGVyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUuc3BsaXQoXCJcXHUwMEEwXCIpLmpvaW4oXCIgXCIpLnRvVXBwZXJDYXNlKCk7XHJcbn1cclxuZnVuY3Rpb24gdG9VcHBlckFycmF5KGFycikge1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBhcnJbaV07XHJcbiAgICAgICAgcmVzdWx0W2ldID0gdG9VcHBlcih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbnZhciBpbnZhcmlhbnRDdWx0dXJlSW5mbyA9IHtcclxuICAgIG5hbWU6IFwiXCIsXHJcbiAgICBudW1iZXJGb3JtYXQ6IHtcclxuICAgICAgICBDdXJyZW5jeURlY2ltYWxEaWdpdHM6IDIsXHJcbiAgICAgICAgQ3VycmVuY3lEZWNpbWFsU2VwYXJhdG9yOiBcIi5cIixcclxuICAgICAgICBDdXJyZW5jeUdyb3VwU2l6ZXM6IFszXSxcclxuICAgICAgICBOdW1iZXJHcm91cFNpemVzOiBbM10sXHJcbiAgICAgICAgUGVyY2VudEdyb3VwU2l6ZXM6IFszXSxcclxuICAgICAgICBDdXJyZW5jeUdyb3VwU2VwYXJhdG9yOiBcIixcIixcclxuICAgICAgICBDdXJyZW5jeVN5bWJvbDogXCJcXHUwMEE0XCIsXHJcbiAgICAgICAgTmFOU3ltYm9sOiBcIk5hTlwiLFxyXG4gICAgICAgIEN1cnJlbmN5TmVnYXRpdmVQYXR0ZXJuOiAwLFxyXG4gICAgICAgIE51bWJlck5lZ2F0aXZlUGF0dGVybjogMSxcclxuICAgICAgICBQZXJjZW50UG9zaXRpdmVQYXR0ZXJuOiAwLFxyXG4gICAgICAgIFBlcmNlbnROZWdhdGl2ZVBhdHRlcm46IDAsXHJcbiAgICAgICAgTmVnYXRpdmVJbmZpbml0eVN5bWJvbDogXCItSW5maW5pdHlcIixcclxuICAgICAgICBOZWdhdGl2ZVNpZ246IFwiLVwiLFxyXG4gICAgICAgIE51bWJlckRlY2ltYWxEaWdpdHM6IDIsXHJcbiAgICAgICAgTnVtYmVyRGVjaW1hbFNlcGFyYXRvcjogXCIuXCIsXHJcbiAgICAgICAgTnVtYmVyR3JvdXBTZXBhcmF0b3I6IFwiLFwiLFxyXG4gICAgICAgIEN1cnJlbmN5UG9zaXRpdmVQYXR0ZXJuOiAwLFxyXG4gICAgICAgIFBvc2l0aXZlSW5maW5pdHlTeW1ib2w6IFwiSW5maW5pdHlcIixcclxuICAgICAgICBQb3NpdGl2ZVNpZ246IFwiK1wiLFxyXG4gICAgICAgIFBlcmNlbnREZWNpbWFsRGlnaXRzOiAyLFxyXG4gICAgICAgIFBlcmNlbnREZWNpbWFsU2VwYXJhdG9yOiBcIi5cIixcclxuICAgICAgICBQZXJjZW50R3JvdXBTZXBhcmF0b3I6IFwiLFwiLFxyXG4gICAgICAgIFBlcmNlbnRTeW1ib2w6IFwiJVwiLFxyXG4gICAgICAgIFBlck1pbGxlU3ltYm9sOiBcIlxcdTIwMzBcIixcclxuICAgICAgICBOYXRpdmVEaWdpdHM6IFtcIjBcIiwgXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIl0sXHJcbiAgICAgICAgRGlnaXRTdWJzdGl0dXRpb246IDFcclxuICAgIH0sXHJcbiAgICBkYXRlVGltZUZvcm1hdDoge1xyXG4gICAgICAgIEFNRGVzaWduYXRvcjogXCJBTVwiLFxyXG4gICAgICAgIENhbGVuZGFyOiB7IE1pblN1cHBvcnRlZERhdGVUaW1lOiBcIkAtNjIxMzU1NjgwMDAwMDBAXCIsIE1heFN1cHBvcnRlZERhdGVUaW1lOiBcIkAyNTM0MDIzMDA3OTk5OTlAXCIsIEFsZ29yaXRobVR5cGU6IDEsIENhbGVuZGFyVHlwZTogMSwgRXJhczogWzFdLCBUd29EaWdpdFllYXJNYXg6IDIwMjkgfSxcclxuICAgICAgICBEYXRlU2VwYXJhdG9yOiBcIi9cIixcclxuICAgICAgICBGaXJzdERheU9mV2VlazogMCxcclxuICAgICAgICBDYWxlbmRhcldlZWtSdWxlOiAwLFxyXG4gICAgICAgIEZ1bGxEYXRlVGltZVBhdHRlcm46IFwiZGRkZCwgZGQgTU1NTSB5eXl5IEhIOm1tOnNzXCIsXHJcbiAgICAgICAgTG9uZ0RhdGVQYXR0ZXJuOiBcImRkZGQsIGRkIE1NTU0geXl5eVwiLFxyXG4gICAgICAgIExvbmdUaW1lUGF0dGVybjogXCJISDptbTpzc1wiLFxyXG4gICAgICAgIE1vbnRoRGF5UGF0dGVybjogXCJNTU1NIGRkXCIsXHJcbiAgICAgICAgUE1EZXNpZ25hdG9yOiBcIlBNXCIsXHJcbiAgICAgICAgUkZDMTEyM1BhdHRlcm46IFwiZGRkLCBkZCBNTU0geXl5eSBISCc6J21tJzonc3MgJ0dNVCdcIixcclxuICAgICAgICBTaG9ydERhdGVQYXR0ZXJuOiBcIk1NL2RkL3l5eXlcIixcclxuICAgICAgICBTaG9ydFRpbWVQYXR0ZXJuOiBcImg6bW0gdHRcIixcclxuICAgICAgICBTb3J0YWJsZURhdGVUaW1lUGF0dGVybjogXCJ5eXl5Jy0nTU0nLSdkZCdUJ0hIJzonbW0nOidzc1wiLFxyXG4gICAgICAgIFRpbWVTZXBhcmF0b3I6IFwiOlwiLFxyXG4gICAgICAgIFVuaXZlcnNhbFNvcnRhYmxlRGF0ZVRpbWVQYXR0ZXJuOiBcInl5eXknLSdNTSctJ2RkIEhIJzonbW0nOidzcydaJ1wiLFxyXG4gICAgICAgIFllYXJNb250aFBhdHRlcm46IFwieXl5eSBNTU1NXCIsXHJcbiAgICAgICAgQWJicmV2aWF0ZWREYXlOYW1lczogW1wiU3VuXCIsIFwiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCJdLFxyXG4gICAgICAgIFNob3J0ZXN0RGF5TmFtZXM6IFtcIlN1XCIsIFwiTW9cIiwgXCJUdVwiLCBcIldlXCIsIFwiVGhcIiwgXCJGclwiLCBcIlNhXCJdLFxyXG4gICAgICAgIERheU5hbWVzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcclxuICAgICAgICBBYmJyZXZpYXRlZE1vbnRoTmFtZXM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiLCBcIlwiXSxcclxuICAgICAgICBNb250aE5hbWVzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiLCBcIlwiXSxcclxuICAgICAgICBOYXRpdmVDYWxlbmRhck5hbWU6IFwiR3JlZ29yaWFuIENhbGVuZGFyXCIsXHJcbiAgICAgICAgQWJicmV2aWF0ZWRNb250aEdlbml0aXZlTmFtZXM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiLCBcIlwiXSxcclxuICAgICAgICBNb250aEdlbml0aXZlTmFtZXM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCIsIFwiXCJdXHJcbiAgICB9LFxyXG4gICAgZXJhczogWzEsIFwiQS5ELlwiLCBudWxsLCAwXVxyXG59O1xyXG52YXIgQ3VsdHVyZUluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDdWx0dXJlSW5mbyhuYW1lLCBudW1iZXJGb3JtYXQsIGRhdGVUaW1lRm9ybWF0KSB7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLm51bWJlckZvcm1hdCA9IG51bWJlckZvcm1hdDtcclxuICAgICAgICB0aGlzLmRhdGVUaW1lRm9ybWF0ID0gZGF0ZVRpbWVGb3JtYXQ7XHJcbiAgICB9XHJcbiAgICBDdWx0dXJlSW5mby5wYXJzZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBkdGYgPSB2YWx1ZS5kYXRlVGltZUZvcm1hdDtcclxuICAgICAgICBpZiAoZHRmICYmICFkdGYuRXJhcykge1xyXG4gICAgICAgICAgICBkdGYuRXJhcyA9IHZhbHVlLmVyYXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ3VsdHVyZUluZm8odmFsdWUubmFtZSwgdmFsdWUubnVtYmVyRm9ybWF0LCBkdGYpO1xyXG4gICAgfTtcclxuICAgIEN1bHR1cmVJbmZvLnNldHVwID0gZnVuY3Rpb24gKGN1bHR1cmVJbmZvKSB7XHJcbiAgICAgICAgaWYgKGN1bHR1cmVJbmZvID09PSB2b2lkIDApIHsgY3VsdHVyZUluZm8gPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGN1bHR1cmVJbmZvICE9IG51bGwgJiYgdHlwZW9mIGN1bHR1cmVJbmZvID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIEN1bHR1cmVJbmZvLkN1cnJlbnRDdWx0dXJlID0gQ3VsdHVyZUluZm8ucGFyc2UoY3VsdHVyZUluZm8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghQ3VsdHVyZUluZm8uQ3VycmVudEN1bHR1cmUpIHtcclxuICAgICAgICAgICAgLy8gU2V0IHVwIGRlZmF1bHQgY3VsdHVyZVxyXG4gICAgICAgICAgICB2YXIgZGVmYXVsdEN1bHR1cmUgPSBDdWx0dXJlSW5mby5fZGVmYXVsdEN1bHR1cmU7XHJcbiAgICAgICAgICAgIGlmICghQ3VsdHVyZUluZm8uX2RlZmF1bHRDdWx0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VsdHVyZUluZm9PYmplY3QgPSBoZWxwZXJzXzEuY2xvbmUoaW52YXJpYW50Q3VsdHVyZUluZm8pO1xyXG4gICAgICAgICAgICAgICAgY3VsdHVyZUluZm9PYmplY3QubmFtZSA9IFwiZW4tVVNcIjtcclxuICAgICAgICAgICAgICAgIGN1bHR1cmVJbmZvT2JqZWN0Lm51bWJlckZvcm1hdC5DdXJyZW5jeVN5bWJvbCA9IFwiJFwiO1xyXG4gICAgICAgICAgICAgICAgdmFyIGR0ZiA9IGN1bHR1cmVJbmZvT2JqZWN0LmRhdGVUaW1lRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgZHRmLkZ1bGxEYXRlVGltZVBhdHRlcm4gPSBcImRkZGQsIE1NTU0gZGQsIHl5eXkgaDptbTpzcyB0dFwiO1xyXG4gICAgICAgICAgICAgICAgZHRmLkxvbmdEYXRlUGF0dGVybiA9IFwiZGRkZCwgTU1NTSBkZCwgeXl5eVwiO1xyXG4gICAgICAgICAgICAgICAgZHRmLkxvbmdUaW1lUGF0dGVybiA9IFwiaDptbTpzcyB0dFwiO1xyXG4gICAgICAgICAgICAgICAgZHRmLlNob3J0RGF0ZVBhdHRlcm4gPSBcIk0vZC95eXl5XCI7XHJcbiAgICAgICAgICAgICAgICBkdGYuU2hvcnRUaW1lUGF0dGVybiA9IFwiaDptbSB0dFwiO1xyXG4gICAgICAgICAgICAgICAgZHRmLlllYXJNb250aFBhdHRlcm4gPSBcIk1NTU0sIHl5eXlcIjtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRDdWx0dXJlID0gQ3VsdHVyZUluZm8ucGFyc2UoY3VsdHVyZUluZm9PYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgQ3VsdHVyZUluZm8uX2RlZmF1bHRDdWx0dXJlID0gZGVmYXVsdEN1bHR1cmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ3VsdHVyZUluZm8uQ3VycmVudEN1bHR1cmUgPSBkZWZhdWx0Q3VsdHVyZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ3VsdHVyZUluZm8ucHJvdG90eXBlLl9nZXREYXRlVGltZUZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdHMgPSB0aGlzLl9kYXRlVGltZUZvcm1hdHM7XHJcbiAgICAgICAgaWYgKCFmb3JtYXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBkdGYgPSB0aGlzLmRhdGVUaW1lRm9ybWF0O1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRlVGltZUZvcm1hdHMgPSBmb3JtYXRzID0gW1xyXG4gICAgICAgICAgICAgICAgZHRmW1wiTW9udGhEYXlQYXR0ZXJuXCJdLFxyXG4gICAgICAgICAgICAgICAgZHRmW1wiWWVhck1vbnRoUGF0dGVyblwiXSxcclxuICAgICAgICAgICAgICAgIGR0ZltcIlNob3J0RGF0ZVBhdHRlcm5cIl0sXHJcbiAgICAgICAgICAgICAgICBkdGZbXCJTaG9ydFRpbWVQYXR0ZXJuXCJdLFxyXG4gICAgICAgICAgICAgICAgZHRmW1wiTG9uZ0RhdGVQYXR0ZXJuXCJdLFxyXG4gICAgICAgICAgICAgICAgZHRmW1wiTG9uZ1RpbWVQYXR0ZXJuXCJdLFxyXG4gICAgICAgICAgICAgICAgZHRmW1wiRnVsbERhdGVUaW1lUGF0dGVyblwiXSxcclxuICAgICAgICAgICAgICAgIGR0ZltcIlJGQzExMjNQYXR0ZXJuXCJdLFxyXG4gICAgICAgICAgICAgICAgZHRmW1wiU29ydGFibGVEYXRlVGltZVBhdHRlcm5cIl0sXHJcbiAgICAgICAgICAgICAgICBkdGZbXCJVbml2ZXJzYWxTb3J0YWJsZURhdGVUaW1lUGF0dGVyblwiXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0cztcclxuICAgIH07XHJcbiAgICBDdWx0dXJlSW5mby5wcm90b3R5cGUuX2dldE1vbnRoSW5kZXggPSBmdW5jdGlvbiAodmFsdWUsIGFiYnIpIHtcclxuICAgICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBjYWNoZSBvZiB1cHBlci1jYXNlIG1vbnRoIG5hbWVzXHJcbiAgICAgICAgdmFyIHVwcGVyTW9udGhzID0gYWJiciA/IHRoaXMuX3VwcGVyQWJick1vbnRocyA6IHRoaXMuX3VwcGVyTW9udGhzO1xyXG4gICAgICAgIGlmICghdXBwZXJNb250aHMpIHtcclxuICAgICAgICAgICAgaWYgKGFiYnIpXHJcbiAgICAgICAgICAgICAgICB1cHBlck1vbnRocyA9IHRoaXMuX3VwcGVyQWJick1vbnRocyA9IHRvVXBwZXJBcnJheSh0aGlzLmRhdGVUaW1lRm9ybWF0LkFiYnJldmlhdGVkTW9udGhOYW1lcyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHVwcGVyTW9udGhzID0gdGhpcy5fdXBwZXJNb250aHMgPSB0b1VwcGVyQXJyYXkodGhpcy5kYXRlVGltZUZvcm1hdC5Nb250aE5hbWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbW9udGggbmFtZSB0byB1cHBlci1jYXNlIGFuZCBnZXQgaXRzIGluZGV4IGluIHRoZSBsaXN0XHJcbiAgICAgICAgdmFsdWUgPSB0b1VwcGVyKHZhbHVlKTtcclxuICAgICAgICB2YXIgaSA9IHVwcGVyTW9udGhzLmluZGV4T2YodmFsdWUpO1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICAvLyBHZXQgb3IgY3JlYXRlIHRoZSBjYWNoZSBvZiB1cHBlci1jYXNlIGdlbml0aXZlIG1vbnRoIG5hbWVzXHJcbiAgICAgICAgICAgIHZhciB1cHBlck1vbnRoc0dlbml0aXZlID0gYWJiciA/IHRoaXMuX3VwcGVyQWJick1vbnRoc0dlbml0aXZlIDogdGhpcy5fdXBwZXJNb250aHNHZW5pdGl2ZTtcclxuICAgICAgICAgICAgaWYgKCF1cHBlck1vbnRoc0dlbml0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWJicilcclxuICAgICAgICAgICAgICAgICAgICB1cHBlck1vbnRoc0dlbml0aXZlID0gdGhpcy5fdXBwZXJBYmJyTW9udGhzR2VuaXRpdmUgPSB0b1VwcGVyQXJyYXkodGhpcy5kYXRlVGltZUZvcm1hdC5BYmJyZXZpYXRlZE1vbnRoR2VuaXRpdmVOYW1lcyk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJNb250aHNHZW5pdGl2ZSA9IHRoaXMuX3VwcGVyTW9udGhzR2VuaXRpdmUgPSB0b1VwcGVyQXJyYXkodGhpcy5kYXRlVGltZUZvcm1hdC5Nb250aEdlbml0aXZlTmFtZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBsaXN0IG9mIGdlbml0aXZlIG1vbnRoIG5hbWVzXHJcbiAgICAgICAgICAgIGkgPSB1cHBlck1vbnRoc0dlbml0aXZlLmluZGV4T2YodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaTtcclxuICAgIH07XHJcbiAgICBDdWx0dXJlSW5mby5wcm90b3R5cGUuX2dldERheUluZGV4ID0gZnVuY3Rpb24gKHZhbHVlLCBhYmJyKSB7XHJcbiAgICAgICAgLy8gR2V0IG9yIGNyZWF0ZSB0aGUgY2FjaGUgb2YgdXBwZXItY2FzZSBkYXkgbmFtZXNcclxuICAgICAgICB2YXIgdXBwZXJEYXlzID0gYWJiciA/IHRoaXMuX3VwcGVyQWJickRheXMgOiB0aGlzLl91cHBlckRheXM7XHJcbiAgICAgICAgaWYgKCF1cHBlckRheXMpIHtcclxuICAgICAgICAgICAgaWYgKGFiYnIpXHJcbiAgICAgICAgICAgICAgICB1cHBlckRheXMgPSB0aGlzLl91cHBlckFiYnJEYXlzID0gdG9VcHBlckFycmF5KHRoaXMuZGF0ZVRpbWVGb3JtYXQuQWJicmV2aWF0ZWREYXlOYW1lcyk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHVwcGVyRGF5cyA9IHRoaXMuX3VwcGVyRGF5cyA9IHRvVXBwZXJBcnJheSh0aGlzLmRhdGVUaW1lRm9ybWF0LkRheU5hbWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgZGF5IG5hbWUgdG8gdXBwZXItY2FzZSBhbmQgZ2V0IGl0cyBpbmRleCBpbiB0aGUgbGlzdFxyXG4gICAgICAgIHZhbHVlID0gdG9VcHBlcih2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHVwcGVyRGF5cy5pbmRleE9mKHZhbHVlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ3VsdHVyZUluZm87XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ3VsdHVyZUluZm8gPSBDdWx0dXJlSW5mbztcclxuQ3VsdHVyZUluZm8uSW52YXJpYW50Q3VsdHVyZSA9IEN1bHR1cmVJbmZvLnBhcnNlKGludmFyaWFudEN1bHR1cmVJbmZvKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5lbnRyaWVzID0gZXhwb3J0cy5mbGF0TWFwID0gZXhwb3J0cy5jbG9uZSA9IGV4cG9ydHMubWl4aW4gPSBleHBvcnRzLmdldEV2ZW50U3Vic2NyaXB0aW9ucyA9IGV4cG9ydHMubWVyZ2UgPSBleHBvcnRzLmhhc093blByb3BlcnR5ID0gZXhwb3J0cy50b1RpdGxlQ2FzZSA9IGV4cG9ydHMucmFuZG9tVGV4dCA9IGV4cG9ydHMucmFuZG9tSW50ID0gZXhwb3J0cy5pc1R5cGUgPSBleHBvcnRzLmdldERlZmF1bHRWYWx1ZSA9IGV4cG9ydHMuaXNOdW1iZXIgPSBleHBvcnRzLmdldENvbnN0cnVjdG9yTmFtZSA9IGV4cG9ydHMuZ2V0VHlwZU5hbWUgPSBleHBvcnRzLnBhcnNlRnVuY3Rpb25OYW1lID0gZXhwb3J0cy5yZXBsYWNlVG9rZW5zID0gZXhwb3J0cy5ldmFsUGF0aCA9IGV4cG9ydHMubmF2aWdhdGVBdHRyaWJ1dGUgPSBleHBvcnRzLmVuc3VyZU5hbWVzcGFjZSA9IGV4cG9ydHMuZ2V0R2xvYmFsT2JqZWN0ID0gdm9pZCAwO1xyXG5mdW5jdGlvbiBnZXRHbG9iYWxPYmplY3QoKSB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2luZG93KSA9PT0gXCJbb2JqZWN0IFdpbmRvd11cIikge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZ2V0R2xvYmFsT2JqZWN0ID0gZ2V0R2xvYmFsT2JqZWN0O1xyXG5mdW5jdGlvbiBlbnN1cmVOYW1lc3BhY2UobmFtZSwgcGFyZW50TmFtZXNwYWNlKSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgdmFyIG5zVG9rZW5zO1xyXG4gICAgdmFyIHRhcmdldCA9IHBhcmVudE5hbWVzcGFjZTtcclxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgbnNUb2tlbnMgPSB0YXJnZXQuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgIHRhcmdldCA9IGdldEdsb2JhbE9iamVjdCgpO1xyXG4gICAgICAgIG5zVG9rZW5zLmZvckVhY2goZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldFt0b2tlbl07XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IG5hbWVzcGFjZSBcXFwiXCIgKyBwYXJlbnROYW1lc3BhY2UgKyBcIlxcXCIgY291bGQgbm90IGJlIGZvdW5kLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFyZ2V0ID09PSB1bmRlZmluZWQgfHwgdGFyZ2V0ID09PSBudWxsKSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gZ2V0R2xvYmFsT2JqZWN0KCk7XHJcbiAgICB9XHJcbiAgICAvLyBjcmVhdGUgdGhlIG5hbWVzcGFjZSBvYmplY3QgaWYgaXQgZG9lc24ndCBleGlzdCwgb3RoZXJ3aXNlIHJldHVybiB0aGUgZXhpc3RpbmcgbmFtZXNwYWNlXHJcbiAgICBpZiAoIShuYW1lIGluIHRhcmdldCkpIHtcclxuICAgICAgICByZXN1bHQgPSB0YXJnZXRbbmFtZV0gPSB7fTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmVuc3VyZU5hbWVzcGFjZSA9IGVuc3VyZU5hbWVzcGFjZTtcclxuZnVuY3Rpb24gbmF2aWdhdGVBdHRyaWJ1dGUob2JqLCBhdHRyLCBjYWxsYmFjaywgdGhpc1B0cikge1xyXG4gICAgaWYgKHRoaXNQdHIgPT09IHZvaWQgMCkgeyB0aGlzUHRyID0gbnVsbDsgfVxyXG4gICAgZm9yICh2YXIgdmFsID0gb2JqW2F0dHJdOyB2YWwgIT0gbnVsbDsgdmFsID0gdmFsW2F0dHJdKSB7XHJcbiAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc1B0ciB8fCBvYmosIHZhbCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5uYXZpZ2F0ZUF0dHJpYnV0ZSA9IG5hdmlnYXRlQXR0cmlidXRlO1xyXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcclxuICAgIHJldHVybiBnZXRUeXBlTmFtZShvYmopID09PSBcIm9iamVjdFwiIHx8IChvYmogJiYgb2JqIGluc3RhbmNlb2YgT2JqZWN0KTtcclxufVxyXG4vLyBJZiBhIGdldHRlciBtZXRob2QgbWF0Y2hpbmcgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgaXMgZm91bmQgb24gdGhlIHRhcmdldCBpdCBpcyBpbnZva2VkIGFuZCByZXR1cm5zIHRoZVxyXG4vLyB2YWx1ZSwgdW5sZXNzIHRoZSB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG51bGwgaXMgcmV0dXJuZWQgaW5zdGVhZC4gIFRoaXMgaXMgZG9uZSBzbyB0aGF0XHJcbi8vIGNhbGxpbmcgY29kZSBjYW4gaW50ZXJwcmV0IGEgcmV0dXJuIHZhbHVlIG9mIHVuZGVmaW5lZCB0byBtZWFuIHRoYXQgdGhlIHByb3BlcnR5IGl0IHJlcXVlc3RlZCBkb2VzIG5vdCBleGlzdC5cclxuZnVuY3Rpb24gZ2V0VmFsdWUodGFyZ2V0LCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHZhbHVlO1xyXG4gICAgLy8gdGhlIHNlZSBpZiB0aGVyZSBpcyBhbiBleHBsaWNpdCBnZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBwcm9wZXJ0eVxyXG4gICAgdmFyIGdldHRlciA9IHRhcmdldFtcImdldF9cIiArIHByb3BlcnR5XTtcclxuICAgIGlmIChnZXR0ZXIpIHtcclxuICAgICAgICB2YWx1ZSA9IGdldHRlci5jYWxsKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIG90aGVyd2lzZSBzZWFyY2ggZm9yIHRoZSBwcm9wZXJ0eVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKChpc09iamVjdCh0YXJnZXQpICYmIHByb3BlcnR5IGluIHRhcmdldCkgfHxcclxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcGVydHkpIHx8XHJcbiAgICAgICAgICAgICh0YXJnZXQuY29uc3RydWN0b3IgPT09IFN0cmluZyAmJiAvXlswLTldKyQvLnRlc3QocHJvcGVydHkpICYmIHBhcnNlSW50KHByb3BlcnR5LCAxMCkgPCB0YXJnZXQubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRhcmdldFtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoL1xcLi8udGVzdChwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogV2FybiBhYm91dCBwYXNzaW5nIG11bHRpLWhvcCBwYXRoIHRvIGBnZXRWYWx1ZSgpYFxyXG4gICAgICAgICAgICAvLyBsb2dXYXJuaW5nKFwiUG9zc2libGUgaW5jb3JyZWN0IHVzYWdlIG9mIFxcXCJnZXRWYWx1ZSgpXFxcIiwgdGhlIHBhdGggXFxcIlwiICsgcHJvcGVydHkgKyBcIlxcXCIgZG9lcyBub3QgZXhpc3Qgb24gdGhlIHRhcmdldCBhbmQgYXBwZWFycyB0byByZXByZXNlbnQgYSBtdWx0aS1ob3AgcGF0aC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGV2YWxQYXRoKG9iaiwgcGF0aCwgbnVsbFZhbHVlLCB1bmRlZmluZWRWYWx1ZSkge1xyXG4gICAgaWYgKG51bGxWYWx1ZSA9PT0gdm9pZCAwKSB7IG51bGxWYWx1ZSA9IG51bGw7IH1cclxuICAgIGlmICh1bmRlZmluZWRWYWx1ZSA9PT0gdm9pZCAwKSB7IHVuZGVmaW5lZFZhbHVlID0gdW5kZWZpbmVkOyB9XHJcbiAgICB2YXIgdmFsdWUgPSBvYmo7XHJcbiAgICB2YXIgc3RlcHMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICB2YXIgbmFtZV8xID0gc3RlcHNbaV07XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gZ2V0VmFsdWUoc291cmNlLCBuYW1lXzEpO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmV4cG9ydHMuZXZhbFBhdGggPSBldmFsUGF0aDtcclxuLyoqXHJcbiAqIFJlcGxhY2UgdG9rZW5zIChleDogezB9KSBpbiB0aGUgZ2l2ZW4gc3RyaW5nXHJcbiAqIEBwYXJhbSB0ZW1wbGF0ZSBUaGUgdGVtcGxhdGUgc3RyaW5nXHJcbiAqIEBwYXJhbSBwYXJhbXMgVGhlIHJlcGxhY2VtZW50IHBhcmFtZXRlcnNcclxuICovXHJcbmZ1bmN0aW9uIHJlcGxhY2VUb2tlbnModGVtcGxhdGUsIHBhcmFtcykge1xyXG4gICAgaWYgKHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZS5yZXBsYWNlKC97KFtefV0rKX0vZywgZnVuY3Rpb24gKG1hdGNoLCBrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5KHBhcmFtcywga2V5KSA/IHBhcmFtc1trZXldIDogbWF0Y2g7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVtcGxhdGU7XHJcbn1cclxuZXhwb3J0cy5yZXBsYWNlVG9rZW5zID0gcmVwbGFjZVRva2VucztcclxudmFyIGZuUmVnZXggPSAvZnVuY3Rpb25cXHMqKFtcXHdfJF0qKS9pO1xyXG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uTmFtZShmbikge1xyXG4gICAgdmFyIGZuTWF0Y2ggPSBmblJlZ2V4LmV4ZWMoZm4udG9TdHJpbmcoKSk7XHJcbiAgICByZXR1cm4gZm5NYXRjaCA/IChmbk1hdGNoWzFdIHx8IFwie2Fub255bW91c31cIikgOiBcInthbm9ueW1vdXN9XCI7XHJcbn1cclxuZXhwb3J0cy5wYXJzZUZ1bmN0aW9uTmFtZSA9IHBhcnNlRnVuY3Rpb25OYW1lO1xyXG52YXIgdHlwZU5hbWVFeHByID0gL1xccyhbYS16fEEtWl0rKS87XHJcbmZ1bmN0aW9uIGdldFR5cGVOYW1lKG9iaikge1xyXG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xyXG4gICAgaWYgKG9iaiA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gXCJudWxsXCI7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikubWF0Y2godHlwZU5hbWVFeHByKVsxXS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbmV4cG9ydHMuZ2V0VHlwZU5hbWUgPSBnZXRUeXBlTmFtZTtcclxuZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JOYW1lKGN0b3IpIHtcclxuICAgIC8vIEhhbmRsZSB2YWx1ZSB0eXBlcyBleHBsaWNpdGx5XHJcbiAgICBpZiAoY3RvciA9PT0gU3RyaW5nKVxyXG4gICAgICAgIHJldHVybiBcIlN0cmluZ1wiO1xyXG4gICAgaWYgKGN0b3IgPT09IE51bWJlcilcclxuICAgICAgICByZXR1cm4gXCJOdW1iZXJcIjtcclxuICAgIGlmIChjdG9yID09PSBEYXRlKVxyXG4gICAgICAgIHJldHVybiBcIkRhdGVcIjtcclxuICAgIGlmIChjdG9yID09PSBCb29sZWFuKVxyXG4gICAgICAgIHJldHVybiBcIkJvb2xlYW5cIjtcclxuICAgIC8vIFRyeSB0byB1c2UgZnVuY3Rpb24gbmFtZVxyXG4gICAgaWYgKHR5cGVvZiBjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgY3Rvci5uYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGN0b3IubmFtZTtcclxuICAgIH1cclxuICAgIC8vIEZhbGwgYmFjayB0byB0aGUgbG93LWxldmVsICd0b1N0cmluZycgb24gdGhlIHByb3RvdHlwZVxyXG4gICAgcmV0dXJuIGdldFR5cGVOYW1lKGN0b3IucHJvdG90eXBlKTtcclxufVxyXG5leHBvcnRzLmdldENvbnN0cnVjdG9yTmFtZSA9IGdldENvbnN0cnVjdG9yTmFtZTtcclxuZnVuY3Rpb24gaXNOdW1iZXIob2JqKSB7XHJcbiAgICByZXR1cm4gZ2V0VHlwZU5hbWUob2JqKSA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ob2JqKTtcclxufVxyXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRWYWx1ZShpc0xpc3QsIGpzdHlwZSkge1xyXG4gICAgaWYgKGlzTGlzdClcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICBpZiAoanN0eXBlID09PSBCb29sZWFuKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChqc3R5cGUgPT09IE51bWJlcilcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmV4cG9ydHMuZ2V0RGVmYXVsdFZhbHVlID0gZ2V0RGVmYXVsdFZhbHVlO1xyXG5mdW5jdGlvbiBpc1R5cGUob2JqLCB0ZXN0KSB7XHJcbiAgICBpZiAodGVzdCA9PT0gdm9pZCAwKSB7IHRlc3QgPSBudWxsOyB9XHJcbiAgICBpZiAodGVzdCkge1xyXG4gICAgICAgIHJldHVybiB0ZXN0KG9iaik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nLCBhc3N1bWUgb2JqZWN0IGlzIG9mIHRoZSB0eXBlXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5pc1R5cGUgPSBpc1R5cGU7XHJcbmZ1bmN0aW9uIHJhbmRvbUludChtaW4sIG1heCkge1xyXG4gICAgaWYgKG1pbiA9PT0gdm9pZCAwKSB7IG1pbiA9IDA7IH1cclxuICAgIGlmIChtYXggPT09IHZvaWQgMCkgeyBtYXggPSA5OyB9XHJcbiAgICB2YXIgcmFuZCA9IE1hdGgucmFuZG9tKCk7XHJcbiAgICByZXR1cm4gcmFuZCA9PT0gMSA/IG1heCA6IE1hdGguZmxvb3IocmFuZCAqIChtYXggLSBtaW4gKyAxKSkgKyBtaW47XHJcbn1cclxuZXhwb3J0cy5yYW5kb21JbnQgPSByYW5kb21JbnQ7XHJcbmZ1bmN0aW9uIHJhbmRvbVRleHQobGVuLCBpbmNsdWRlTGV0dGVycywgaW5jbHVkZURpZ2l0cykge1xyXG4gICAgaWYgKGluY2x1ZGVMZXR0ZXJzID09PSB2b2lkIDApIHsgaW5jbHVkZUxldHRlcnMgPSB0cnVlOyB9XHJcbiAgICBpZiAoaW5jbHVkZURpZ2l0cyA9PT0gdm9pZCAwKSB7IGluY2x1ZGVEaWdpdHMgPSB0cnVlOyB9XHJcbiAgICBpZiAoIWluY2x1ZGVMZXR0ZXJzICYmICFpbmNsdWRlRGlnaXRzKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgdmFyIG1pbiA9IGluY2x1ZGVMZXR0ZXJzID8gMCA6IDI2O1xyXG4gICAgICAgIHZhciBtYXggPSBpbmNsdWRlRGlnaXRzID8gMzUgOiAyNTtcclxuICAgICAgICB2YXIgcmFuZCA9IHJhbmRvbUludChtaW4sIG1heCk7XHJcbiAgICAgICAgdmFyIGNoYXJDb2RlO1xyXG4gICAgICAgIGlmIChyYW5kIDw9IDI1KSB7XHJcbiAgICAgICAgICAgIC8vIEFscGhhOiBhZGQgOTcgZm9yICdhJ1xyXG4gICAgICAgICAgICBjaGFyQ29kZSA9IHJhbmQgKyA5NztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE51bTogc3RhcnQgYXQgMCBhbmQgYWRkIDQ4IGZvciAwXHJcbiAgICAgICAgICAgIGNoYXJDb2RlID0gKHJhbmQgLSAyNikgKyA0ODtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5leHBvcnRzLnJhbmRvbVRleHQgPSByYW5kb21UZXh0O1xyXG5mdW5jdGlvbiB0b1RpdGxlQ2FzZShpbnB1dCkge1xyXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTk2OTcyL2NvbnZlcnQtc3RyaW5nLXRvLXRpdGxlLWNhc2Utd2l0aC1qYXZhc2NyaXB0LzY0NzUxMjUjNjQ3NTEyNVxyXG4gICAgdmFyIGksIGosIHN0ciwgbG93ZXJzLCB1cHBlcnM7XHJcbiAgICBzdHIgPSBpbnB1dC5yZXBsYWNlKC8oW15cXFdfXStbXlxccy1dKikgKi9nLCBmdW5jdGlvbiAodHh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHR4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR4dC5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKTtcclxuICAgIH0pO1xyXG4gICAgLy8gQ2VydGFpbiBtaW5vciB3b3JkcyBzaG91bGQgYmUgbGVmdCBsb3dlcmNhc2UgdW5sZXNzXHJcbiAgICAvLyB0aGV5IGFyZSB0aGUgZmlyc3Qgb3IgbGFzdCB3b3JkcyBpbiB0aGUgc3RyaW5nXHJcbiAgICBsb3dlcnMgPSBbXCJBXCIsIFwiQW5cIiwgXCJUaGVcIiwgXCJBbmRcIiwgXCJCdXRcIiwgXCJPclwiLCBcIkZvclwiLCBcIk5vclwiLCBcIkFzXCIsIFwiQXRcIixcclxuICAgICAgICBcIkJ5XCIsIFwiRm9yXCIsIFwiRnJvbVwiLCBcIkluXCIsIFwiSW50b1wiLCBcIk5lYXJcIiwgXCJPZlwiLCBcIk9uXCIsIFwiT250b1wiLFxyXG4gICAgICAgIFwiVG9cIiwgXCJXaXRoXCJdO1xyXG4gICAgZm9yIChpID0gMCwgaiA9IGxvd2Vycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXHNcIiArIGxvd2Vyc1tpXSArIFwiXFxcXHNcIiwgXCJnXCIpLCBmdW5jdGlvbiAodHh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eHQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8vIENlcnRhaW4gd29yZHMgc3VjaCBhcyBpbml0aWFsaXNtcyBvciBhY3JvbnltcyBzaG91bGQgYmUgbGVmdCB1cHBlcmNhc2VcclxuICAgIHVwcGVycyA9IFtcIklkXCIsIFwiVHZcIl07XHJcbiAgICBmb3IgKGkgPSAwLCBqID0gdXBwZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgdXBwZXJzW2ldICsgXCJcXFxcYlwiLCBcImdcIiksIHVwcGVyc1tpXS50b1VwcGVyQ2FzZSgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHI7XHJcbn1cclxuZXhwb3J0cy50b1RpdGxlQ2FzZSA9IHRvVGl0bGVDYXNlO1xyXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcclxufVxyXG5leHBvcnRzLmhhc093blByb3BlcnR5ID0gaGFzT3duUHJvcGVydHk7XHJcbmZ1bmN0aW9uIG1lcmdlKG9iajEpIHtcclxuICAgIHZhciBvYmpzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIG9ianNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgdGFyZ2V0ID0ge307XHJcbiAgICBmb3IgKHZhciBhcmcgaW4gb2JqMSkge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShvYmoxLCBhcmcpKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFthcmddID0gb2JqMVthcmddO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBvYmogPSBvYmpzW2ldO1xyXG4gICAgICAgIGZvciAodmFyIGFyZyBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2FyZ10gPSBvYmpbYXJnXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xyXG5mdW5jdGlvbiBnZXRFdmVudFN1YnNjcmlwdGlvbnMoZXZlbnQpIHtcclxuICAgIHZhciBmdW5jID0gZXZlbnQuZnVuYztcclxuICAgIGlmIChmdW5jKSB7XHJcbiAgICAgICAgdmFyIGZ1bmNzID0gZnVuYy5fZnVuY3M7XHJcbiAgICAgICAgaWYgKGZ1bmNzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIHN1YnMgPSBmdW5jcy5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHsgaGFuZGxlcjogZi5mbiwgaXNFeGVjdXRlZDogZi5hcHBsaWVkLCBpc09uY2U6IGYub25jZSB9OyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHN1YnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZXRFdmVudFN1YnNjcmlwdGlvbnMgPSBnZXRFdmVudFN1YnNjcmlwdGlvbnM7XHJcbmZ1bmN0aW9uIG1peGluKGN0b3IsIG1ldGhvZHMpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5KG1ldGhvZHMsIGtleSkgJiYgbWV0aG9kc1trZXldIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgY3Rvci5wcm90b3R5cGVba2V5XSA9IG1ldGhvZHNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5taXhpbiA9IG1peGluO1xyXG4vKipcclxuICogUmVjdXJzaXZlbHkgY2xvbmUgYW4gb2JqZWN0IGFuZCBpdHMgY2hpbGRyZW5cclxuICogQHBhcmFtIHZhbHVlIFRoZSBvYmplY3QgdG8gY2xvbmVcclxuICovXHJcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSkge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XHJcbiAgICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IHZhbHVlIGluc3RhbmNlb2YgQXJyYXkgPyAodmFsdWUubGVuZ3RoID09PSAxID8gW3ZhbHVlWzBdXSA6IEFycmF5LmFwcGx5KG51bGwsIHZhbHVlKSkgOiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBjbG9uZSh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcclxuLyoqXHJcbiAqIEhlbHBlciBhbHRlcm5hdGl2ZSB0byBBcnJheS5wcm90b3R5cGUuZmxhdE1hcFxyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9mbGF0TWFwI0FsdGVybmF0aXZlXHJcbiAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgYXJyYXlcclxuICogQHBhcmFtIGNhbGxiYWNrIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5IG9mIG91dHB1dHMgZm9yIGVhY2ggaW5wdXRcclxuICovXHJcbmZ1bmN0aW9uIGZsYXRNYXAoaW5wdXQsIGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gaW5wdXQucmVkdWNlKGZ1bmN0aW9uIChhcnIsIGkpIHsgcmV0dXJuIGFyci5jb25jYXQoY2FsbGJhY2soaSkpOyB9LCBbXSk7XHJcbn1cclxuZXhwb3J0cy5mbGF0TWFwID0gZmxhdE1hcDtcclxuLyoqXHJcbiAqIEhlbHBlciBhbHRlcm5hdGl2ZSB0byBPYmplY3QuZW50cmllc1xyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvZW50cmllcyNQb2x5ZmlsbFxyXG4gKiBAcGFyYW0gaW5wdXQgVGhlIGlucHV0IGFycmF5XHJcbiAqL1xyXG5mdW5jdGlvbiBlbnRyaWVzKG9iaikge1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG9uZS12YXJcclxuICAgIHZhciBvd25Qcm9wcyA9IE9iamVjdC5rZXlzKG9iaiksIGkgPSBvd25Qcm9wcy5sZW5ndGgsIHJlc0FycmF5ID0gbmV3IEFycmF5KGkpOyAvLyBwcmVhbGxvY2F0ZSB0aGUgQXJyYXlcclxuICAgIHdoaWxlIChpLS0pXHJcbiAgICAgICAgcmVzQXJyYXlbaV0gPSBbb3duUHJvcHNbaV0sIG9ialtvd25Qcm9wc1tpXV1dO1xyXG4gICAgcmV0dXJuIHJlc0FycmF5O1xyXG59XHJcbmV4cG9ydHMuZW50cmllcyA9IGVudHJpZXM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSkpO1xyXG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gQ29yZSBtb2RlbFxyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbW9kZWxcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZVwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm9wZXJ0eVwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm9wZXJ0eS1jaGFpblwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm9wZXJ0eS1wYXRoXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VudGl0eVwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vYmplY3QtbWV0YVwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mb3JtYXRcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2JzZXJ2YWJsZS1hcnJheVwiKSwgZXhwb3J0cyk7XHJcbi8vIENvbmRpdGlvbnMsIGV0Yy5cclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbmRpdGlvbi10YXJnZXRcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uZGl0aW9uLXR5cGUtc2V0XCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbmRpdGlvbi10eXBlXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbmRpdGlvblwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mb3JtYXQtZXJyb3JcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RyaW5nLWZvcm1hdC1ydWxlXCIpLCBleHBvcnRzKTtcclxuLy8gUnVsZXMgZW5naW5lIGFuZCB2YXJpb3VzIHJ1bGUgdHlwZXNcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3J1bGVcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcnVsZS1pbnZvY2F0aW9uLXR5cGVcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29uZGl0aW9uLXJ1bGVcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdmFsaWRhdGlvbi1ydWxlXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FsbG93ZWQtdmFsdWVzLXJ1bGVcIiksIGV4cG9ydHMpO1xyXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY2FsY3VsYXRlZC1wcm9wZXJ0eS1ydWxlXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JlcXVpcmVkLXJ1bGVcIiksIGV4cG9ydHMpO1xyXG4vLyBTZXJpYWxpemF0aW9uXHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbnRpdHktc2VyaWFsaXplclwiKSwgZXhwb3J0cyk7XHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbml0aWxpemF0aW9uLWNvbnRleHRcIiksIGV4cG9ydHMpO1xyXG4vLyBHbG9iYWxpemF0aW9uICYgTG9jYWxpemF0aW9uXHJcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nbG9iYWxpemF0aW9uXCIpLCBleHBvcnRzKTtcclxuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jlc291cmNlXCIpLCBleHBvcnRzKTtcclxuLy8gSW50ZXJuYWwgaGVscGVycywgZXRjLlxyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9ldmVudC1zY29wZVwiO1xyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9ldmVudHNcIjtcclxuLy8gZXhwb3J0ICogZnJvbSBcIi4vZnVuY3RvclwiO1xyXG4vLyBleHBvcnQgKiBmcm9tIFwiLi9oZWxwZXJzXCI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuSW5pdGlhbGl6YXRpb25Db250ZXh0ID0gdm9pZCAwO1xyXG52YXIgSW5pdGlhbGl6YXRpb25Db250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6YXRpb25Db250ZXh0KG5ld0RvY3VtZW50KSB7XHJcbiAgICAgICAgdGhpcy5uZXdEb2N1bWVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGFza3MgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy53YWl0aW5nID0gW107XHJcbiAgICAgICAgdGhpcy5uZXdEb2N1bWVudCA9IG5ld0RvY3VtZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2ZW50cyBhbnkgd2FpdGluZyBjYWxsYmFja3MgZnJvbSBiZWluZyBleGVjdXRlZCBiZWZvcmUgdGhlIHNwZWNpZmllZCBhY3Rpb24gY29tcGxldGVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIHJldHVybiB2YWx1ZSBvZiBgYWN0aW9uYC5cclxuICAgICAqL1xyXG4gICAgSW5pdGlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKGFjdGlvbikge1xyXG4gICAgICAgIC8vIGNyZWF0ZSBhIHByb21pc2Ugd2hpY2ggd2lsbCBuZXZlciBhY3R1YWxseSBiZSByZXNvbHZlZCwgYnV0IGl0IHdpbGwgcHJldmVudCB0aGUgd2FpdGluZyBxdWV1ZSBmcm9tIGJlaW5nIHByb2Nlc3NlZFxyXG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAoKSB7IH0pO1xyXG4gICAgICAgIHRoaXMudGFza3MuYWRkKG1hcmtlcik7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGFjdGlvbigpO1xyXG4gICAgICAgIHRoaXMudGFza3MuZGVsZXRlKG1hcmtlcik7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzV2FpdGluZ1F1ZXVlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBJbml0aWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLndhaXQgPSBmdW5jdGlvbiAodGFzaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy50YXNrcy5hZGQodGFzayk7XHJcbiAgICAgICAgdGFzay50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gcHJvY2VzcyB0aGUgcXVldWUgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgYWRkaXRpb25hbCB0YXNrcyB0byBiZSBxdWV1ZWQgYXMgYSByZXN1bHQgb2YgdGhpcyBvbmVcclxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy50YXNrcy5kZWxldGUodGFzayk7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9jZXNzV2FpdGluZ1F1ZXVlKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbml0aWFsaXphdGlvbkNvbnRleHQucHJvdG90eXBlLCBcImNhblByb2Nlc3NRdWV1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhc2tzLnNpemUgPT09IDA7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgSW5pdGlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS5wcm9jZXNzV2FpdGluZ1F1ZXVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNhblByb2Nlc3NRdWV1ZSkge1xyXG4gICAgICAgICAgICB3aGlsZSAodGhpcy53YWl0aW5nLmxlbmd0aCA+IDAgJiYgdGhpcy5jYW5Qcm9jZXNzUXVldWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkb25lID0gdGhpcy53YWl0aW5nLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBkb25lKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS53aGVuUmVhZHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodGhpcy5jYW5Qcm9jZXNzUXVldWUpXHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLndhaXRpbmcucHVzaChjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgSW5pdGlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZS50cnlSZXNvbHZlVmFsdWUgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciB0YXNrID0gaW5zdGFuY2Uuc2VyaWFsaXplci5yZXNvbHZlVmFsdWUoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHRhc2spXHJcbiAgICAgICAgICAgIHRoaXMud2FpdCh0YXNrKTtcclxuICAgICAgICByZXR1cm4gdGFzaztcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW5pdGlhbGl6YXRpb25Db250ZXh0LnByb3RvdHlwZSwgXCJpc05ld0RvY3VtZW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3RG9jdW1lbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEluaXRpYWxpemF0aW9uQ29udGV4dC5wcm90b3R5cGUsIFwicmVhZHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmV0dXJuIF90aGlzLndoZW5SZWFkeShyZXNvbHZlKTsgfSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIEluaXRpYWxpemF0aW9uQ29udGV4dDtcclxufSgpKTtcclxuZXhwb3J0cy5Jbml0aWFsaXphdGlvbkNvbnRleHQgPSBJbml0aWFsaXphdGlvbkNvbnRleHQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkxpc3RMZW5ndGhSdWxlID0gdm9pZCAwO1xyXG52YXIgdmFsaWRhdGlvbl9ydWxlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uLXJ1bGVcIik7XHJcbnZhciBMaXN0TGVuZ3RoUnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhMaXN0TGVuZ3RoUnVsZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RMZW5ndGhSdWxlKHJvb3RUeXBlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBlbnN1cmUgdGhlIHJ1bGUgbmFtZSBpcyBzcGVjaWZpZWRcclxuICAgICAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgXCJMaXN0TGVuZ3RoXCI7XHJcbiAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB7fTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWluICYmIG9wdGlvbnMubWluIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubWluID0gb3B0aW9ucy5taW4uY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lsZW50bHkgaWdub3JlIG1pbiBlcnJvcnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9wdGlvbnMubWluKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UubWluID0gb3B0aW9ucy5taW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF4ICYmIG9wdGlvbnMubWF4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubWF4ID0gb3B0aW9ucy5tYXguY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lsZW50bHkgaWdub3JlIG1heCBlcnJvcnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG9wdGlvbnMubWluKSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgcmFuZ2UubWluID0gb3B0aW9ucy5taW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbCA9IG9wdGlvbnMucHJvcGVydHkudmFsdWUodGhpcyk7XHJcbiAgICAgICAgICAgIGlmICghdmFsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKHJhbmdlLm1pbiA9PSBudWxsIHx8IHZhbC5sZW5ndGggPj0gcmFuZ2UubWluKSAmJiAocmFuZ2UubWF4ID09IG51bGwgfHwgdmFsLmxlbmd0aCA8PSByYW5nZS5tYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBWYWx1ZSBpcyB3aXRoaW4gcmFuZ2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5taW4gIT0gbnVsbCAmJiByYW5nZS5tYXggIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiByb290VHlwZS5tb2RlbC5nZXRSZXNvdXJjZShcImxpc3RsZW5ndGgtYmV0d2VlblwiKS5yZXBsYWNlKFwie21pbn1cIiwgcmFuZ2UubWluLnRvU3RyaW5nKCkpLnJlcGxhY2UoXCJ7bWF4fVwiLCByYW5nZS5tYXgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIGlmIChyYW5nZS5taW4gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiByb290VHlwZS5tb2RlbC5nZXRSZXNvdXJjZShcImxpc3RsZW5ndGgtYXQtbGVhc3RcIikucmVwbGFjZShcInttaW59XCIsIHJhbmdlLm1pbi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RUeXBlLm1vZGVsLmdldFJlc291cmNlKFwibGlzdGxlbmd0aC1hdC1tb3N0XCIpLnJlcGxhY2UoXCJ7bWF4fVwiLCByYW5nZS5tYXgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBjYWxsIHRoZSBiYXNlIHR5cGUgY29uc3RydWN0b3JcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RUeXBlLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBMaXN0TGVuZ3RoUnVsZTtcclxufSh2YWxpZGF0aW9uX3J1bGVfMS5WYWxpZGF0aW9uUnVsZSkpO1xyXG5leHBvcnRzLkxpc3RMZW5ndGhSdWxlID0gTGlzdExlbmd0aFJ1bGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5Nb2RlbFNldHRpbmdzID0gZXhwb3J0cy5jcmVhdGVNb2RlbCA9IGV4cG9ydHMuTW9kZWwgPSB2b2lkIDA7XHJcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcclxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XHJcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xyXG52YXIgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XHJcbnZhciBlbnRpdHlfc2VyaWFsaXplcl8xID0gcmVxdWlyZShcIi4vZW50aXR5LXNlcmlhbGl6ZXJcIik7XHJcbnZhciByZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vcmVzb3VyY2VcIik7XHJcbnZhciBnbG9iYWxpemF0aW9uXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxpemF0aW9uXCIpO1xyXG52YXIgZXZlbnRfc2NvcGVfMSA9IHJlcXVpcmUoXCIuL2V2ZW50LXNjb3BlXCIpO1xyXG52YXIgdmFsdWVUeXBlcyA9IHsgc3RyaW5nOiBTdHJpbmcsIG51bWJlcjogTnVtYmVyLCBkYXRlOiBEYXRlLCBib29sZWFuOiBCb29sZWFuIH07XHJcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1vZGVsKG9wdGlvbnMsIGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX3JlYWR5UHJvY2Vzc2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBlbnRpdHlfc2VyaWFsaXplcl8xLkVudGl0eVNlcmlhbGl6ZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGVzID0ge307XHJcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IG5ldyBNb2RlbFNldHRpbmdzKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5lbnRpdHlSZWdpc3RlcmVkID0gbmV3IGV2ZW50c18xLkV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5hZnRlclByb3BlcnR5U2V0ID0gbmV3IGV2ZW50c18xLkV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5saXN0Q2hhbmdlZCA9IG5ldyBldmVudHNfMS5FdmVudCgpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRTY29wZSA9IGV2ZW50X3Njb3BlXzEuRXZlbnRTY29wZS5jcmVhdGUodGhpcy5zZXR0aW5ncy5ldmVudFNjb3BlU2V0dGluZ3MpO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mb3JtYXRzXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlbmQob3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBkZWZhdWx0IGxvY2FsZSB0byB1c2Ugd2hlbiBhIG1vZGVsJ3MgbG9jYWxlIGlzIG5vdCBleHBsaWNpdGx5IHNldFxyXG4gICAgICogQHBhcmFtIGxvY2FsZSBUaGUgZGVmYXVsdCBsb2NhbGVcclxuICAgICAqL1xyXG4gICAgTW9kZWwuc2V0RGVmYXVsdExvY2FsZSA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcclxuICAgICAgICByZXNvdXJjZV8xLnNldERlZmF1bHRMb2NhbGUobG9jYWxlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgZ2xvYmFsIHJlc291cmNlIG1lc3NhZ2VzIGZvciB0aGUgZ2l2ZW4gbG9jYWxlXHJcbiAgICAgKiBAcGFyYW0gbG9jYWxlIFRoZSBsb2NhbGUgdG8gc2V0IG1lc3NhZ2VzIGZvclxyXG4gICAgICogQHBhcmFtIHJlc291cmNlcyBUaGUgcmVzb3VyY2VzIG1lc3NhZ2VzXHJcbiAgICAgKi9cclxuICAgIE1vZGVsLmRlZmluZVJlc291cmNlcyA9IGZ1bmN0aW9uIChsb2NhbGUsIHJlc291cmNlcykge1xyXG4gICAgICAgIHJlc291cmNlXzEuZGVmaW5lUmVzb3VyY2VzKGxvY2FsZSwgcmVzb3VyY2VzKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5nZXRSZXNvdXJjZSA9IGZ1bmN0aW9uIChuYW1lLCBhcmcyLCBhcmczKSB7XHJcbiAgICAgICAgdmFyIGxvY2FsZTtcclxuICAgICAgICB2YXIgcGFyYW1zO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxlID0gYXJnMjtcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzIgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBhcmcyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xyXG4gICAgICAgICAgICBsb2NhbGUgPSBhcmcyO1xyXG4gICAgICAgICAgICBwYXJhbXMgPSBhcmczO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzb3VyY2UgPSByZXNvdXJjZV8xLmdldFJlc291cmNlKG5hbWUsIGxvY2FsZSk7XHJcbiAgICAgICAgaWYgKHBhcmFtcylcclxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlcnNfMS5yZXBsYWNlVG9rZW5zKHJlc291cmNlLCBwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiByZXNvdXJjZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJlc291cmNlIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgcmVzb3VyY2UgbmFtZS9rZXlcclxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgdG8gdXNlIGZvciBzdHJpbmcgZm9ybWF0IHN1YnN0aXR1dGlvblxyXG4gICAgICovXHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0UmVzb3VyY2UgPSBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IG51bGw7IH1cclxuICAgICAgICB2YXIgcmVzb3VyY2UgPSByZXNvdXJjZV8xLmdldFJlc291cmNlKG5hbWUsIHRoaXMuJHJlc291cmNlcywgdGhpcy4kbG9jYWxlKTtcclxuICAgICAgICBpZiAocGFyYW1zKVxyXG4gICAgICAgICAgICByZXR1cm4gaGVscGVyc18xLnJlcGxhY2VUb2tlbnMocmVzb3VyY2UsIHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc291cmNlO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5yZXNvdXJjZUV4aXN0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc291cmNlXzEucmVzb3VyY2VFeGlzdHMobmFtZSwgdGhpcy4kcmVzb3VyY2VzLCB0aGlzLiRsb2NhbGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRm9ybWF0cyBhIGRhdGUgYXMgdGV4dCB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZm9ybWF0XHJcbiAgICAgKiBAcGFyYW0gZm9ybWF0IFRoZSBmb3JtYXQgc3BlY2lmaWVyXHJcbiAgICAgKi9cclxuICAgIE1vZGVsLnByb3RvdHlwZS5mb3JtYXREYXRlID0gZnVuY3Rpb24gKGRhdGUsIGZvcm1hdCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWxpemF0aW9uXzEuZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIHRoaXMuJGN1bHR1cmUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgZGF0ZSBmcm9tIHRleHRcclxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIHBhcnNlXHJcbiAgICAgKi9cclxuICAgIE1vZGVsLnByb3RvdHlwZS5wYXJzZURhdGUgPSBmdW5jdGlvbiAodGV4dCwgZm9ybWF0cykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWxpemF0aW9uXzEucGFyc2VEYXRlKHRleHQsIHRoaXMuJGN1bHR1cmUsIGZvcm1hdHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kcyBhIGRhdGUvdGltZSBmb3JtYXQgc3RyaW5nLCB3aGljaCBtYXkgYmUgYSBwcmVkZWZpbmVkIHNob3J0IGZvcm1hdCwgaW50byB0aGUgZXF1aXZhbGVudCBmdWxsIGZvcm1hdCBzdHJpblxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZXhwYW5kRGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsaXphdGlvbl8xLmV4cGFuZERhdGVGb3JtYXQodGhpcy4kY3VsdHVyZS5kYXRlVGltZUZvcm1hdCwgZm9ybWF0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZvcm1hdHMgYSBudW1iZXIgYXMgdGV4dCB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0IHN0cmluZ1xyXG4gICAgICogQHBhcmFtIG51bWJlciBUaGUgbnVtYmVyIHRvIGZvcm1hdFxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHNwZWNpZmllclxyXG4gICAgICovXHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24gKG51bWJlciwgZm9ybWF0KSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbGl6YXRpb25fMS5mb3JtYXROdW1iZXIobnVtYmVyLCBmb3JtYXQsIHRoaXMuJGN1bHR1cmUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgbnVtYmVyIGZyb20gdGV4dFxyXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gcGFyc2VcclxuICAgICAqL1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnBhcnNlTnVtYmVyID0gZnVuY3Rpb24gKHRleHQsIGZvcm1hdCkge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWxpemF0aW9uXzEucGFyc2VOdW1iZXIodGV4dCwgZ2xvYmFsaXphdGlvbl8xLmdldE51bWJlclN0eWxlKGZvcm1hdCksIHRoaXMuJGN1bHR1cmUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kcyB0aGUgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIHR5cGUgaW5mb3JtYXRpb24uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgc2V0IG9mIG1vZGVsIHR5cGVzIHRvIGFkZCBhbmQvb3IgZXh0ZW5kLlxyXG4gICAgICovXHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIFVzZSBwcmVwYXJlKCkgdG8gZGVmZXIgcHJvcGVydHkgcGF0aCByZXNvbHV0aW9uIHdoaWxlIHRoZSBtb2RlbCBpcyBiZWluZyBleHRlbmRlZFxyXG4gICAgICAgIHRoaXMucHJlcGFyZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIE5hbWVzcGFjZVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy4kbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBHdWFyZCBhZ2FpbnN0IG5hbWVzcGFjZSBiZWluZyBzZXQgYWZ0ZXIgdHlwZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgIHZhciAkbmFtZXNwYWNlID0gb3B0aW9ucy4kbmFtZXNwYWNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy4kbmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIiRuYW1lc3BhY2VcIiwgeyBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogJG5hbWVzcGFjZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJG5hbWVzcGFjZSAhPT0gX3RoaXMuJG5hbWVzcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWRlZmluZSBuYW1lc3BhY2UgZm9yIG1vZGVsLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBMb2NhbGVcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuJGxvY2FsZSAmJiB0eXBlb2Ygb3B0aW9ucy4kbG9jYWxlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBHdWFyZCBhZ2FpbnN0IGxvY2FsZSBiZWluZyBzZXQgYWZ0ZXIgdHlwZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgIHZhciAkbG9jYWxlID0gb3B0aW9ucy4kbG9jYWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy4kbG9jYWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIiRsb2NhbGVcIiwgeyBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogJGxvY2FsZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJGxvY2FsZSAhPT0gX3RoaXMuJGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWRlZmluZSBsb2NhbGUgZm9yIG1vZGVsLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXNvdXJjZXNcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuJHJlc291cmNlcyAmJiB0eXBlb2Ygb3B0aW9ucy4kcmVzb3VyY2VzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBHdWFyZCBhZ2FpbnN0IHJlc291cmNlcyBiZWluZyBzZXQgYWZ0ZXIgdHlwZXMgaGF2ZSBiZWVuIGNyZWF0ZWRcclxuICAgICAgICAgICAgICAgIHZhciAkcmVzb3VyY2VzID0gb3B0aW9ucy4kcmVzb3VyY2VzO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy4kcmVzb3VyY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIiRyZXNvdXJjZXNcIiwgeyBjb25maWd1cmFibGU6IGZhbHNlLCBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogJHJlc291cmNlcywgd3JpdGFibGU6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJHJlc291cmNlcyAhPT0gX3RoaXMuJHJlc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZWRlZmluZSByZXNvdXJjZXMgZm9yIG1vZGVsLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDdWx0dXJlXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLiRjdWx0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgJGN1bHR1cmUgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBHdWFyZCBhZ2FpbnN0IGN1bHR1cmUgYmVpbmcgc2V0IGFmdGVyIHR5cGVzIGhhdmUgYmVlbiBjcmVhdGVkXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuJGN1bHR1cmUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAkY3VsdHVyZSA9IG9wdGlvbnMuJGN1bHR1cmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy4kY3VsdHVyZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbGl6YXRpb25fMS5DdWx0dXJlSW5mby5zZXR1cCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnbG9iYWxpemF0aW9uXzEuQ3VsdHVyZUluZm8uQ3VycmVudEN1bHR1cmUubmFtZSA9PT0gb3B0aW9ucy4kY3VsdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAkY3VsdHVyZSA9IGdsb2JhbGl6YXRpb25fMS5DdWx0dXJlSW5mby5DdXJyZW50Q3VsdHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkY3VsdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBjdWx0dXJlICdcIiArIG9wdGlvbnMuJGN1bHR1cmUgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgkY3VsdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuJGN1bHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLCBcIiRjdWx0dXJlXCIsIHsgY29uZmlndXJhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6ICRjdWx0dXJlLCB3cml0YWJsZTogZmFsc2UgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCRjdWx0dXJlICE9PSBfdGhpcy4kY3VsdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVkZWZpbmUgY3VsdHVyZSBmb3IgbW9kZWwuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdHlwZXNUb0NyZWF0ZSA9IE9iamVjdC5rZXlzKG9wdGlvbnMpLmZpbHRlcihmdW5jdGlvbiAodHlwZU5hbWUpIHsgcmV0dXJuICF0eXBlTmFtZS5zdGFydHNXaXRoKFwiJFwiKTsgfSk7XHJcbiAgICAgICAgICAgIHZhciB0eXBlc1RvSW5pdGlhbGl6ZSA9IFtdO1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgTmV3IFR5cGVzXHJcbiAgICAgICAgICAgIHdoaWxlICh0eXBlc1RvQ3JlYXRlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IHR5cGVzVG9DcmVhdGUuc3BsaWNlKDAsIDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdHlwZU5hbWVJZHggPSAtMSwgcG9zID0gdHlwZU5hbWUubGVuZ3RoIC0gMSwgaSA9IHR5cGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiLCBwb3MpOyBpID4gMDsgcG9zID0gaSAtIDEsIGkgPSB0eXBlTmFtZS5sYXN0SW5kZXhPZihcIi5cIiwgcG9zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZXNwYWNlID0gdHlwZU5hbWUuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZXNwYWNlSWR4ID0gdHlwZXNUb0NyZWF0ZS5pbmRleE9mKHR5cGVOYW1lc3BhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlTmFtZXNwYWNlSWR4ID4gdHlwZU5hbWVJZHgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlR5cGUgJ1wiICsgdHlwZU5hbWVzcGFjZSArIFwiJyBzaG91bGQgYmUgY3JlYXRlZCBiZWZvcmUgdHlwZSAnXCIgKyB0eXBlTmFtZSArIFwiJy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjdXJyZW50ICB0eXBlJ3MgXCJuYW1lc3BhY2VcIiB0eXBlIGFuZCByZS1hZGQgdGhlIGN1cnJlbnQgdHlwZSB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlc1RvQ3JlYXRlLnNwbGljZSh0eXBlTmFtZXNwYWNlSWR4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZXNUb0NyZWF0ZS5zcGxpY2UoMCwgMCwgdHlwZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlTmFtZUlkeCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN1bWUgdGhlIGxvb3AgdXNpbmcgdGhlIG5ldyBuYW1lc3BhY2UgdHlwZSAocmVzZXR0aW5nIGluZGV4IHZhcmlhYmxlcyBpc24ndCBuZWNlc3NhcnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWVzcGFjZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZU9wdGlvbnMgPSBvcHRpb25zW3R5cGVOYW1lXTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gX3RoaXMudHlwZXNbdHlwZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgdHlwZXNUb0luaXRpYWxpemUucHVzaCh0eXBlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZVR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlT3B0aW9ucy4kZXh0ZW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVHlwZSA9IF90aGlzLnR5cGVzW3R5cGVPcHRpb25zLiRleHRlbmRzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFiYXNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFzZSB0eXBlICdcIiArIHR5cGVPcHRpb25zLiRleHRlbmRzICsgXCInIGZvciB0eXBlICdcIiArIHR5cGVOYW1lICsgXCInIHdhc24ndCBmb3VuZC5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHR5cGVPcHRpb25zLiRmb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IG5ldyB0eXBlXzEuVHlwZShfdGhpcywgdHlwZU5hbWUsIGJhc2VUeXBlLCBmb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnR5cGVzW3R5cGVOYW1lXSA9IHR5cGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRXh0ZW5kIFR5cGVzXHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdHlwZXNUb0luaXRpYWxpemVfMSA9IHR5cGVzVG9Jbml0aWFsaXplOyBfaSA8IHR5cGVzVG9Jbml0aWFsaXplXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSB0eXBlc1RvSW5pdGlhbGl6ZV8xW19pXTtcclxuICAgICAgICAgICAgICAgIHZhciB0eXBlT3B0aW9ucyA9IG9wdGlvbnNbdHlwZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudHlwZXNbdHlwZU5hbWVdLmV4dGVuZCh0eXBlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByZXBhcmVzIHRoZSBtb2RlbCBieSBpbnZva2luZyBhbmQgZXh0ZW5zaW9uIGZ1bmN0aW9uLCB3aGljaCB0cmFja2luZyB0aGUgbW9kZWxcclxuICAgICAqIHJlYWR5IHN0YXRlIHRvIGFsbG93IHVzZSBvZiB0aGUgQHJlYWR5IHByb21pc2UgdG8gZGVmZXIgcHJvcGVydHkgcGF0aCByZXNvbHV0aW9uLlxyXG4gICAgICogQHBhcmFtIGV4dGVuZCBUaGUgZnVuY3Rpb24gZXh0ZW5kaW5nIHRoZSBtb2RlbFxyXG4gICAgICovXHJcbiAgICBNb2RlbC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uIChleHRlbmQpIHtcclxuICAgICAgICAvLyBDcmVhdGUgYSBtb2RlbCBpbml0aWFsaXphdGlvbiBzY29wZVxyXG4gICAgICAgIGlmICghdGhpcy5fcmVhZHlDYWxsYmFja3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlQcm9jZXNzaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBhcnJheSB0byB0cmFjayBtb2RlbCBpbml0aWFsaXphdGlvbiBjYWxsYmFja3NcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3JlYWR5Q2FsbGJhY2tzXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBbXSB9KTtcclxuICAgICAgICAgICAgLy8gRXh0ZW5kIHRoZSBtb2RlbFxyXG4gICAgICAgICAgICBleHRlbmQoKTtcclxuICAgICAgICAgICAgLy8gQ29tcGxldGUgcGVuZGluZyBtb2RlbCBpbml0aWFsaXphdGlvbiBzdGVwc1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeVByb2Nlc3NpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fcmVhZHlDYWxsYmFja3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5pdCA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeVByb2Nlc3NpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlYWR5Q2FsbGJhY2tzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMZXZlcmFnZSB0aGUgY3VycmVudCBtb2RlbCBpbml0aWFsaXphdGlvbiBzY29wZVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgZXh0ZW5kKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hlbiB0aGUgbW9kZWwgaXMgcmVhZHkuXHJcbiAgICAgKiBAcGFyYW0gaW5pdCBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIG1vZGVsIGlzIHJlYWR5LlxyXG4gICAgICogQHBhcmFtIGVucXVldWVXaGlsZVByb2Nlc3NpbmcgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjYWxsYmFjayBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIHF1ZXVlIHdoaWxlIHRoZSBxdWV1ZSBpcyBiZWluZyBwcm9jZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIE1vZGVsLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmVucXVldWVXaGlsZVByb2Nlc3NpbmcsIGVucXVldWVXaGlsZVByb2Nlc3NpbmcgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZWFkeUNhbGxiYWNrcyAmJiAoIXRoaXMuX3JlYWR5UHJvY2Vzc2luZyB8fCBlbnF1ZXVlV2hpbGVQcm9jZXNzaW5nKSlcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZm9ybWF0IGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IHR5cGUgYW5kIGZvcm1hdCBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0aGUgZm9ybWF0IGlzIGZvclxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBUaGUgZm9ybWF0IHRlbXBsYXRlIG9yIHNwZWNpZmllclxyXG4gICAgICovXHJcbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0Rm9ybWF0ID0gZnVuY3Rpb24gKHR5cGUsIGZvcm1hdCwgZm9ybWF0RXZhbCkge1xyXG4gICAgICAgIC8vIFJldHVybiBudWxsIGlmIGEgZm9ybWF0IHNwZWNpZmllciB3YXMgbm90IHByb3ZpZGVkXHJcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCB0aGUgZm9ybWF0IGNhY2hlIGZvciB0aGUgdHlwZVxyXG4gICAgICAgIHZhciBmb3JtYXRzO1xyXG4gICAgICAgIGlmICh0eXBlXzEuaXNFbnRpdHlUeXBlKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdHMgPSB0eXBlLm1ldGEuX2Zvcm1hdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3JtYXRzID0gdGhpcy5fZm9ybWF0c1t0eXBlLm5hbWVdO1xyXG4gICAgICAgICAgICBpZiAoIWZvcm1hdHMpXHJcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdGhpcy5fZm9ybWF0c1t0eXBlLm5hbWVdID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZpcnN0IHNlZSBpZiB0aGUgcmVxdWVzdGVkIGZvcm1hdCBpcyBjYWNoZWRcclxuICAgICAgICB2YXIgZiA9IGZvcm1hdHNbZm9ybWF0XTtcclxuICAgICAgICBpZiAoZikge1xyXG4gICAgICAgICAgICByZXR1cm4gZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYW5kIGNhY2hlIHRoZSBmb3JtYXRcclxuICAgICAgICBpZiAodHlwZV8xLmlzRW50aXR5VHlwZSh0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKGZvcm1hdHNbZm9ybWF0XSA9IGZvcm1hdF8xLkZvcm1hdC5mcm9tVGVtcGxhdGUodHlwZS5tZXRhLCBmb3JtYXQsIGZvcm1hdEV2YWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgY2FsbCB0aGUgZm9ybWF0IHByb3ZpZGVyIHRvIGNyZWF0ZSBhIG5ldyBmb3JtYXRcclxuICAgICAgICAgICAgcmV0dXJuIChmb3JtYXRzW2Zvcm1hdF0gPSBmb3JtYXRfMS5jcmVhdGVGb3JtYXQodGhpcywgdHlwZSwgZm9ybWF0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgamF2YXNjcmlwdCBwcm9wZXJ0eSB0eXBlIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gICAgICogQHBhcmFtIHR5cGVcclxuICAgICAqL1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmdldEpzVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIGpzdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJvYmplY3RcIiA/IE9iamVjdCA6IHZhbHVlVHlwZXNbdHlwZS50b0xvd2VyQ2FzZSgpXTtcclxuICAgICAgICBpZiAoIWpzdHlwZSkge1xyXG4gICAgICAgICAgICB2YXIgbW9kZWxUeXBlID0gdGhpcy50eXBlc1t0eXBlXTtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZGVsVHlwZSA/IG1vZGVsVHlwZS5qc3R5cGUgOiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ganN0eXBlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb2RlbDtcclxufSgpKTtcclxuZXhwb3J0cy5Nb2RlbCA9IE1vZGVsO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXHJcbmZ1bmN0aW9uIGNyZWF0ZU1vZGVsKG9wdGlvbnMsIGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKG9wdGlvbnMsIGNvbmZpZyk7XHJcbiAgICAgICAgbW9kZWwucmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKG1vZGVsKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlTW9kZWwgPSBjcmVhdGVNb2RlbDtcclxudmFyIE1vZGVsU2V0dGluZ3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb2RlbFNldHRpbmdzKGNvbmZpZykge1xyXG4gICAgICAgIC8vIFRoZXJlIGlzIGEgc2xpZ2h0IHNwZWVkIGNvc3QgdG8gY3JlYXRpbmcgb3duIHByb3BlcnRpZXMsXHJcbiAgICAgICAgLy8gd2hpY2ggbWF5IGJlIG5vdGljZWFibGUgd2l0aCB2ZXJ5IGxhcmdlIG9iamVjdCBjb3VudHMuXHJcbiAgICAgICAgdGhpcy5jcmVhdGVPd25Qcm9wZXJ0aWVzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hdXRvZ2VuZXJhdGVQcm9wZXJ0eUxhYmVscyA9IHRydWU7XHJcbiAgICAgICAgLy8gRG9uJ3QgcG9sbHV0ZSB0aGUgd2luZG93IG9iamVjdCBieSBkZWZhdWx0XHJcbiAgICAgICAgdGhpcy51c2VHbG9iYWxPYmplY3QgPSBmYWxzZTtcclxuICAgICAgICAvLyBVc2Ugc2FuZSBkZWZhdWx0cyBmb3IgZXZlbnQgc2NvcGUgc2V0dGluZ3MsIGkuZS4gXCJub24tZXhpdGluZ1wiIHNjb3BlIGRldGVjdGlvblxyXG4gICAgICAgIHRoaXMuZXZlbnRTY29wZVNldHRpbmdzID0gZXZlbnRfc2NvcGVfMS5FVkVOVF9TQ09QRV9ERUZBVUxUX1NFVFRJTkdTO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlT3duUHJvcGVydGllcyA9IGNvbmZpZyAmJiAhIWNvbmZpZy5jcmVhdGVPd25Qcm9wZXJ0aWVzO1xyXG4gICAgICAgIGlmIChjb25maWcgJiYgY29uZmlnLmF1dG9nZW5lcmF0ZVByb3BlcnR5TGFiZWxzID09PSBmYWxzZSlcclxuICAgICAgICAgICAgdGhpcy5hdXRvZ2VuZXJhdGVQcm9wZXJ0eUxhYmVscyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXNlR2xvYmFsT2JqZWN0ID0gY29uZmlnICYmICEhY29uZmlnLnVzZUdsb2JhbE9iamVjdDtcclxuICAgICAgICB0aGlzLmV2ZW50U2NvcGVTZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgbWF4RXhpdGluZ1RyYW5zZmVyQ291bnQ6IChjb25maWcgJiYgdHlwZW9mIGNvbmZpZy5tYXhFeGl0aW5nRXZlbnRTY29wZVRyYW5zZmVyQ291bnQgPT09IFwibnVtYmVyXCIgPyBjb25maWcubWF4RXhpdGluZ0V2ZW50U2NvcGVUcmFuc2ZlckNvdW50IDogbnVsbCkgfHwgZXZlbnRfc2NvcGVfMS5FVkVOVF9TQ09QRV9ERUZBVUxUX1NFVFRJTkdTLm1heEV4aXRpbmdUcmFuc2ZlckNvdW50LFxyXG4gICAgICAgICAgICBtYXhEZXB0aDogKGNvbmZpZyAmJiB0eXBlb2YgY29uZmlnLm1heEV2ZW50U2NvcGVEZXB0aCA9PT0gXCJudW1iZXJcIiA/IGNvbmZpZy5tYXhFdmVudFNjb3BlRGVwdGggOiBudWxsKSB8fCBldmVudF9zY29wZV8xLkVWRU5UX1NDT1BFX0RFRkFVTFRfU0VUVElOR1MubWF4RGVwdGhcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1vZGVsU2V0dGluZ3M7XHJcbn0oKSk7XHJcbmV4cG9ydHMuTW9kZWxTZXR0aW5ncyA9IE1vZGVsU2V0dGluZ3M7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcclxuZnVuY3Rpb24gbm9ybWFsaXplKHZhbCwgZm9ybWF0KSB7XHJcbiAgICBpZiAoIXZhbCAmJiB2YWwgIT09IGZhbHNlKVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICBpZiAodmFsLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiRGF0ZVwiKSB7XHJcbiAgICAgICAgdmFyIGRhdGVGb3JtYXQgPSB0eXBlb2YgZm9ybWF0ID09PSBcInN0cmluZ1wiID8gZm9ybWF0IDogZm9ybWF0LnNwZWNpZmllcjtcclxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PT0gXCJ0XCIpIHtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBkYXRlIG9mIHRoZSBkYXRlVGltZSB0byBKYW51YXJ5IDFzdCwgMTk3MFxyXG4gICAgICAgICAgICB2YXIgbmV3RGF0ZSA9IG5ldyBEYXRlKHZhbC52YWx1ZU9mKCkpO1xyXG4gICAgICAgICAgICBuZXdEYXRlLnNldEZ1bGxZZWFyKDE5NzApO1xyXG4gICAgICAgICAgICBuZXdEYXRlLnNldE1vbnRoKDApO1xyXG4gICAgICAgICAgICBuZXdEYXRlLnNldERhdGUoMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdEYXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRlRm9ybWF0ID09PSBcImRcIikge1xyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHRpbWUgb2YgdGhlIGRhdGVUaW1lIHRvIDEyQU1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbC5nZXRGdWxsWWVhcigpLCB2YWwuZ2V0TW9udGgoKSwgdmFsLmdldERhdGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxufVxyXG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5PYmplY3RNZXRhID0gdm9pZCAwO1xyXG52YXIgY29uZGl0aW9uX3R5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbmRpdGlvbi10eXBlXCIpO1xyXG52YXIgb2JzZXJ2YWJsZV9hcnJheV8xID0gcmVxdWlyZShcIi4vb2JzZXJ2YWJsZS1hcnJheVwiKTtcclxudmFyIGZvcm1hdF9lcnJvcl8xID0gcmVxdWlyZShcIi4vZm9ybWF0LWVycm9yXCIpO1xyXG52YXIgT2JqZWN0TWV0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9iamVjdE1ldGEodHlwZSwgZW50aXR5LCBpZCwgaXNOZXcpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0eXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCB2YWx1ZTogdHlwZSB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbnRpdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBlbnRpdHkgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGlkIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImlzTmV3XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBpc05ldyB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25kaXRpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBvYnNlcnZhYmxlX2FycmF5XzEuT2JzZXJ2YWJsZUFycmF5LmNyZWF0ZSgpIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fcGVuZGluZ0ludm9jYXRpb25fX1wiLCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIHZhbHVlOiBbXSB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY29uZGl0aW9uIHRhcmdldCB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9uIHR5cGVcclxuICAgICAqIEBwYXJhbSBjb25kaXRpb25UeXBlIFRoZSB0eXBlIG9mIGNvbmRpdGlvbiB0byByZXRyaWV2ZVxyXG4gICAgICovXHJcbiAgICBPYmplY3RNZXRhLnByb3RvdHlwZS5nZXRDb25kaXRpb24gPSBmdW5jdGlvbiAoY29uZGl0aW9uVHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLmNvbmRpdGlvbi50eXBlID09PSBjb25kaXRpb25UeXBlOyB9KVswXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3JlcyB0aGUgY29uZGl0aW9uIHRhcmdldCBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBjb25kaXRpb25UYXJnZXQgVGhlIGNvbmRpdGlvbiB0YXJnZXQgdG8gc3RvcmVcclxuICAgICAqL1xyXG4gICAgT2JqZWN0TWV0YS5wcm90b3R5cGUuc2V0Q29uZGl0aW9uID0gZnVuY3Rpb24gKGNvbmRpdGlvblRhcmdldCkge1xyXG4gICAgICAgIGlmIChjb25kaXRpb25UYXJnZXQuY29uZGl0aW9uLnR5cGUgIT09IGZvcm1hdF9lcnJvcl8xLkZvcm1hdEVycm9yLkNvbmRpdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jb25kaXRpb25zLnB1c2goY29uZGl0aW9uVGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNvbmRpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmRpdGlvbiB0eXBlXHJcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uVHlwZSBUaGUgdHlwZSBvZiBjb25kaXRpb24gdG8gY2xlYXJcclxuICAgICAqL1xyXG4gICAgT2JqZWN0TWV0YS5wcm90b3R5cGUuY2xlYXJDb25kaXRpb24gPSBmdW5jdGlvbiAoY29uZGl0aW9uVHlwZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb25kaXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25UYXJnZXQgPSB0aGlzLmNvbmRpdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGlmIChjb25kaXRpb25UYXJnZXQuY29uZGl0aW9uLnR5cGUgPT09IGNvbmRpdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZGl0aW9ucy5zcGxpY2UoaS0tLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHNldCBvZiBwZXJtaXNzaW9ucyBhcmUgYWxsb3dlZCBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSBjb2RlcyBUaGUgcGVybWlzc2lvbiBjb25kaXRpb24gdHlwZSBjb2RlKHMpXHJcbiAgICAgKi9cclxuICAgIE9iamVjdE1ldGEucHJvdG90eXBlLmlzQWxsb3dlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29kZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBjb2Rlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlbnN1cmUgZWFjaCBjb25kaXRpb24gdHlwZSBpcyBhbGxvd2VkIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZVxyXG4gICAgICAgIGZvciAodmFyIGMgPSBjb2Rlcy5sZW5ndGggLSAxOyBjID49IDA7IGMtLSkge1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IGNvZGVzW2NdO1xyXG4gICAgICAgICAgICB2YXIgY29uZGl0aW9uVHlwZSA9IGNvbmRpdGlvbl90eXBlXzEuQ29uZGl0aW9uVHlwZS5nZXQoY29kZSk7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiB1bmRlZmluZWQgaWYgdGhlIGNvbmRpdGlvbiB0eXBlIGRvZXMgbm90IGV4aXN0XHJcbiAgICAgICAgICAgIGlmIChjb25kaXRpb25UeXBlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSBjb25kaXRpb24gdHlwZSBpcyBub3QgYSBwZXJtaXNzaW9uXHJcbiAgICAgICAgICAgIGlmICghKGNvbmRpdGlvblR5cGUgaW5zdGFuY2VvZiBjb25kaXRpb25fdHlwZV8xLlBlcm1pc3Npb25Db25kaXRpb25UeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZGl0aW9uIHR5cGUgXFxcIlwiICsgY29kZSArIFwiXFxcIiBzaG91bGQgYmUgYSBQZXJtaXNzaW9uLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByZXR1cm4gZmFsc2UgaWYgYSBjb25kaXRpb24gb2YgdGhlIGN1cnJlbnQgdHlwZSBleGlzdHMgYW5kIGlzIGEgZGVueSBwZXJtaXNzaW9uIG9yIGRvZXMgbm90IGV4aXN0IGFuZCBpcyBhIGdyYW50IHBlcm1pc3Npb25cclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q29uZGl0aW9uKGNvbmRpdGlvblR5cGUpID8gIWNvbmRpdGlvblR5cGUuaXNBbGxvd2VkIDogY29uZGl0aW9uVHlwZS5pc0FsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gT2JqZWN0TWV0YTtcclxufSgpKTtcclxuZXhwb3J0cy5PYmplY3RNZXRhID0gT2JqZWN0TWV0YTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLnVwZGF0ZUFycmF5ID0gZXhwb3J0cy5BcnJheU9ic2VydmVyID0gZXhwb3J0cy5PYnNlcnZhYmxlQXJyYXkkdW5zaGlmdCA9IGV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5JHNwbGljZSA9IGV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5JHNvcnQgPSBleHBvcnRzLk9ic2VydmFibGVBcnJheSRzaGlmdCA9IGV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5JHJldmVyc2UgPSBleHBvcnRzLk9ic2VydmFibGVBcnJheSRwdXNoID0gZXhwb3J0cy5PYnNlcnZhYmxlQXJyYXkkcG9wID0gZXhwb3J0cy5PYnNlcnZhYmxlQXJyYXkkZmlsbCA9IGV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5JGNvcHlXaXRoaW4gPSBleHBvcnRzLk9ic2VydmFibGVBcnJheSRiYXRjaFVwZGF0ZSA9IGV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5JG92ZXJyaWRlTmF0aXZlTWV0aG9kcyA9IGV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24gPSBleHBvcnRzLkFycmF5Q2hhbmdlVHlwZSA9IGV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5ID0gdm9pZCAwO1xyXG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L2V4cG9ydCwgbm8tcmVkZWNsYXJlLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcclxudmFyIE9ic2VydmFibGVBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9ic2VydmFibGVBcnJheSgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZ2l2ZW4gYXJyYXkgaXMgb2JzZXJ2YWJsZVxyXG4gICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBjaGVjayBmb3Igb2JzZXJ2YWJpbGl0eVxyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlQXJyYXkuaXNPYnNlcnZhYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICByZXR1cm4gaGVscGVyc18xLmhhc093blByb3BlcnR5KGFycmF5LCBcIl9fYW9iX19cIikgJiYgYXJyYXkuX19hb2JfXy5jb25zdHJ1Y3RvciA9PT0gQXJyYXlPYnNlcnZlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoZSBnaXZlbiBhcnJheSBvYnNlcnZhYmxlLCBpZiBub3QgYWxyZWFkeVxyXG4gICAgICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBtYWtlIG9ic2VydmFibGVcclxuICAgICAqL1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5LmVuc3VyZU9ic2VydmFibGUgPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhlIGFycmF5IGlzIGFscmVhZHkgYW4gb2JzZXJ2YWJsZSBsaXN0XHJcbiAgICAgICAgaWYgKE9ic2VydmFibGVBcnJheS5pc09ic2VydmFibGVBcnJheShhcnJheSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGVscGVyc18xLmhhc093blByb3BlcnR5KGFycmF5LCBcIl9fYW9iX19cIikpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogV2FybiBhYm91dCBpbnZhbGlkICdfX2FvYl9fJyBwcm9wZXJ0eT9cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIFwiX19hb2JfX1wiLCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICB2YWx1ZTogbmV3IEFycmF5T2JzZXJ2ZXIoYXJyYXkpLFxyXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIFwiY2hhbmdlZFwiLCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19hb2JfXy5jaGFuZ2VkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYXJyYXlbXCJiYXRjaFVwZGF0ZVwiXSA9IE9ic2VydmFibGVBcnJheSRiYXRjaFVwZGF0ZTtcclxuICAgICAgICBPYnNlcnZhYmxlQXJyYXkkb3ZlcnJpZGVOYXRpdmVNZXRob2RzLmNhbGwoYXJyYXkpO1xyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgb2JzZXJ2YWJsZSBhcnJheVxyXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBpbml0aWFsIGFycmF5IGl0ZW1zXHJcbiAgICAgKi9cclxuICAgIE9ic2VydmFibGVBcnJheS5jcmVhdGUgPSBmdW5jdGlvbiAoaXRlbXMpIHtcclxuICAgICAgICBpZiAoaXRlbXMgPT09IHZvaWQgMCkgeyBpdGVtcyA9IFtdOyB9XHJcbiAgICAgICAgdmFyIGFycmF5O1xyXG4gICAgICAgIGlmIChpdGVtcyBpbnN0YW5jZW9mIE9ic2VydmFibGVBcnJheSlcclxuICAgICAgICAgICAgYXJyYXkgPSBpdGVtcztcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IChPYnNlcnZhYmxlQXJyYXlJbXBsZW1lbnRhdGlvbi5iaW5kLmFwcGx5KE9ic2VydmFibGVBcnJheUltcGxlbWVudGF0aW9uLCBfX3NwcmVhZEFycmF5cyhbdm9pZCAwXSwgaXRlbXMpKSkoKTtcclxuICAgICAgICBPYnNlcnZhYmxlQXJyYXkuZW5zdXJlT2JzZXJ2YWJsZShhcnJheSk7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBPYnNlcnZhYmxlQXJyYXk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5ID0gT2JzZXJ2YWJsZUFycmF5O1xyXG52YXIgQXJyYXlDaGFuZ2VUeXBlO1xyXG4oZnVuY3Rpb24gKEFycmF5Q2hhbmdlVHlwZSkge1xyXG4gICAgQXJyYXlDaGFuZ2VUeXBlW0FycmF5Q2hhbmdlVHlwZVtcImFkZFwiXSA9IDFdID0gXCJhZGRcIjtcclxuICAgIEFycmF5Q2hhbmdlVHlwZVtBcnJheUNoYW5nZVR5cGVbXCJyZW1vdmVcIl0gPSAyXSA9IFwicmVtb3ZlXCI7XHJcbiAgICBBcnJheUNoYW5nZVR5cGVbQXJyYXlDaGFuZ2VUeXBlW1wicmVwbGFjZVwiXSA9IDRdID0gXCJyZXBsYWNlXCI7XHJcbiAgICBBcnJheUNoYW5nZVR5cGVbQXJyYXlDaGFuZ2VUeXBlW1wicmVvcmRlclwiXSA9IDhdID0gXCJyZW9yZGVyXCI7XHJcbn0pKEFycmF5Q2hhbmdlVHlwZSA9IGV4cG9ydHMuQXJyYXlDaGFuZ2VUeXBlIHx8IChleHBvcnRzLkFycmF5Q2hhbmdlVHlwZSA9IHt9KSk7XHJcbnZhciBPYnNlcnZhYmxlQXJyYXlJbXBsZW1lbnRhdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhPYnNlcnZhYmxlQXJyYXlJbXBsZW1lbnRhdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBvYnNlcnZhYmxlIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgVGhlIGFycmF5IG9mIGluaXRpYWwgaXRlbXNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIGl0ZW1zKSB8fCB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJfX2FvYl9fXCIsIHtcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgQXJyYXlPYnNlcnZlcihfdGhpcyksXHJcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjaGFuZ2VkXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FvYl9fLmNoYW5nZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoX3RoaXMuY29uc3RydWN0b3IgIT09IE9ic2VydmFibGVBcnJheUltcGxlbWVudGF0aW9uKSB7XHJcbiAgICAgICAgICAgIF90aGlzW1wiYmF0Y2hVcGRhdGVcIl0gPSAoZnVuY3Rpb24gKGZuKSB7IE9ic2VydmFibGVBcnJheSRiYXRjaFVwZGF0ZS5jYWxsKHRoaXMsIGZuKTsgfSk7XHJcbiAgICAgICAgICAgIE9ic2VydmFibGVBcnJheSRvdmVycmlkZU5hdGl2ZU1ldGhvZHMuY2FsbChfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYnNlcnZhYmxlQXJyYXlJbXBsZW1lbnRhdGlvbi5wcm90b3R5cGUsIFwiY2hhbmdlZFwiLCB7XHJcbiAgICAgICAgLyoqIEV4cG9zZSB0aGUgY2hhbmdlZCBldmVudCAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FvYl9fLmNoYW5nZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbiBxdWV1ZWluZyBjaGFuZ2VzIHRvIHRoZSBhcnJheSwgbWFrZSBjaGFuZ2VzIGluIHRoZSBnaXZlbiBjYWxsYmFjayBmdW5jdGlvbiwgdGhlbiBzdG9wIHF1ZXVlaW5nIGFuZCByYWlzZSBldmVudHNcclxuICAgICAqL1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24ucHJvdG90eXBlLmJhdGNoVXBkYXRlID0gZnVuY3Rpb24gKGZuLCBhZGRpdGlvbmFsQXJncykge1xyXG4gICAgICAgIGlmIChhZGRpdGlvbmFsQXJncyA9PT0gdm9pZCAwKSB7IGFkZGl0aW9uYWxBcmdzID0gbnVsbDsgfVxyXG4gICAgICAgIE9ic2VydmFibGVBcnJheSRiYXRjaFVwZGF0ZS5jYWxsKHRoaXMsIGZuLCBhZGRpdGlvbmFsQXJncyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29weVdpdGhpbigpIG1ldGhvZCBzaGFsbG93IGNvcGllcyBwYXJ0IG9mIGFuIGFycmF5IHRvIGFub3RoZXIgbG9jYXRpb24gaW4gdGhlIHNhbWUgYXJyYXkgYW5kIHJldHVybnMgaXQsIHdpdGhvdXQgbW9kaWZ5aW5nIGl0cyBzaXplLlxyXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvY29weVdpdGhpblxyXG4gICAgICogQHBhcmFtIHRhcmdldCBaZXJvIGJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGNvcHkgdGhlIHNlcXVlbmNlIHRvLiBJZiBuZWdhdGl2ZSwgdGFyZ2V0IHdpbGwgYmUgY291bnRlZCBmcm9tIHRoZSBlbmQuIElmIHRhcmdldCBpcyBhdCBvciBncmVhdGVyIHRoYW4gYXJyLmxlbmd0aCwgbm90aGluZyB3aWxsIGJlIGNvcGllZC4gSWYgdGFyZ2V0IGlzIHBvc2l0aW9uZWQgYWZ0ZXIgc3RhcnQsIHRoZSBjb3BpZWQgc2VxdWVuY2Ugd2lsbCBiZSB0cmltbWVkIHRvIGZpdCBhcnIubGVuZ3RoLlxyXG4gICAgICogQHBhcmFtIHN0YXJ0IFplcm8gYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY29weWluZyBlbGVtZW50cyBmcm9tLiBJZiBuZWdhdGl2ZSwgc3RhcnQgd2lsbCBiZSBjb3VudGVkIGZyb20gdGhlIGVuZC4gSWYgc3RhcnQgaXMgb21pdHRlZCwgY29weVdpdGhpbiB3aWxsIGNvcHkgZnJvbSB0aGUgc3RhcnQgKGRlZmF1bHRzIHRvIDApLlxyXG4gICAgICogQHBhcmFtIGVuZCBaZXJvIGJhc2VkIGluZGV4IGF0IHdoaWNoIHRvIGVuZCBjb3B5aW5nIGVsZW1lbnRzIGZyb20uIGNvcHlXaXRoaW4gY29waWVzIHVwIHRvIGJ1dCBub3QgaW5jbHVkaW5nIGVuZC4gSWYgbmVnYXRpdmUsIGVuZCB3aWxsIGJlIGNvdW50ZWQgZnJvbSB0aGUgZW5kLiBJZiBlbmQgaXMgb21pdHRlZCwgY29weVdpdGhpbiB3aWxsIGNvcHkgdW50aWwgdGhlIGVuZCAoZGVmYXVsdCB0byBhcnIubGVuZ3RoKS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBtb2RpZmllZCBhcnJheS5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24ucHJvdG90eXBlLmNvcHlXaXRoaW4gPSBmdW5jdGlvbiAodGFyZ2V0LCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVBcnJheSRjb3B5V2l0aGluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZmlsbCgpIG1ldGhvZCBmaWxscyBhbGwgdGhlIGVsZW1lbnRzIG9mIGFuIGFycmF5IGZyb20gYSBzdGFydCBpbmRleCB0byBhbiBlbmQgaW5kZXggd2l0aCBhIHN0YXRpYyB2YWx1ZS4gVGhlIGVuZCBpbmRleCBpcyBub3QgaW5jbHVkZWQuXHJcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWxsXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gZmlsbCBhbiBhcnJheS5cclxuICAgICAqIEBwYXJhbSBzdGFydCBTdGFydCBpbmRleCwgZGVmYXVsdHMgdG8gMC5cclxuICAgICAqIEBwYXJhbSBlbmQgRW5kIGluZGV4LCBkZWZhdWx0cyB0byB0aGlzLmxlbmd0aC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBtb2RpZmllZCBhcnJheS5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24ucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5JGZpbGwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb3AoKSBtZXRob2QgcmVtb3ZlcyB0aGUgbGFzdCBlbGVtZW50IGZyb20gYW4gYXJyYXkgYW5kIHJldHVybnMgdGhhdCBlbGVtZW50LiBUaGlzIG1ldGhvZCBjaGFuZ2VzIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxyXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcG9wXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCBlbGVtZW50IGZyb20gdGhlIGFycmF5OyB1bmRlZmluZWQgaWYgdGhlIGFycmF5IGlzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBPYnNlcnZhYmxlQXJyYXlJbXBsZW1lbnRhdGlvbi5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlQXJyYXkkcG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcHVzaCgpIG1ldGhvZCBhZGRzIG9uZSBvciBtb3JlIGVsZW1lbnRzIHRvIHRoZSBlbmQgb2YgYW4gYXJyYXkgYW5kIHJldHVybnMgdGhlIG5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxyXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcHVzaFxyXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBlbGVtZW50cyB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGxlbmd0aCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IHVwb24gd2hpY2ggdGhlIG1ldGhvZCB3YXMgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBPYnNlcnZhYmxlQXJyYXlJbXBsZW1lbnRhdGlvbi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBlbGVtZW50c1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5JHB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZXZlcnNlKCkgbWV0aG9kIHJldmVyc2VzIGFuIGFycmF5IGluIHBsYWNlLiBUaGUgZmlyc3QgYXJyYXkgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCBhbmQgdGhlIGxhc3QgYXJyYXkgZWxlbWVudCBiZWNvbWVzIHRoZSBmaXJzdC5cclxuICAgICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JldmVyc2VcclxuICAgICAqIEByZXR1cm5zIFRoZSByZXZlcnNlZCBhcnJheS5cclxuICAgICAqL1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVBcnJheSRyZXZlcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2hpZnQoKSBtZXRob2QgcmVtb3ZlcyB0aGUgZmlyc3QgZWxlbWVudCBmcm9tIGFuIGFycmF5IGFuZCByZXR1cm5zIHRoYXQgcmVtb3ZlZCBlbGVtZW50LiBUaGlzIG1ldGhvZCBjaGFuZ2VzIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxyXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2hpZnRcclxuICAgICAqIEByZXR1cm5zIFRoZSByZW1vdmVkIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXk7IHVuZGVmaW5lZCBpZiB0aGUgYXJyYXkgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIE9ic2VydmFibGVBcnJheUltcGxlbWVudGF0aW9uLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5JHNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc29ydCgpIG1ldGhvZCBzb3J0cyB0aGUgZWxlbWVudHMgb2YgYW4gYXJyYXkgaW4gcGxhY2UgYW5kIHJldHVybnMgdGhlIGFycmF5LiBKYXZhc2NyaXB0IHNvcnQgYWxnb3JpdGhtIG9uIFY4IGlzIG5vdyBzdGFibGUuIFRoZSBkZWZhdWx0IHNvcnQgb3JkZXIgaXMgYWNjb3JkaW5nIHRvIHN0cmluZyBVbmljb2RlIGNvZGUgcG9pbnRzLlxyXG4gICAgICogVGhlIHRpbWUgYW5kIHNwYWNlIGNvbXBsZXhpdHkgb2YgdGhlIHNvcnQgY2Fubm90IGJlIGd1YXJhbnRlZWQgYXMgaXQgaXMgaW1wbGVtZW50YXRpb24gZGVwZW5kZW50LlxyXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydFxyXG4gICAgICogQHBhcmFtIGNvbXBhcmVGdW5jdGlvbiBTcGVjaWZpZXMgYSBmdW5jdGlvbiB0aGF0IGRlZmluZXMgdGhlIHNvcnQgb3JkZXIuIElmIG9taXR0ZWQsIHRoZSBhcnJheSBpcyBzb3J0ZWQgYWNjb3JkaW5nIHRvIGVhY2ggY2hhcmFjdGVyJ3MgVW5pY29kZSBjb2RlIHBvaW50IHZhbHVlLCBhY2NvcmRpbmcgdG8gdGhlIHN0cmluZyBjb252ZXJzaW9uIG9mIGVhY2ggZWxlbWVudC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBzb3J0ZWQgYXJyYXkuIE5vdGUgdGhhdCB0aGUgYXJyYXkgaXMgc29ydGVkIGluIHBsYWNlLCBhbmQgbm8gY29weSBpcyBtYWRlLlxyXG4gICAgICovXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbiAgICBPYnNlcnZhYmxlQXJyYXlJbXBsZW1lbnRhdGlvbi5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChjb21wYXJlRnVuY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZUFycmF5JHNvcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzcGxpY2UoKSBtZXRob2QgY2hhbmdlcyB0aGUgY29udGVudHMgb2YgYW4gYXJyYXkgYnkgcmVtb3ZpbmcgZXhpc3RpbmcgZWxlbWVudHMgYW5kL29yIGFkZGluZyBuZXcgZWxlbWVudHMuXHJcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zcGxpY2VcclxuICAgICAqIEBwYXJhbSBzdGFydCAgSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY2hhbmdpbmcgdGhlIGFycmF5ICh3aXRoIG9yaWdpbiAwKS4gSWYgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LCBhY3R1YWwgc3RhcnRpbmcgaW5kZXggd2lsbCBiZSBzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuIElmIG5lZ2F0aXZlLCB3aWxsIGJlZ2luIHRoYXQgbWFueSBlbGVtZW50cyBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5ICh3aXRoIG9yaWdpbiAtMSkgYW5kIHdpbGwgYmUgc2V0IHRvIDAgaWYgYWJzb2x1dGUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxyXG4gICAgICogQHBhcmFtIGRlbGV0ZUNvdW50IEFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgbnVtYmVyIG9mIG9sZCBhcnJheSBlbGVtZW50cyB0byByZW1vdmUuIElmIGRlbGV0ZUNvdW50IGlzIG9taXR0ZWQsIG9yIGlmIGl0cyB2YWx1ZSBpcyBsYXJnZXIgdGhhbiBhcnJheS5sZW5ndGggLSBzdGFydCAodGhhdCBpcywgaWYgaXQgaXMgZ3JlYXRlciB0aGFuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgbGVmdCBpbiB0aGUgYXJyYXksIHN0YXJ0aW5nIGF0IHN0YXJ0KSwgdGhlbiBhbGwgb2YgdGhlIGVsZW1lbnRzIGZyb20gc3RhcnQgdGhyb3VnaCB0aGUgZW5kIG9mIHRoZSBhcnJheSB3aWxsIGJlIGRlbGV0ZWQuIElmIGRlbGV0ZUNvdW50IGlzIDAgb3IgbmVnYXRpdmUsIG5vIGVsZW1lbnRzIGFyZSByZW1vdmVkLiBJbiB0aGlzIGNhc2UsIHlvdSBzaG91bGQgc3BlY2lmeSBhdCBsZWFzdCBvbmUgbmV3IGVsZW1lbnQgKHNlZSBiZWxvdykuXHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgYXJyYXksIGJlZ2lubmluZyBhdCB0aGUgc3RhcnQgaW5kZXguIElmIHlvdSBkb24ndCBzcGVjaWZ5IGFueSBlbGVtZW50cywgc3BsaWNlKCkgd2lsbCBvbmx5IHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheS5cclxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRlbGV0ZWQgZWxlbWVudHMuIElmIG9ubHkgb25lIGVsZW1lbnQgaXMgcmVtb3ZlZCwgYW4gYXJyYXkgb2Ygb25lIGVsZW1lbnQgaXMgcmV0dXJuZWQuIElmIG5vIGVsZW1lbnRzIGFyZSByZW1vdmVkLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24ucHJvdG90eXBlLnNwbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZGVsZXRlQ291bnQpIHtcclxuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBpdGVtc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVBcnJheSRzcGxpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB1bnNoaWZ0KCkgbWV0aG9kIGFkZHMgb25lIG9yIG1vcmUgZWxlbWVudHMgdG8gdGhlIGJlZ2lubmluZyBvZiBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGUgbmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXHJcbiAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS91bnNoaWZ0XHJcbiAgICAgKiBAcGFyYW0gaXRlbXMgVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgZnJvbnQgb2YgdGhlIGFycmF5LlxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBsZW5ndGggcHJvcGVydHkgb2YgdGhlIG9iamVjdCB1cG9uIHdoaWNoIHRoZSBtZXRob2Qgd2FzIGNhbGxlZC5cclxuICAgICAqL1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG4gICAgT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24ucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGVBcnJheSR1bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9ic2VydmFibGVBcnJheUltcGxlbWVudGF0aW9uO1xyXG59KEFycmF5KSk7XHJcbmV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5SW1wbGVtZW50YXRpb24gPSBPYnNlcnZhYmxlQXJyYXlJbXBsZW1lbnRhdGlvbjtcclxuLyoqXHJcbiAqIE92ZXJyaWRlJ3MgbmF0aXZlIEFycmF5IG1ldGhvZHMgdGhhdCBtYW5pcHVsYXRlIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHRvIGV4dGVuZFxyXG4gKi9cclxuZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5JG92ZXJyaWRlTmF0aXZlTWV0aG9kcygpIHtcclxuICAgIHRoaXNbXCJjb3B5V2l0aGluXCJdID0gT2JzZXJ2YWJsZUFycmF5JGNvcHlXaXRoaW47XHJcbiAgICB0aGlzW1wiZmlsbFwiXSA9IE9ic2VydmFibGVBcnJheSRmaWxsO1xyXG4gICAgdGhpc1tcInBvcFwiXSA9IE9ic2VydmFibGVBcnJheSRwb3A7XHJcbiAgICB0aGlzW1wicHVzaFwiXSA9IE9ic2VydmFibGVBcnJheSRwdXNoO1xyXG4gICAgdGhpc1tcInJldmVyc2VcIl0gPSBPYnNlcnZhYmxlQXJyYXkkcmV2ZXJzZTtcclxuICAgIHRoaXNbXCJzaGlmdFwiXSA9IE9ic2VydmFibGVBcnJheSRzaGlmdDtcclxuICAgIHRoaXNbXCJzb3J0XCJdID0gT2JzZXJ2YWJsZUFycmF5JHNvcnQ7XHJcbiAgICB0aGlzW1wic3BsaWNlXCJdID0gT2JzZXJ2YWJsZUFycmF5JHNwbGljZTtcclxuICAgIHRoaXNbXCJ1bnNoaWZ0XCJdID0gT2JzZXJ2YWJsZUFycmF5JHVuc2hpZnQ7XHJcbn1cclxuZXhwb3J0cy5PYnNlcnZhYmxlQXJyYXkkb3ZlcnJpZGVOYXRpdmVNZXRob2RzID0gT2JzZXJ2YWJsZUFycmF5JG92ZXJyaWRlTmF0aXZlTWV0aG9kcztcclxuLyoqXHJcbiAqIEJlZ2luIHF1ZXVlaW5nIGNoYW5nZXMgdG8gdGhlIGFycmF5LCBtYWtlIGNoYW5nZXMgaW4gdGhlIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uLCB0aGVuIHN0b3AgcXVldWVpbmcgYW5kIHJhaXNlIGV2ZW50c1xyXG4gKi9cclxuZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5JGJhdGNoVXBkYXRlKGZuLCBhZGRpdGlvbmFsQXJncykge1xyXG4gICAgaWYgKGFkZGl0aW9uYWxBcmdzID09PSB2b2lkIDApIHsgYWRkaXRpb25hbEFyZ3MgPSBudWxsOyB9XHJcbiAgICB0aGlzLl9fYW9iX18uc3RhcnRRdWV1ZWluZ0NoYW5nZXMoKTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgZm4odGhpcyk7XHJcbiAgICAgICAgdGhpcy5fX2FvYl9fLnN0b3BRdWV1ZWluZ0NoYW5nZXModHJ1ZSwgYWRkaXRpb25hbEFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX19hb2JfXy5faXNRdWV1aW5nQ2hhbmdlcykge1xyXG4gICAgICAgICAgICB0aGlzLl9fYW9iX18uc3RvcFF1ZXVlaW5nQ2hhbmdlcyhmYWxzZSwgYWRkaXRpb25hbEFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLk9ic2VydmFibGVBcnJheSRiYXRjaFVwZGF0ZSA9IE9ic2VydmFibGVBcnJheSRiYXRjaFVwZGF0ZTtcclxuLyoqXHJcbiAqIFRoZSBjb3B5V2l0aGluKCkgbWV0aG9kIHNoYWxsb3cgY29waWVzIHBhcnQgb2YgYW4gYXJyYXkgdG8gYW5vdGhlciBsb2NhdGlvbiBpbiB0aGUgc2FtZSBhcnJheSBhbmQgcmV0dXJucyBpdCwgd2l0aG91dCBtb2RpZnlpbmcgaXRzIHNpemUuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2NvcHlXaXRoaW5cclxuICogQHBhcmFtIGFycmF5IFRoZSBvYnNlcnZhYmxlIGFycmF5XHJcbiAqIEBwYXJhbSB0YXJnZXQgWmVybyBiYXNlZCBpbmRleCBhdCB3aGljaCB0byBjb3B5IHRoZSBzZXF1ZW5jZSB0by4gSWYgbmVnYXRpdmUsIHRhcmdldCB3aWxsIGJlIGNvdW50ZWQgZnJvbSB0aGUgZW5kLiBJZiB0YXJnZXQgaXMgYXQgb3IgZ3JlYXRlciB0aGFuIGFyci5sZW5ndGgsIG5vdGhpbmcgd2lsbCBiZSBjb3BpZWQuIElmIHRhcmdldCBpcyBwb3NpdGlvbmVkIGFmdGVyIHN0YXJ0LCB0aGUgY29waWVkIHNlcXVlbmNlIHdpbGwgYmUgdHJpbW1lZCB0byBmaXQgYXJyLmxlbmd0aC5cclxuICogQHBhcmFtIHN0YXJ0IFplcm8gYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgY29weWluZyBlbGVtZW50cyBmcm9tLiBJZiBuZWdhdGl2ZSwgc3RhcnQgd2lsbCBiZSBjb3VudGVkIGZyb20gdGhlIGVuZC4gSWYgc3RhcnQgaXMgb21pdHRlZCwgY29weVdpdGhpbiB3aWxsIGNvcHkgZnJvbSB0aGUgc3RhcnQgKGRlZmF1bHRzIHRvIDApLlxyXG4gKiBAcGFyYW0gZW5kIFplcm8gYmFzZWQgaW5kZXggYXQgd2hpY2ggdG8gZW5kIGNvcHlpbmcgZWxlbWVudHMgZnJvbS4gY29weVdpdGhpbiBjb3BpZXMgdXAgdG8gYnV0IG5vdCBpbmNsdWRpbmcgZW5kLiBJZiBuZWdhdGl2ZSwgZW5kIHdpbGwgYmUgY291bnRlZCBmcm9tIHRoZSBlbmQuIElmIGVuZCBpcyBvbWl0dGVkLCBjb3B5V2l0aGluIHdpbGwgY29weSB1bnRpbCB0aGUgZW5kIChkZWZhdWx0IHRvIGFyci5sZW5ndGgpLlxyXG4gKi9cclxuZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5JGNvcHlXaXRoaW4odGFyZ2V0LCBzdGFydCwgZW5kKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgLy8gVE9ETzogV2FybiBhYm91dCBub24tb2JzZXJ2YWJsZSBtYW5pcHVsYXRpb24gb2Ygb2JzZXJ2YWJsZSBhcnJheT9cclxuICAgIHRoaXMuX19hb2JfXy5yYWlzZUV2ZW50cyh7IHR5cGU6IEFycmF5Q2hhbmdlVHlwZS5yZXBsYWNlLCBzdGFydEluZGV4OiBzdGFydCwgZW5kSW5kZXg6IGVuZCB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5JGNvcHlXaXRoaW4gPSBPYnNlcnZhYmxlQXJyYXkkY29weVdpdGhpbjtcclxuLyoqXHJcbiAqIFRoZSBmaWxsKCkgbWV0aG9kIGZpbGxzIGFsbCB0aGUgZWxlbWVudHMgb2YgYW4gYXJyYXkgZnJvbSBhIHN0YXJ0IGluZGV4IHRvIGFuIGVuZCBpbmRleCB3aXRoIGEgc3RhdGljIHZhbHVlLiBUaGUgZW5kIGluZGV4IGlzIG5vdCBpbmNsdWRlZC5cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsbFxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIG9ic2VydmFibGUgYXJyYXlcclxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGZpbGwgYW4gYXJyYXkuXHJcbiAqIEBwYXJhbSBzdGFydCBTdGFydCBpbmRleCwgZGVmYXVsdHMgdG8gMC5cclxuICogQHBhcmFtIGVuZCBFbmQgaW5kZXgsIGRlZmF1bHRzIHRvIHRoaXMubGVuZ3RoLlxyXG4gKi9cclxuZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5JGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcclxuICAgIEFycmF5LnByb3RvdHlwZS5maWxsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAvLyBUT0RPOiBXYXJuIGFib3V0IG5vbi1vYnNlcnZhYmxlIG1hbmlwdWxhdGlvbiBvZiBvYnNlcnZhYmxlIGFycmF5P1xyXG4gICAgdGhpcy5fX2FvYl9fLnJhaXNlRXZlbnRzKHsgdHlwZTogQXJyYXlDaGFuZ2VUeXBlLnJlcGxhY2UsIHN0YXJ0SW5kZXg6IHN0YXJ0LCBlbmRJbmRleDogZW5kIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZXhwb3J0cy5PYnNlcnZhYmxlQXJyYXkkZmlsbCA9IE9ic2VydmFibGVBcnJheSRmaWxsO1xyXG4vKipcclxuICogVGhlIHBvcCgpIG1ldGhvZCByZW1vdmVzIHRoZSBsYXN0IGVsZW1lbnQgZnJvbSBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGF0IGVsZW1lbnQuIFRoaXMgbWV0aG9kIGNoYW5nZXMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3BvcFxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIG9ic2VydmFibGUgYXJyYXlcclxuICogQHJldHVybnMgVGhlIHJlbW92ZWQgZWxlbWVudCBmcm9tIHRoZSBhcnJheTsgdW5kZWZpbmVkIGlmIHRoZSBhcnJheSBpcyBlbXB0eS5cclxuICovXHJcbmZ1bmN0aW9uIE9ic2VydmFibGVBcnJheSRwb3AoKSB7XHJcbiAgICB2YXIgb3JpZ2luYWxMZW5ndGggPSB0aGlzLmxlbmd0aDtcclxuICAgIHZhciByZW1vdmVkID0gQXJyYXkucHJvdG90eXBlLnBvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgaWYgKHRoaXMubGVuZ3RoICE9PSBvcmlnaW5hbExlbmd0aCkge1xyXG4gICAgICAgIHZhciByZW1vdmVkSW5kZXggPSBvcmlnaW5hbExlbmd0aCAtIDE7XHJcbiAgICAgICAgdGhpcy5fX2FvYl9fLnJhaXNlRXZlbnRzKHsgdHlwZTogQXJyYXlDaGFuZ2VUeXBlLnJlbW92ZSwgc3RhcnRJbmRleDogcmVtb3ZlZEluZGV4LCBlbmRJbmRleDogcmVtb3ZlZEluZGV4LCBpdGVtczogW3JlbW92ZWRdIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZWQ7XHJcbn1cclxuZXhwb3J0cy5PYnNlcnZhYmxlQXJyYXkkcG9wID0gT2JzZXJ2YWJsZUFycmF5JHBvcDtcclxuLyoqXHJcbiAqIFRoZSBwdXNoKCkgbWV0aG9kIGFkZHMgb25lIG9yIG1vcmUgZWxlbWVudHMgdG8gdGhlIGVuZCBvZiBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGUgbmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3B1c2hcclxuICogQHBhcmFtIGFycmF5IFRoZSBvYnNlcnZhYmxlIGFycmF5XHJcbiAqIEBwYXJhbSBpdGVtcyBUaGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxyXG4gKiBAcmV0dXJucyBUaGUgbmV3IGxlbmd0aCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IHVwb24gd2hpY2ggdGhlIG1ldGhvZCB3YXMgY2FsbGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5JHB1c2goKSB7XHJcbiAgICB2YXIgaXRlbXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgaXRlbXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIC8vIEJVRzogQmFiZWwncyBoYW5kbGluZyBvZiByZXN0IGFyZ3VtZW50cyBzZWVtcyB0byBiZSB0aHJvd24gb2ZmIGJ5IDEgKGR1ZSB0byB0aGUgXCJ0aGlzXCIgYXJndW1lbnQ/KSAtIGNvZ25pdG9mb3Jtcy9tb2RlbC5qczojNVxyXG4gICAgaXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgdmFyIG9yaWdpbmFsTGVuZ3RoID0gdGhpcy5sZW5ndGg7XHJcbiAgICB2YXIgbmV3TGVuZ3RoID0gQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIGlmIChuZXdMZW5ndGggPiAwKSB7XHJcbiAgICAgICAgdGhpcy5fX2FvYl9fLnJhaXNlRXZlbnRzKHsgdHlwZTogQXJyYXlDaGFuZ2VUeXBlLmFkZCwgc3RhcnRJbmRleDogb3JpZ2luYWxMZW5ndGgsIGVuZEluZGV4OiBvcmlnaW5hbExlbmd0aCArIChuZXdMZW5ndGggLSBvcmlnaW5hbExlbmd0aCkgLSAxLCBpdGVtczogaXRlbXMgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3TGVuZ3RoO1xyXG59XHJcbmV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5JHB1c2ggPSBPYnNlcnZhYmxlQXJyYXkkcHVzaDtcclxuLyoqXHJcbiAqIFRoZSByZXZlcnNlKCkgbWV0aG9kIHJldmVyc2VzIGFuIGFycmF5IGluIHBsYWNlLiBUaGUgZmlyc3QgYXJyYXkgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCBhbmQgdGhlIGxhc3QgYXJyYXkgZWxlbWVudCBiZWNvbWVzIHRoZSBmaXJzdC5cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvcmV2ZXJzZVxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIG9ic2VydmFibGUgYXJyYXlcclxuICogQHJldHVybnMgVGhlIHJldmVyc2VkIGFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5JHJldmVyc2UoKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgLy8gVE9ETzogV2FybiBhYm91dCBub24tb2JzZXJ2YWJsZSBtYW5pcHVsYXRpb24gb2Ygb2JzZXJ2YWJsZSBhcnJheT9cclxuICAgIHRoaXMuX19hb2JfXy5yYWlzZUV2ZW50cyh7IHR5cGU6IEFycmF5Q2hhbmdlVHlwZS5yZW9yZGVyLCBzdGFydEluZGV4OiAwLCBlbmRJbmRleDogdGhpcy5sZW5ndGggLSAxIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn1cclxuZXhwb3J0cy5PYnNlcnZhYmxlQXJyYXkkcmV2ZXJzZSA9IE9ic2VydmFibGVBcnJheSRyZXZlcnNlO1xyXG4vKipcclxuICogVGhlIHNoaWZ0KCkgbWV0aG9kIHJlbW92ZXMgdGhlIGZpcnN0IGVsZW1lbnQgZnJvbSBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGF0IHJlbW92ZWQgZWxlbWVudC4gVGhpcyBtZXRob2QgY2hhbmdlcyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2hpZnRcclxuICogQHBhcmFtIGFycmF5IFRoZSBvYnNlcnZhYmxlIGFycmF5XHJcbiAqIEByZXR1cm5zIFRoZSByZW1vdmVkIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXk7IHVuZGVmaW5lZCBpZiB0aGUgYXJyYXkgaXMgZW1wdHkuXHJcbiAqL1xyXG5mdW5jdGlvbiBPYnNlcnZhYmxlQXJyYXkkc2hpZnQoKSB7XHJcbiAgICB2YXIgb3JpZ2luYWxMZW5ndGggPSB0aGlzLmxlbmd0aDtcclxuICAgIHZhciByZW1vdmVkID0gQXJyYXkucHJvdG90eXBlLnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAodGhpcy5sZW5ndGggIT09IG9yaWdpbmFsTGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5fX2FvYl9fLnJhaXNlRXZlbnRzKHsgdHlwZTogQXJyYXlDaGFuZ2VUeXBlLnJlbW92ZSwgc3RhcnRJbmRleDogMCwgZW5kSW5kZXg6IDAsIGl0ZW1zOiBbcmVtb3ZlZF0gfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlZDtcclxufVxyXG5leHBvcnRzLk9ic2VydmFibGVBcnJheSRzaGlmdCA9IE9ic2VydmFibGVBcnJheSRzaGlmdDtcclxuLyoqXHJcbiAqIFRoZSBzb3J0KCkgbWV0aG9kIHNvcnRzIHRoZSBlbGVtZW50cyBvZiBhbiBhcnJheSBpbiBwbGFjZSBhbmQgcmV0dXJucyB0aGUgYXJyYXkuIEphdmFzY3JpcHQgc29ydCBhbGdvcml0aG0gb24gVjggaXMgbm93IHN0YWJsZS4gVGhlIGRlZmF1bHQgc29ydCBvcmRlciBpcyBhY2NvcmRpbmcgdG8gc3RyaW5nIFVuaWNvZGUgY29kZSBwb2ludHMuXHJcbiAqIFRoZSB0aW1lIGFuZCBzcGFjZSBjb21wbGV4aXR5IG9mIHRoZSBzb3J0IGNhbm5vdCBiZSBndWFyYW50ZWVkIGFzIGl0IGlzIGltcGxlbWVudGF0aW9uIGRlcGVuZGVudC5cclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydFxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIG9ic2VydmFibGUgYXJyYXlcclxuICogQHBhcmFtIGNvbXBhcmVGdW5jdGlvbiBTcGVjaWZpZXMgYSBmdW5jdGlvbiB0aGF0IGRlZmluZXMgdGhlIHNvcnQgb3JkZXIuIElmIG9taXR0ZWQsIHRoZSBhcnJheSBpcyBzb3J0ZWQgYWNjb3JkaW5nIHRvIGVhY2ggY2hhcmFjdGVyJ3MgVW5pY29kZSBjb2RlIHBvaW50IHZhbHVlLCBhY2NvcmRpbmcgdG8gdGhlIHN0cmluZyBjb252ZXJzaW9uIG9mIGVhY2ggZWxlbWVudC5cclxuICogQHJldHVybnMgVGhlIHNvcnRlZCBhcnJheS4gTm90ZSB0aGF0IHRoZSBhcnJheSBpcyBzb3J0ZWQgaW4gcGxhY2UsIGFuZCBubyBjb3B5IGlzIG1hZGUuXHJcbiAqL1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXHJcbmZ1bmN0aW9uIE9ic2VydmFibGVBcnJheSRzb3J0KGNvbXBhcmVGdW5jdGlvbikge1xyXG4gICAgQXJyYXkucHJvdG90eXBlLnNvcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIC8vIFRPRE86IFdhcm4gYWJvdXQgbm9uLW9ic2VydmFibGUgbWFuaXB1bGF0aW9uIG9mIG9ic2VydmFibGUgYXJyYXk/XHJcbiAgICB0aGlzLl9fYW9iX18ucmFpc2VFdmVudHMoeyB0eXBlOiBBcnJheUNoYW5nZVR5cGUucmVvcmRlciwgc3RhcnRJbmRleDogMCwgZW5kSW5kZXg6IHRoaXMubGVuZ3RoIC0gMSB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59XHJcbmV4cG9ydHMuT2JzZXJ2YWJsZUFycmF5JHNvcnQgPSBPYnNlcnZhYmxlQXJyYXkkc29ydDtcclxuLyoqXHJcbiAqIFRoZSBzcGxpY2UoKSBtZXRob2QgY2hhbmdlcyB0aGUgY29udGVudHMgb2YgYW4gYXJyYXkgYnkgcmVtb3ZpbmcgZXhpc3RpbmcgZWxlbWVudHMgYW5kL29yIGFkZGluZyBuZXcgZWxlbWVudHMuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NwbGljZVxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIG9ic2VydmFibGUgYXJyYXlcclxuICogQHBhcmFtIHN0YXJ0ICBJbmRleCBhdCB3aGljaCB0byBzdGFydCBjaGFuZ2luZyB0aGUgYXJyYXkgKHdpdGggb3JpZ2luIDApLiBJZiBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXksIGFjdHVhbCBzdGFydGluZyBpbmRleCB3aWxsIGJlIHNldCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS4gSWYgbmVnYXRpdmUsIHdpbGwgYmVnaW4gdGhhdCBtYW55IGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkgKHdpdGggb3JpZ2luIC0xKSBhbmQgd2lsbCBiZSBzZXQgdG8gMCBpZiBhYnNvbHV0ZSB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBkZWxldGVDb3VudCBBbiBpbnRlZ2VyIGluZGljYXRpbmcgdGhlIG51bWJlciBvZiBvbGQgYXJyYXkgZWxlbWVudHMgdG8gcmVtb3ZlLiBJZiBkZWxldGVDb3VudCBpcyBvbWl0dGVkLCBvciBpZiBpdHMgdmFsdWUgaXMgbGFyZ2VyIHRoYW4gYXJyYXkubGVuZ3RoIC0gc3RhcnQgKHRoYXQgaXMsIGlmIGl0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGxlZnQgaW4gdGhlIGFycmF5LCBzdGFydGluZyBhdCBzdGFydCksIHRoZW4gYWxsIG9mIHRoZSBlbGVtZW50cyBmcm9tIHN0YXJ0IHRocm91Z2ggdGhlIGVuZCBvZiB0aGUgYXJyYXkgd2lsbCBiZSBkZWxldGVkLiBJZiBkZWxldGVDb3VudCBpcyAwIG9yIG5lZ2F0aXZlLCBubyBlbGVtZW50cyBhcmUgcmVtb3ZlZC4gSW4gdGhpcyBjYXNlLCB5b3Ugc2hvdWxkIHNwZWNpZnkgYXQgbGVhc3Qgb25lIG5ldyBlbGVtZW50IChzZWUgYmVsb3cpLlxyXG4gKiBAcGFyYW0gaXRlbXMgVGhlIGVsZW1lbnRzIHRvIGFkZCB0byB0aGUgYXJyYXksIGJlZ2lubmluZyBhdCB0aGUgc3RhcnQgaW5kZXguIElmIHlvdSBkb24ndCBzcGVjaWZ5IGFueSBlbGVtZW50cywgc3BsaWNlKCkgd2lsbCBvbmx5IHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBhcnJheS5cclxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZGVsZXRlZCBlbGVtZW50cy4gSWYgb25seSBvbmUgZWxlbWVudCBpcyByZW1vdmVkLCBhbiBhcnJheSBvZiBvbmUgZWxlbWVudCBpcyByZXR1cm5lZC4gSWYgbm8gZWxlbWVudHMgYXJlIHJlbW92ZWQsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxyXG4gKi9cclxuZnVuY3Rpb24gT2JzZXJ2YWJsZUFycmF5JHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQpIHtcclxuICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBpdGVtc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIC8vIEJVRzogQmFiZWwncyBoYW5kbGluZyBvZiByZXN0IGFyZ3VtZW50cyBzZWVtcyB0byBiZSB0aHJvd24gb2ZmIGJ5IDEgKGR1ZSB0byB0aGUgXCJ0aGlzXCIgYXJndW1lbnQ/KSAtIGNvZ25pdG9mb3Jtcy9tb2RlbC5qczojNVxyXG4gICAgaXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgdmFyIHJlbW92ZWQgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICBpZiAocmVtb3ZlZC5sZW5ndGggPiAwIHx8IGl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXIgY2hhbmdlRXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjaGFuZ2VFdmVudHMucHVzaCh7IHR5cGU6IEFycmF5Q2hhbmdlVHlwZS5yZW1vdmUsIHN0YXJ0SW5kZXg6IHN0YXJ0LCBlbmRJbmRleDogc3RhcnQgKyByZW1vdmVkLmxlbmd0aCAtIDEsIGl0ZW1zOiByZW1vdmVkIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjaGFuZ2VFdmVudHMucHVzaCh7IHR5cGU6IEFycmF5Q2hhbmdlVHlwZS5hZGQsIHN0YXJ0SW5kZXg6IHN0YXJ0LCBlbmRJbmRleDogc3RhcnQgKyBpdGVtcy5sZW5ndGggLSAxLCBpdGVtczogaXRlbXMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX19hb2JfXy5yYWlzZUV2ZW50cyhjaGFuZ2VFdmVudHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZWQ7XHJcbn1cclxuZXhwb3J0cy5PYnNlcnZhYmxlQXJyYXkkc3BsaWNlID0gT2JzZXJ2YWJsZUFycmF5JHNwbGljZTtcclxuLyoqXHJcbiAqIFRoZSB1bnNoaWZ0KCkgbWV0aG9kIGFkZHMgb25lIG9yIG1vcmUgZWxlbWVudHMgdG8gdGhlIGJlZ2lubmluZyBvZiBhbiBhcnJheSBhbmQgcmV0dXJucyB0aGUgbmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3Vuc2hpZnRcclxuICogQHBhcmFtIGFycmF5IFRoZSBvYnNlcnZhYmxlIGFycmF5XHJcbiAqIEBwYXJhbSBpdGVtcyBUaGUgZWxlbWVudHMgdG8gYWRkIHRvIHRoZSBmcm9udCBvZiB0aGUgYXJyYXkuXHJcbiAqIEByZXR1cm5zIFRoZSBuZXcgbGVuZ3RoIHByb3BlcnR5IG9mIHRoZSBvYmplY3QgdXBvbiB3aGljaCB0aGUgbWV0aG9kIHdhcyBjYWxsZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBPYnNlcnZhYmxlQXJyYXkkdW5zaGlmdCgpIHtcclxuICAgIHZhciBpdGVtcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgLy8gQlVHOiBCYWJlbCdzIGhhbmRsaW5nIG9mIHJlc3QgYXJndW1lbnRzIHNlZW1zIHRvIGJlIHRocm93biBvZmYgYnkgMSAoZHVlIHRvIHRoZSBcInRoaXNcIiBhcmd1bWVudD8pIC0gY29nbml0b2Zvcm1zL21vZGVsLmpzOiM1XHJcbiAgICBpdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICB2YXIgb3JpZ2luYWxMZW5ndGggPSB0aGlzLmxlbmd0aDtcclxuICAgIHZhciBuZXdMZW5ndGggPSBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgaWYgKG5ld0xlbmd0aCAhPT0gb3JpZ2luYWxMZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9fYW9iX18ucmFpc2VFdmVudHMoeyB0eXBlOiBBcnJheUNoYW5nZVR5cGUuYWRkLCBzdGFydEluZGV4OiAwLCBlbmRJbmRleDogaXRlbXMubGVuZ3RoIC0gMSwgaXRlbXM6IGl0ZW1zIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ld0xlbmd0aDtcclxufVxyXG5leHBvcnRzLk9ic2VydmFibGVBcnJheSR1bnNoaWZ0ID0gT2JzZXJ2YWJsZUFycmF5JHVuc2hpZnQ7XHJcbnZhciBBcnJheU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQXJyYXlPYnNlcnZlcihhcnJheSkge1xyXG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBuZXcgZXZlbnRzXzEuRXZlbnQoKTtcclxuICAgICAgICB0aGlzLl9pc1F1ZXVpbmdDaGFuZ2VzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBBcnJheU9ic2VydmVyLnByb3RvdHlwZS5yYWlzZUV2ZW50cyA9IGZ1bmN0aW9uIChjaGFuZ2VzLCBhZGRpdGlvbmFsQXJncykge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1F1ZXVpbmdDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcXVldWVkQ2hhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVkQ2hhbmdlcyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoYW5nZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLl9xdWV1ZWRDaGFuZ2VzLCBjaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlZENoYW5nZXMucHVzaChjaGFuZ2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoYW5nZXMpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aClcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZC5wdWJsaXNoKHRoaXMuYXJyYXksIHsgY2hhbmdlczogY2hhbmdlcywgYWRkaXRpb25hbEFyZ3M6IGFkZGl0aW9uYWxBcmdzIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkLnB1Ymxpc2godGhpcy5hcnJheSwgeyBjaGFuZ2VzOiBbY2hhbmdlc10sIGFkZGl0aW9uYWxBcmdzOiBhZGRpdGlvbmFsQXJncyB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXJyYXlPYnNlcnZlci5wcm90b3R5cGUuc3RhcnRRdWV1ZWluZ0NoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faXNRdWV1aW5nQ2hhbmdlcyA9IHRydWU7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZWRDaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlZENoYW5nZXMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXJyYXlPYnNlcnZlci5wcm90b3R5cGUuc3RvcFF1ZXVlaW5nQ2hhbmdlcyA9IGZ1bmN0aW9uIChyYWlzZUV2ZW50cywgYWRkaXRpb25hbEFyZ3MpIHtcclxuICAgICAgICBpZiAoYWRkaXRpb25hbEFyZ3MgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsQXJncyA9IG51bGw7IH1cclxuICAgICAgICB0aGlzLl9pc1F1ZXVpbmdDaGFuZ2VzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHJhaXNlRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFpc2VFdmVudHModGhpcy5fcXVldWVkQ2hhbmdlcywgYWRkaXRpb25hbEFyZ3MpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcXVldWVkQ2hhbmdlcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFycmF5T2JzZXJ2ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQXJyYXlPYnNlcnZlciA9IEFycmF5T2JzZXJ2ZXI7XHJcbmZ1bmN0aW9uIGNhbGxTcGxpY2UoYXJyLCBpbmRleCwgcmVtb3ZlQ291bnQsIGFkZEl0ZW1zKSB7XHJcbiAgICBpZiAocmVtb3ZlQ291bnQgfHwgYWRkSXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhciBhZGRJdGVtc0FyZ3MgPSBbaW5kZXgsIHJlbW92ZUNvdW50XS5jb25jYXQoYWRkSXRlbXMpO1xyXG4gICAgICAgIGFyci5zcGxpY2UuYXBwbHkoYXJyLCBhZGRJdGVtc0FyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHVwZGF0ZUFycmF5KGFycmF5LCB2YWx1ZXMpIHtcclxuICAgIHZhciBwb2ludGVyID0gMDtcclxuICAgIHZhciBzcmNTZWVrID0gMDtcclxuICAgIHZhciB0Z3RTZWVrID0gMDtcclxuICAgIHdoaWxlIChzcmNTZWVrIDwgYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKGFycmF5W3NyY1NlZWtdID09PSB2YWx1ZXNbdGd0U2Vla10pIHtcclxuICAgICAgICAgICAgaWYgKHBvaW50ZXIgPT09IHNyY1NlZWsgJiYgcG9pbnRlciA9PT0gdGd0U2Vlaykge1xyXG4gICAgICAgICAgICAgICAgLy8gaXRlbXMgbWF0Y2gsIHNvIGFkdmFuY2VcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBzcmNTZWVrID0gdGd0U2VlayA9IHBvaW50ZXIgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJhbmdlIGZyb20gc291cmNlIGFuZCBhZGQgcmFuZ2UgZnJvbSB0YXJnZXRcclxuICAgICAgICAgICAgICAgIGNhbGxTcGxpY2UoYXJyYXksIHBvaW50ZXIsIHNyY1NlZWsgLSBwb2ludGVyLCB2YWx1ZXMuc2xpY2UocG9pbnRlciwgdGd0U2VlaykpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdG8gaW5kZXggZm9sbG93IHRhcmdldCBzZWVrIGxvY2F0aW9uIHNpbmNlIGFycmF5cyBtYXRjaCB1cCB0byB0aGF0IHBvaW50XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyID0gc3JjU2VlayA9IHRndFNlZWsgPSB0Z3RTZWVrICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0Z3RTZWVrID49IHZhbHVlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSB0YXJnZXQgYXJyYXksIHNvIGFkdmFuY2UgdGhlIHNyYyBwb2ludGVyIGFuZCB0ZXN0IGFnYWluXHJcbiAgICAgICAgICAgIHRndFNlZWsgPSBwb2ludGVyO1xyXG4gICAgICAgICAgICBzcmNTZWVrICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBhZHZhbmNlIHRvIHRoZSBuZXh0IHRhcmdldCBpdGVtIHRvIHRlc3RcclxuICAgICAgICAgICAgdGd0U2VlayArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhbGxTcGxpY2UoYXJyYXksIHBvaW50ZXIsIHNyY1NlZWsgLSBwb2ludGVyLCB2YWx1ZXMuc2xpY2UocG9pbnRlciwgTWF0aC5tYXgodGd0U2VlaywgdmFsdWVzLmxlbmd0aCkpKTtcclxufVxyXG5leHBvcnRzLnVwZGF0ZUFycmF5ID0gdXBkYXRlQXJyYXk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUHJvcGVydHlDaGFpbiA9IHZvaWQgMDtcclxudmFyIHByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eVwiKTtcclxudmFyIGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xyXG52YXIgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XHJcbi8qKlxyXG4gKiBFbmNhcHN1bGF0ZXMgdGhlIGxvZ2ljIHJlcXVpcmVkIHRvIHdvcmsgd2l0aCBhIGNoYWluIG9mIHByb3BlcnRpZXMgYW5kXHJcbiAqIGEgcm9vdCBvYmplY3QsIGFsbG93aW5nIGludGVyYWN0aW9uIHdpdGggdGhlIGNoYWluIGFzIGlmIGl0IHdlcmUgYVxyXG4gKiBzaW5nbGUgcHJvcGVydHkgb2YgdGhlIHJvb3Qgb2JqZWN0LlxyXG4gKi9cclxudmFyIFByb3BlcnR5Q2hhaW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcm9wZXJ0eUNoYWluKHJvb3RUeXBlLCBwYXRoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJvb3RUeXBlID0gcm9vdFR5cGU7XHJcbiAgICAgICAgLy8gcmVwbGFjZSBcIi5cIiBpbiB0eXBlIGNhc3RzIHNvIHRoYXQgdGhleSBkbyBub3QgaW50ZXJmZXJlIHdpdGggc3BsaXR0aW5nIHBhdGhcclxuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC88W14+XSo+L2lnLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS5yZXBsYWNlKC9cXC4vaWcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiJF8kXCI7IH0pOyB9KTtcclxuICAgICAgICB2YXIgY3VycmVudFR5cGUgPSByb290VHlwZTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwYXRoLnNwbGl0KFwiLlwiKS5tYXAoZnVuY3Rpb24gKHN0ZXApIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5O1xyXG4gICAgICAgICAgICAvLyBSZWdleCBwYXR0ZXJuIG1hdGNoZXMgYWxsIGxldHRlcnMgYW5kIGRpZ2l0cyB0aGF0IGFyZSB2YWxpZCBmb3IgamF2YXNjcmlwdCBpZGVudGlmaWVycywgaW5jbHVkaW5nICBcIl9cIlxyXG4gICAgICAgICAgICB2YXIgcGFyc2VkID0gc3RlcC5tYXRjaCgvXihbXzAtOWEtekEtWlxcdTAwYWFcXHUwMGI1XFx1MDBiYVxcdTAwYzAtXFx1MDBkNlxcdTAwZDgtXFx1MDBmNlxcdTAwZjgtXFx1MDJiOFxcdTAyYmItXFx1MDJjMVxcdTAyZDAtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWVcXHUwMzcwLVxcdTAzNzNcXHUwMzc2LVxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyM1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIxLVxcdTA2NGFcXHUwNjYwLVxcdTA2NjlcXHUwNjZlLVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNS1cXHUwNmU2XFx1MDZlZS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjMC1cXHUwN2VhXFx1MDdmNC1cXHUwN2Y1XFx1MDdmYVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk2Ni1cXHUwOTZmXFx1MDk3MS1cXHUwOTcyXFx1MDk3Yi1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4Zi1cXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkYy1cXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDllNi1cXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZi1cXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMi1cXHUwYTMzXFx1MGEzNS1cXHUwYTM2XFx1MGEzOC1cXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNjYtXFx1MGE2ZlxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjItXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMC1cXHUwYWUxXFx1MGFlNi1cXHUwYWVmXFx1MGIwNS1cXHUwYjBjXFx1MGIwZi1cXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMi1cXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWMtXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNjYtXFx1MGI2ZlxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OS1cXHUwYjlhXFx1MGI5Y1xcdTBiOWUtXFx1MGI5ZlxcdTBiYTMtXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYmU2LVxcdTBiZWZcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzU5XFx1MGM2MC1cXHUwYzYxXFx1MGM2Ni1cXHUwYzZmXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwLVxcdTBjZTFcXHUwY2U2LVxcdTBjZWZcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkMjhcXHUwZDJhLVxcdTBkMzlcXHUwZDNkXFx1MGQ2MC1cXHUwZDYxXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzItXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlNTAtXFx1MGU1OVxcdTBlODEtXFx1MGU4MlxcdTBlODRcXHUwZTg3LVxcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYS1cXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMi1cXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWQwLVxcdTBlZDlcXHUwZWRjLVxcdTBlZGRcXHUwZjAwXFx1MGYyMC1cXHUwZjI5XFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhiXFx1MTAwMC1cXHUxMDJhXFx1MTAzZi1cXHUxMDQ5XFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjUtXFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMDkwLVxcdTEwOTlcXHUxMGEwLVxcdTEwYzVcXHUxMGQwLVxcdTEwZmFcXHUxMGZjXFx1MTEwMC1cXHUxMTU5XFx1MTE1Zi1cXHUxMWEyXFx1MTFhOC1cXHUxMWY5XFx1MTIwMC1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2NzZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE3ZTAtXFx1MTdlOVxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOTAwLVxcdTE5MWNcXHUxOTQ2LVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YTlcXHUxOWMxLVxcdTE5YzdcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTZcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjgzLVxcdTFiYTBcXHUxYmFlLVxcdTFiYjlcXHUxYzAwLVxcdTFjMjNcXHUxYzQwLVxcdTFjNDlcXHUxYzRkLVxcdTFjN2RcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOTRcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE4My1cXHUyMTg0XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyYzZmXFx1MmM3MS1cXHUyYzdkXFx1MmM4MC1cXHUyY2U0XFx1MmQwMC1cXHUyZDI1XFx1MmQzMC1cXHUyZDY1XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTMwMDUtXFx1MzAwNlxcdTMwMzEtXFx1MzAzNVxcdTMwM2ItXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiN1xcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjM1xcdWEwMDAtXFx1YTQ4Y1xcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYyYlxcdWE2NDAtXFx1YTY1ZlxcdWE2NjItXFx1YTY2ZVxcdWE2ODAtXFx1YTY5N1xcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4Y1xcdWE3ZmItXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZDAtXFx1YThkOVxcdWE5MDAtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNTAtXFx1YWE1OVxcdWFjMDAtXFx1ZDdhM1xcdWY5MDAtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2YVxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYxMC1cXHVmZjE5XFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXSspKDwoW18kMC05YS16QS1aXFx1MDBhYVxcdTAwYjVcXHUwMGJhXFx1MDBjMC1cXHUwMGQ2XFx1MDBkOC1cXHUwMGY2XFx1MDBmOC1cXHUwMmI4XFx1MDJiYi1cXHUwMmMxXFx1MDJkMC1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlZVxcdTAzNzAtXFx1MDM3M1xcdTAzNzYtXFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTIzXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjEtXFx1MDY0YVxcdTA2NjAtXFx1MDY2OVxcdTA2NmUtXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1LVxcdTA2ZTZcXHUwNmVlLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2MwLVxcdTA3ZWFcXHUwN2Y0LVxcdTA3ZjVcXHUwN2ZhXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTY2LVxcdTA5NmZcXHUwOTcxLVxcdTA5NzJcXHUwOTdiLVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmLVxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWU2LVxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmLVxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyLVxcdTBhMzNcXHUwYTM1LVxcdTBhMzZcXHUwYTM4LVxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE2Ni1cXHUwYTZmXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMi1cXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwLVxcdTBhZTFcXHUwYWU2LVxcdTBhZWZcXHUwYjA1LVxcdTBiMGNcXHUwYjBmLVxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyLVxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Yy1cXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI2Ni1cXHUwYjZmXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5LVxcdTBiOWFcXHUwYjljXFx1MGI5ZS1cXHUwYjlmXFx1MGJhMy1cXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBiZTYtXFx1MGJlZlxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNTlcXHUwYzYwLVxcdTBjNjFcXHUwYzY2LVxcdTBjNmZcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTAtXFx1MGNlMVxcdTBjZTYtXFx1MGNlZlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQyOFxcdTBkMmEtXFx1MGQzOVxcdTBkM2RcXHUwZDYwLVxcdTBkNjFcXHUwZDY2LVxcdTBkNmZcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMi1cXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU1MC1cXHUwZTU5XFx1MGU4MS1cXHUwZTgyXFx1MGU4NFxcdTBlODctXFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhLVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyLVxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZDAtXFx1MGVkOVxcdTBlZGMtXFx1MGVkZFxcdTBmMDBcXHUwZjIwLVxcdTBmMjlcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGJcXHUxMDAwLVxcdTEwMmFcXHUxMDNmLVxcdTEwNDlcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NS1cXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwOTAtXFx1MTA5OVxcdTEwYTAtXFx1MTBjNVxcdTEwZDAtXFx1MTBmYVxcdTEwZmNcXHUxMTAwLVxcdTExNTlcXHUxMTVmLVxcdTExYTJcXHUxMWE4LVxcdTExZjlcXHUxMjAwLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3NlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTdlMC1cXHUxN2U5XFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE5MDAtXFx1MTkxY1xcdTE5NDYtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhOVxcdTE5YzEtXFx1MTljN1xcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNlxcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiODMtXFx1MWJhMFxcdTFiYWUtXFx1MWJiOVxcdTFjMDAtXFx1MWMyM1xcdTFjNDAtXFx1MWM0OVxcdTFjNGQtXFx1MWM3ZFxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5NFxcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTgzLVxcdTIxODRcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjNmZcXHUyYzcxLVxcdTJjN2RcXHUyYzgwLVxcdTJjZTRcXHUyZDAwLVxcdTJkMjVcXHUyZDMwLVxcdTJkNjVcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA2XFx1MzAzMS1cXHUzMDM1XFx1MzAzYi1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWI3XFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmMzXFx1YTAwMC1cXHVhNDhjXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjJiXFx1YTY0MC1cXHVhNjVmXFx1YTY2Mi1cXHVhNjZlXFx1YTY4MC1cXHVhNjk3XFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhjXFx1YTdmYi1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThkMC1cXHVhOGQ5XFx1YTkwMC1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE1MC1cXHVhYTU5XFx1YWMwMC1cXHVkN2EzXFx1ZjkwMC1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZhXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjEwLVxcdWZmMTlcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGMkXSspPik/JC9pKTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSBjdXJyZW50VHlwZS5nZXRQcm9wZXJ0eShwYXJzZWRbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEludmFsaWQgcHJvcGVydHlcclxuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0aCAnXCIgKyBwYXRoICsgXCInIHJlZmVyZW5jZXMgdW5rbm93biBwcm9wZXJ0eSAnXCIgKyBzdGVwICsgXCInIG9uIHR5cGUgJ1wiICsgY3VycmVudFR5cGUgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCB0eXBlIG9mIHRoZSBzdGVwXHJcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlID0gcHJvcGVydHkucHJvcGVydHlUeXBlLm1ldGE7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRbM10pIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUeXBlID0gcm9vdFR5cGUubW9kZWwudHlwZXNbcGFyc2VkWzNdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHByb3BlcnR5XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjcmVhdGUgdGhlIGFjY2Vzc2VkIGV2ZW50IGFuZCBhdXRvbWF0aWNhbGx5IHN1YnNjcmliZSB0byBwcm9wZXJ0eSBhY2Nlc3NlcyBhbG9uZyB0aGUgcGF0aCB3aGVuIHRoZSBldmVudCBpcyB1c2VkXHJcbiAgICAgICAgdGhpcy5hY2Nlc3NlZCA9IG5ldyBldmVudHNfMS5FdmVudChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50Lmhhc1N1YnNjcmliZXJzKCkgJiYgIV90aGlzLnN0ZXBBY2Nlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RlcEFjY2Vzc2VkID0gW107XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5LCBpbmRleCwgcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlcjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJpb3JQcm9wID0gaW5kZXggPiAwID8gcHJvcHNbaW5kZXggLSAxXSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlciA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJvb3RUeXBlLmtub3duKCkuZm9yRWFjaChmdW5jdGlvbiAoa25vd24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy50ZXN0Q29ubmVjdGlvbihrbm93biwgYXJncy5lbnRpdHksIHByaW9yUHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2Nlc3NlZC5wdWJsaXNoKGtub3duLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eToga25vd24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBhcmdzLnByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYXJncy52YWx1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnN0ZXBBY2Nlc3NlZFtpbmRleF0gPSBoYW5kbGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmFjY2Vzc2VkLnN1YnNjcmliZShoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFldmVudC5oYXNTdWJzY3JpYmVycygpICYmIF90aGlzLnN0ZXBBY2Nlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSwgaW5kZXgpIHsgcmV0dXJuIHByb3BlcnR5LmFjY2Vzc2VkLnVuc3Vic2NyaWJlKF90aGlzLnN0ZXBBY2Nlc3NlZFtpbmRleF0pOyB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnN0ZXBBY2Nlc3NlZCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjcmVhdGUgdGhlIGNoYW5nZWQgZXZlbnQgYW5kIGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlIHRvIHByb3BlcnR5IGNoYW5nZXMgYWxvbmcgdGhlIHBhdGggd2hlbiB0aGUgZXZlbnQgaXMgdXNlZFxyXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IG5ldyBldmVudHNfMS5FdmVudChmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50Lmhhc1N1YnNjcmliZXJzKCkgJiYgIV90aGlzLnN0ZXBDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGVwQ2hhbmdlZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSwgaW5kZXgsIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByaW9yUHJvcCA9IGluZGV4ID4gMCA/IHByb3BzW2luZGV4IC0gMV0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJpb3JQcm9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yb290VHlwZS5rbm93bigpLmZvckVhY2goZnVuY3Rpb24gKGtub3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnRlc3RDb25uZWN0aW9uKGtub3duLCBhcmdzLmVudGl0eSwgcHJpb3JQcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VkLnB1Ymxpc2goa25vd24sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGl0eToga25vd24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogYXJncy5wcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBhcmdzLm9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IGFyZ3MubmV3VmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VkLnB1Ymxpc2goYXJncy5lbnRpdHksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRpdHk6IGFyZ3MuZW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBhcmdzLnByb3BlcnR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBhcmdzLm9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBhcmdzLm5ld1ZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RlcENoYW5nZWRbaW5kZXhdID0gaGFuZGxlcjtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5jaGFuZ2VkLnN1YnNjcmliZShoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFldmVudC5oYXNTdWJzY3JpYmVycygpICYmIF90aGlzLnN0ZXBDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5LCBpbmRleCkgeyByZXR1cm4gcHJvcGVydHkuY2hhbmdlZC51bnN1YnNjcmliZShfdGhpcy5zdGVwQ2hhbmdlZFtpbmRleF0pOyB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnN0ZXBDaGFuZ2VkID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcGF0aFxyXG4gICAgICAgIHRoaXMucGF0aCA9IGdldFByb3BlcnR5Q2hhaW5QYXRoRnJvbUluZGV4KHRoaXMsIDApO1xyXG4gICAgfVxyXG4gICAgUHJvcGVydHlDaGFpbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICBpZiAocHJvcCA9PT0gbnVsbCB8fCBwcm9wID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIHByb3BlcnR5XzEuUHJvcGVydHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5sZW5ndGggPT09IDEgJiYgdGhpcy5wcm9wZXJ0aWVzWzBdID09PSBwcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFByb3BlcnR5Q2hhaW4pIHtcclxuICAgICAgICAgICAgaWYgKHByb3AucHJvcGVydGllcy5sZW5ndGggIT09IHRoaXMucHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXNbaV0uZXF1YWxzKHByb3AucHJvcGVydGllc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgb2JqZWN0cyBhbG9uZyBhIHByb3BlcnR5IGNoYWluIHN0YXJ0aW5nIHdpdGggdGhlIHJvb3Qgb2JqZWN0IChvYmopLlxyXG4gICAgICogVGhpcyBpcyBhbmFsb2dvdXMgdG8gdGhlIEFycmF5IGZvckVhY2ggZnVuY3Rpb24uIFRoZSBjYWxsYmFjayBtYXkgcmV0dXJuIGEgQm9vbGVhblxyXG4gICAgICogdmFsdWUgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdG8gY29udGludWUgaXRlcmF0aW5nLlxyXG4gICAgICogQHBhcmFtIG9iaiBUaGUgcm9vdCBvYmplY3QgKG9mIHR5cGUgYElFbnRpdHlgKSB0byB1c2UgaW4gaXRlcmF0aW5nIG92ZXIgdGhlIGNoYWluLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBpbnZva2UgYXQgZWFjaCBpdGVyYXRpb24gc3RlcC4gIE1heSByZXR1cm4gYSBCb29sZWFuIHZhbHVlIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRvIGNvbnRpbnVlIGl0ZXJhdGluZy5cclxuICAgICAqIEBwYXJhbSBmaWx0ZXIgQW4gb3B0aW9uYWwgcHJvcGVydHkgZmlsdGVyLCBpZiBzcGVjaWZpZWQsIG9ubHkgaXRlcmF0ZXMgb3ZlciB0aGUgcmVzdWx0cyBvZiB0aGlzIHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBQcm9wZXJ0eUNoYWluLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2ssIGZpbHRlciAvKiwgdGFyZ2V0OiBJRW50aXR5LCBwOiBudW1iZXIsIGxhc3RQcm9wOiBJUHJvcGVydHkgKi8pIHtcclxuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0gbnVsbDsgfVxyXG4gICAgICAgIGlmIChvYmogPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ29iaicgY2Fubm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLlwiKTtcclxuICAgICAgICBpZiAoY2FsbGJhY2sgPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgJ2NhbGxiYWNrJyBjYW5ub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgKGNhbGxiYWNrKSAhPT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCAnY2FsbGJhY2snIG11c3QgYmUgb2YgdHlwZSBmdW5jdGlvbjogXCIgKyBjYWxsYmFjayArIFwiLlwiKTtcclxuICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2sgb24gb2JqIGZpcnN0XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50c1szXSB8fCBvYmo7XHJcbiAgICAgICAgdmFyIGxhc3RQcm9wID0gYXJndW1lbnRzWzVdIHx8IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgcCA9IGFyZ3VtZW50c1s0XSB8fCAwOyBwIDwgdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aDsgcCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wID0gdGhpcy5wcm9wZXJ0aWVzW3BdO1xyXG4gICAgICAgICAgICB2YXIgaXNMYXN0UHJvcGVydHkgPSBwID09PSB0aGlzLnByb3BlcnRpZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgdmFyIGNhblNraXBSZW1haW5pbmdQcm9wcyA9IGlzTGFzdFByb3BlcnR5IHx8IChmaWx0ZXIgJiYgbGFzdFByb3AgPT09IGZpbHRlcik7XHJcbiAgICAgICAgICAgIHZhciBlbmFibGVDYWxsYmFjayA9ICghZmlsdGVyIHx8IGxhc3RQcm9wID09PSBmaWx0ZXIpO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0IGlzIGEgbGlzdCwgaW52b2tlIHRoZSBjYWxsYmFjayBvbmNlIHBlciBpdGVtIGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlQ2FsbGJhY2sgJiYgY2FsbGJhY2sodGFyZ2V0W2ldLCBwcm9wKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhblNraXBSZW1haW5pbmdQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VmFsdWUgPSBwcm9wLnZhbHVlKHRhcmdldFtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIGFsb25nIHRoZSBjaGFpbiBmb3IgdGhpcyBsaXN0IGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRWYWx1ZSB8fCBQcm9wZXJ0eUNoYWluLnByb3RvdHlwZS5lYWNoLmNhbGwodGhpcywgb2JqLCBjYWxsYmFjaywgZmlsdGVyLCB0YXJnZXRWYWx1ZSwgcCArIDEsIHByb3ApID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBwcm9wZXJ0aWVzIGFscmVhZHkgdmlzaXRlZCBpbiBwcmVjZWRpbmcgbG9vcFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0YWtlIGludG8gYWNjb3VudCBhbnkgY2hhaW4gZmlsdGVycyBhbG9uZyB0aGUgd2F5XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5hYmxlQ2FsbGJhY2sgJiYgY2FsbGJhY2sodGFyZ2V0LCBwcm9wKSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgYSBwcm9wZXJ0eSBmaWx0ZXIgaXMgdXNlZCBhbmQgd2FzIGp1c3QgZXZhbHVhdGVkLCBzdG9wIGVhcmx5XHJcbiAgICAgICAgICAgIGlmIChjYW5Ta2lwUmVtYWluaW5nUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1vdmUgdG8gbmV4dCBwcm9wZXJ0eSBpbiB0aGUgY2hhaW5cclxuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Ll9fZmllbGRzX19bcHJvcC5uYW1lXTtcclxuICAgICAgICAgICAgLy8gYnJlYWsgZWFybHkgaWYgdGhlIHRhcmdldCBpcyB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGFzdFByb3AgPSBwcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlDaGFpbi5wcm90b3R5cGUsIFwiY29udGFpbmluZ1R5cGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290VHlwZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlDaGFpbi5wcm90b3R5cGUsIFwiZmlyc3RQcm9wZXJ0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNbMF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3BlcnR5Q2hhaW4ucHJvdG90eXBlLCBcImxhc3RQcm9wZXJ0eVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXNbdGhpcy5wcm9wZXJ0aWVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFByb3BlcnR5Q2hhaW4ucHJvdG90eXBlLnRvUHJvcGVydHlBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnNsaWNlKCk7XHJcbiAgICB9O1xyXG4gICAgUHJvcGVydHlDaGFpbi5wcm90b3R5cGUuZ2V0TGFzdFRhcmdldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHRoaXMucHJvcGVydGllcy5sZW5ndGggLSAxOyBwKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3AgPSB0aGlzLnByb3BlcnRpZXNbcF07XHJcbiAgICAgICAgICAgIC8vIGV4aXQgZWFybHkgb24gbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgICAgICAgaWYgKCFvYmogPT09IHVuZGVmaW5lZCB8fCBvYmogPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICBvYmogPSBwcm9wLnZhbHVlKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgUHJvcGVydHlDaGFpbi5wcm90b3R5cGUuY2FuU2V0VmFsdWUgPSBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RQcm9wZXJ0eS5jYW5TZXRWYWx1ZSh0aGlzLmdldExhc3RUYXJnZXQob2JqKSwgdmFsdWUpO1xyXG4gICAgfTtcclxuICAgIC8vIERldGVybWluZXMgaWYgdGhpcyBwcm9wZXJ0eSBjaGFpbiBjb25uZWN0cyB0d28gb2JqZWN0cy5cclxuICAgIFByb3BlcnR5Q2hhaW4ucHJvdG90eXBlLnRlc3RDb25uZWN0aW9uID0gZnVuY3Rpb24gKGZyb21Sb290LCB0b09iaiwgdmlhUHJvcGVydHkpIHtcclxuICAgICAgICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gcGVyZm9ybSBzaW1wbGUgY29tcGFyaXNvbiBpZiBubyBwcm9wZXJ0eSBpcyBkZWZpbmVkXHJcbiAgICAgICAgaWYgKCF2aWFQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbVJvb3QgPT09IHRvT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVhY2goZnJvbVJvb3QsIGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gdG9PYmopIHtcclxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCB2aWFQcm9wZXJ0eSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RlZDtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlDaGFpbi5wcm90b3R5cGUsIFwicHJvcGVydHlUeXBlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFByb3BlcnR5LnByb3BlcnR5VHlwZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlDaGFpbi5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFByb3BlcnR5LmZvcm1hdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlDaGFpbi5wcm90b3R5cGUsIFwiaXNMaXN0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFByb3BlcnR5LmlzTGlzdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlDaGFpbi5wcm90b3R5cGUsIFwiaXNDYWxjdWxhdGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFByb3BlcnR5LmlzQ2FsY3VsYXRlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJvcGVydHlDaGFpbi5wcm90b3R5cGUsIFwibGFiZWxcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0UHJvcGVydHkubGFiZWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3BlcnR5Q2hhaW4ucHJvdG90eXBlLCBcImxhYmVsU291cmNlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFByb3BlcnR5LmxhYmVsU291cmNlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eUNoYWluLnByb3RvdHlwZSwgXCJsYWJlbElzRm9ybWF0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdF8xLkZvcm1hdC5oYXNUb2tlbnModGhpcy5sYWJlbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3BlcnR5Q2hhaW4ucHJvdG90eXBlLCBcImhlbHB0ZXh0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFByb3BlcnR5LmhlbHB0ZXh0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eUNoYWluLnByb3RvdHlwZSwgXCJoZWxwdGV4dElzRm9ybWF0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdF8xLkZvcm1hdC5oYXNUb2tlbnModGhpcy5oZWxwdGV4dCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3BlcnR5Q2hhaW4ucHJvdG90eXBlLCBcIm5hbWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXN0UHJvcGVydHkubmFtZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBQcm9wZXJ0eUNoYWluLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uIChvYmosIHZhbCwgYWRkaXRpb25hbEFyZ3MpIHtcclxuICAgICAgICBpZiAob2JqID09PSB2b2lkIDApIHsgb2JqID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICh2YWwgPT09IHZvaWQgMCkgeyB2YWwgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGFkZGl0aW9uYWxBcmdzID09PSB2b2lkIDApIHsgYWRkaXRpb25hbEFyZ3MgPSBudWxsOyB9XHJcbiAgICAgICAgdmFyIGxhc3RUYXJnZXQgPSB0aGlzLmdldExhc3RUYXJnZXQob2JqKTtcclxuICAgICAgICB2YXIgbGFzdFByb3AgPSB0aGlzLmxhc3RQcm9wZXJ0eTtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgbGFzdFByb3AudmFsdWUobGFzdFRhcmdldCwgdmFsLCBhZGRpdGlvbmFsQXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxhc3RUYXJnZXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxhc3RQcm9wLnZhbHVlKGxhc3RUYXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQcm9wZXJ0eUNoYWluLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucHJvcGVydGllcy5tYXAoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUubmFtZTsgfSkuam9pbihcIi5cIik7XHJcbiAgICAgICAgcmV0dXJuIFwidGhpczxcIiArIHRoaXMucm9vdFR5cGUgKyBcIj4uXCIgKyBwYXRoO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQcm9wZXJ0eUNoYWluO1xyXG59KCkpO1xyXG5leHBvcnRzLlByb3BlcnR5Q2hhaW4gPSBQcm9wZXJ0eUNoYWluO1xyXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUNoYWluUGF0aEZyb21JbmRleChjaGFpbiwgc3RhcnRJbmRleCkge1xyXG4gICAgdmFyIHN0ZXBzID0gW107XHJcbiAgICB2YXIgcHJvcHMgPSBjaGFpbi50b1Byb3BlcnR5QXJyYXkoKTtcclxuICAgIHZhciBwcmV2aW91c1N0ZXBUeXBlO1xyXG4gICAgcHJvcHMuc2xpY2Uoc3RhcnRJbmRleCkuZm9yRWFjaChmdW5jdGlvbiAocCwgaSkge1xyXG4gICAgICAgIGlmIChpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChwLmNvbnRhaW5pbmdUeXBlICE9PSBwcmV2aW91c1N0ZXBUeXBlICYmIHAuY29udGFpbmluZ1R5cGUuaXNTdWJjbGFzc09mKHByZXZpb3VzU3RlcFR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXSA9IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdICsgXCI8XCIgKyBwLmNvbnRhaW5pbmdUeXBlLmZ1bGxOYW1lICsgXCI+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RlcHMucHVzaChwLm5hbWUpO1xyXG4gICAgICAgIHByZXZpb3VzU3RlcFR5cGUgPSBwLnByb3BlcnR5VHlwZS5tZXRhO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3RlcHMuam9pbihcIi5cIik7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcclxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlByb3BlcnR5JHNldHRlciA9IGV4cG9ydHMuUHJvcGVydHkkaW5pdCA9IGV4cG9ydHMuUHJvcGVydHkkcGVuZGluZ0luaXQgPSBleHBvcnRzLlByb3BlcnR5JGdlbmVyYXRlT3duUHJvcGVydHkgPSBleHBvcnRzLlByb3BlcnR5JGdlbmVyYXRlUHJvdG90eXBlUHJvcGVydHkgPSBleHBvcnRzLlByb3BlcnR5JGdlbmVyYXRlU3RhdGljUHJvcGVydHkgPSBleHBvcnRzLlByb3BlcnR5JGdlbmVyYXRlU2hvcnRjdXRzID0gZXhwb3J0cy5Qcm9wZXJ0eSRmb3JtYXQgPSBleHBvcnRzLmV2YWx1YXRlTGFiZWwgPSBleHBvcnRzLmdldExhYmVsU291cmNlVHlwZSA9IGV4cG9ydHMuZ2V0TGFiZWxGb3JtYXQgPSBleHBvcnRzLmlzUHJvcGVydHlPcHRpb25zID0gZXhwb3J0cy5pc1Byb3BlcnR5Qm9vbGVhbkZ1bmN0aW9uID0gZXhwb3J0cy5pc1Byb3BlcnR5Qm9vbGVhbkZ1bmN0aW9uQW5kT3B0aW9ucyA9IGV4cG9ydHMuaXNQcm9wZXJ0eVZhbHVlRnVuY3Rpb24gPSBleHBvcnRzLlByb3BlcnR5ID0gdm9pZCAwO1xyXG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiLi9ldmVudHNcIik7XHJcbnZhciBmb3JtYXRfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdFwiKTtcclxudmFyIHR5cGVfMSA9IHJlcXVpcmUoXCIuL3R5cGVcIik7XHJcbnZhciBwcm9wZXJ0eV9jaGFpbl8xID0gcmVxdWlyZShcIi4vcHJvcGVydHktY2hhaW5cIik7XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG52YXIgb2JzZXJ2YWJsZV9hcnJheV8xID0gcmVxdWlyZShcIi4vb2JzZXJ2YWJsZS1hcnJheVwiKTtcclxudmFyIHJ1bGVfMSA9IHJlcXVpcmUoXCIuL3J1bGVcIik7XHJcbnZhciBjYWxjdWxhdGVkX3Byb3BlcnR5X3J1bGVfMSA9IHJlcXVpcmUoXCIuL2NhbGN1bGF0ZWQtcHJvcGVydHktcnVsZVwiKTtcclxudmFyIHN0cmluZ19mb3JtYXRfcnVsZV8xID0gcmVxdWlyZShcIi4vc3RyaW5nLWZvcm1hdC1ydWxlXCIpO1xyXG52YXIgdmFsaWRhdGlvbl9ydWxlXzEgPSByZXF1aXJlKFwiLi92YWxpZGF0aW9uLXJ1bGVcIik7XHJcbnZhciBhbGxvd2VkX3ZhbHVlc19ydWxlXzEgPSByZXF1aXJlKFwiLi9hbGxvd2VkLXZhbHVlcy1ydWxlXCIpO1xyXG52YXIgcmVxdWlyZWRfcnVsZV8xID0gcmVxdWlyZShcIi4vcmVxdWlyZWQtcnVsZVwiKTtcclxudmFyIHJhbmdlX3J1bGVfMSA9IHJlcXVpcmUoXCIuL3JhbmdlLXJ1bGVcIik7XHJcbnZhciBzdHJpbmdfbGVuZ3RoX3J1bGVfMSA9IHJlcXVpcmUoXCIuL3N0cmluZy1sZW5ndGgtcnVsZVwiKTtcclxudmFyIGxpc3RfbGVuZ3RoX3J1bGVfMSA9IHJlcXVpcmUoXCIuL2xpc3QtbGVuZ3RoLXJ1bGVcIik7XHJcbnZhciBpbml0aWxpemF0aW9uX2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2luaXRpbGl6YXRpb24tY29udGV4dFwiKTtcclxudmFyIGNvbmRpdGlvbl90eXBlXzEgPSByZXF1aXJlKFwiLi9jb25kaXRpb24tdHlwZVwiKTtcclxudmFyIFByb3BlcnR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJvcGVydHkoY29udGFpbmluZ1R5cGUsIG5hbWUsIHByb3BlcnR5VHlwZSwgaXNJZGVudGlmaWVyLCBpc0xpc3QsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmNvbnRhaW5pbmdUeXBlID0gY29udGFpbmluZ1R5cGU7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLnByb3BlcnR5VHlwZSA9IHByb3BlcnR5VHlwZTtcclxuICAgICAgICB0aGlzLmlzSWRlbnRpZmllciA9IGlzSWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmlzTGlzdCA9IGlzTGlzdDtcclxuICAgICAgICB0aGlzLnJlcXVpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ydWxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZ2V0dGVyID0gUHJvcGVydHkkbWFrZUdldHRlcih0aGlzLCBQcm9wZXJ0eSRnZXR0ZXIpO1xyXG4gICAgICAgIHRoaXMuc2V0dGVyID0gUHJvcGVydHkkbWFrZVNldHRlcih0aGlzLCBQcm9wZXJ0eSRzZXR0ZXIpO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IG5ldyBldmVudHNfMS5FdmVudCgpO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzZWQgPSBuZXcgZXZlbnRzXzEuRXZlbnQoKTtcclxuICAgICAgICAvLyBBcHBseSBwcm9wZXJ0eSBvcHRpb25zXHJcbiAgICAgICAgaWYgKG9wdGlvbnMpXHJcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kKG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3BlcnR5LnByb3RvdHlwZSwgXCJpc0NvbnN0YW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RhbnQgIT09IG51bGwgJiYgdGhpcy5jb25zdGFudCAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eS5wcm90b3R5cGUsIFwibGFiZWxJc0Zvcm1hdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRfMS5Gb3JtYXQuaGFzVG9rZW5zKHRoaXMubGFiZWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eS5wcm90b3R5cGUsIFwiaGVscHRleHRJc0Zvcm1hdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRfMS5Gb3JtYXQuaGFzVG9rZW5zKHRoaXMuaGVscHRleHQpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eS5wcm90b3R5cGUsIFwicGF0aFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3BlcnR5LnByb3RvdHlwZSwgXCJmaXJzdFByb3BlcnR5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByb3BlcnR5LnByb3RvdHlwZSwgXCJsYXN0UHJvcGVydHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0TGFzdFRhcmdldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcm9wZXJ0eS5wcm90b3R5cGUsIFwiZGVmYXVsdFZhbHVlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSBhcnJheSBhbmQgZGF0ZSBkZWZhdWx0cyBzaW5jZSB0aGV5IGFyZSBtdXRhYmxlIGphdmFzY3JpcHQgdHlwZXNcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWUgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuX2RlZmF1bHRWYWx1ZS5zbGljZSgpIDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gbmV3IERhdGUoK3RoaXMuX2RlZmF1bHRWYWx1ZSkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgVGltZVNwYW4gY2xhc3MvdHlwZT9cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcy5fZGVmYXVsdFZhbHVlIGluc3RhbmNlb2YgVGltZVNwYW4gPyBuZXcgVGltZVNwYW4odGhpcy5fZGVmYXVsdFZhbHVlLnRvdGFsTWlsbGlzZWNvbmRzKSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyc18xLmdldERlZmF1bHRWYWx1ZSh0aGlzLmlzTGlzdCwgdGhpcy5wcm9wZXJ0eVR5cGUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFByb3BlcnR5LnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAob3B0aW9ucywgdGFyZ2V0VHlwZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF0YXJnZXRUeXBlKVxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlID0gdGhpcy5jb250YWluaW5nVHlwZTtcclxuICAgICAgICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBwYXRoIHN0cmluZyBpbnRvIGEgcmVzb2x2ZWQgYXJyYXkgb2YgUHJvcGVydHkgYW5kIFByb3BlcnR5Q2hhaW4gaW5zdGFuY2VzXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZURlcGVuZHNPbihwcm9wZXJ0eSwgcnVsZSwgZGVwZW5kc09uKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBhbiBlbXB0eSBkZXBlbmRlbmN5IGFycmF5IGlmIG5vIHBhdGggd2FzIHNwZWNpZmllZFxyXG4gICAgICAgICAgICBpZiAoIWRlcGVuZHNPbilcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGRlcGVuZHNPbiBpcyBub3QgYSBzdHJpbmdcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoZGVwZW5kc09uKSAhPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGVwZW5kc09uIHByb3BlcnR5IGZvciAnXCIgKyBydWxlICsgXCInIHJ1bGUgb24gJ1wiICsgcHJvcGVydHkgKyBcIi5cIik7XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgcHJvcGVydHkgcGF0aHMgZm9yIHRoZSBzcGVjaWZpZWQgZGVwZW5kZW5jeSBzdHJpbmdcclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFR5cGUuZ2V0UGF0aHMoZGVwZW5kc09uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXNlIHByZXBhcmUoKSB0byBkZWZlciBwcm9wZXJ0eSBwYXRoIHJlc29sdXRpb24gd2hpbGUgdGhlIG1vZGVsIGlzIGJlaW5nIGV4dGVuZGVkXHJcbiAgICAgICAgdGFyZ2V0VHlwZS5tb2RlbC5wcmVwYXJlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IF9fYXNzaWduKHt9LCBvcHRpb25zKTtcclxuICAgICAgICAgICAgLy8gTGFiZWxcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGFiZWwpXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sYWJlbCA9IG9wdGlvbnMubGFiZWw7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldFR5cGUubW9kZWwuc2V0dGluZ3MuYXV0b2dlbmVyYXRlUHJvcGVydHlMYWJlbHMgJiYgIV90aGlzLmxhYmVsKVxyXG4gICAgICAgICAgICAgICAgX3RoaXMubGFiZWwgPSBfdGhpcy5uYW1lLnJlcGxhY2UoLyheW2Etel0rfFtBLVpdezIsfSg/PVtBLVpdW2Etel18JCl8W0EtWl1bYS16XSopL2csIFwiICQxXCIpLnRyaW0oKTtcclxuICAgICAgICAgICAgLy8gTGFiZWwgU291cmNlXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxhYmVsU291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLmxhYmVsU291cmNlKSAhPT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxhYmVsU291cmNlIHByb3BlcnR5IGZvciAnXCIgKyBfdGhpcyArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldFR5cGUubW9kZWwucmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmxhYmVsU291cmNlID0gdGFyZ2V0VHlwZS5nZXRQYXRoKG9wdGlvbnMubGFiZWxTb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSGVscHRleHRcclxuICAgICAgICAgICAgX3RoaXMuaGVscHRleHQgPSBvcHRpb25zLmhlbHB0ZXh0O1xyXG4gICAgICAgICAgICAvLyBGb3JtYXRcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWZpZXJcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMuZm9ybWF0KSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5mb3JtYXQgPSB0YXJnZXRUeXBlLm1vZGVsLmdldEZvcm1hdChfdGhpcy5wcm9wZXJ0eVR5cGUsIGZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXRcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuZm9ybWF0IGluc3RhbmNlb2YgZm9ybWF0XzEuRm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogY29udmVydCBkZXNjcmlwdGlvbi9leHByZXNzaW9uL3JlZm9ybWF0IGludG8gYSBGb3JtYXQgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTdHJpbmcgRm9ybWF0XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoZWxwZXJzXzEuaXNUeXBlKG9wdGlvbnMuZm9ybWF0LCBmdW5jdGlvbiAoZikgeyByZXR1cm4gaGVscGVyc18xLmdldFR5cGVOYW1lKGYpID09PSBcIm9iamVjdFwiICYmIGYuZXhwcmVzc2lvbjsgfSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybWF0XzIgPSBvcHRpb25zLmZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlLm1vZGVsLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IHN0cmluZ19mb3JtYXRfcnVsZV8xLlN0cmluZ0Zvcm1hdFJ1bGUodGFyZ2V0VHlwZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IF90aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGZvcm1hdF8yLmRlc2NyaXB0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZm9ybWF0XzIubWVzc2FnZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGZvcm1hdF8yLmV4cHJlc3Npb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZvcm1hdDogZm9ybWF0XzIucmVmb3JtYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZWdpc3RlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRXJyb3JcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgJ2Zvcm1hdCcgb3B0aW9uIGZvciAnXCIgKyBfdGhpcyArIFwiJy5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ29uc3RhbnRcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29uc3RhbnQgIT09IG51bGwgJiYgb3B0aW9ucy5jb25zdGFudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRUeXBlLm1vZGVsLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBMYXppbHkgb2J0YWluIHRoZSBjb25zdGFudCB0byBlbnN1cmUgYWxsIHR5cGVzL3J1bGVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29uc3RhbnQgdmFsdWUgaGF2ZSBiZWVuIGxvYWRlZCBhbmQgaW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25zdGFudCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRhcmdldFR5cGUubW9kZWwuc2VyaWFsaXplci5kZXNlcmlhbGl6ZShudWxsLCBvcHRpb25zLmNvbnN0YW50LCBfdGhpcywgbmV3IGluaXRpbGl6YXRpb25fY29udGV4dF8xLkluaXRpYWxpemF0aW9uQ29udGV4dCh0cnVlKSk7IH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHZXRcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLmdldCkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZ2V0ID0geyBmdW5jdGlvbjogb3B0aW9ucy5nZXQsIGRlcGVuZHNPbjogXCJcIiB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlPcHRpb25zKG9wdGlvbnMuZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRPcHRpb25zXzEgPSBvcHRpb25zLmdldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChnZXRPcHRpb25zXzEuZnVuY3Rpb24pICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSAnZ2V0JyBmdW5jdGlvbiBvZiB0eXBlICdcIiArIGhlbHBlcnNfMS5nZXRUeXBlTmFtZShnZXRPcHRpb25zXzEuZnVuY3Rpb24pICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VHlwZS5tb2RlbC5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBjYWxjdWxhdGVkX3Byb3BlcnR5X3J1bGVfMS5DYWxjdWxhdGVkUHJvcGVydHlSdWxlKHRhcmdldFR5cGUsIG51bGwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBfdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGN1bGF0ZTogZ2V0T3B0aW9uc18xLmZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2VPZjogcmVzb2x2ZURlcGVuZHNPbihfdGhpcywgXCJnZXRcIiwgZ2V0T3B0aW9uc18xLmRlcGVuZHNPbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmVnaXN0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvcGVydHkgJ2dldCcgb3B0aW9uIG9mIHR5cGUgJ1wiICsgaGVscGVyc18xLmdldFR5cGVOYW1lKG9wdGlvbnMuZ2V0KSArIFwiJy5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2V0XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zZXQgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5XzEgPSBfdGhpcztcclxuICAgICAgICAgICAgICAgIG5ldyBydWxlXzEuUnVsZSh0YXJnZXRUeXBlLCBudWxsLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgb25Jbml0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlT2Y6IFtfdGhpc10sXHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNldC5jYWxsKHRoaXMsIHByb3BlcnR5XzEudmFsdWUodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLnJlZ2lzdGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gSW5pdFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbml0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbml0Rm4gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eVZhbHVlRnVuY3Rpb24ob3B0aW9ucy5pbml0KSlcclxuICAgICAgICAgICAgICAgICAgICBpbml0Rm4gPSBvcHRpb25zLmluaXQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSAnaW5pdCcgb3B0aW9uIG9mIHR5cGUgJ1wiICsgaGVscGVyc18xLmdldFR5cGVOYW1lKG9wdGlvbnMuaW5pdCkgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZXIgPSBpbml0Rm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRGVmYXVsdFxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VmFsdWVGdW5jdGlvbihvcHRpb25zLmRlZmF1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIGdlbmVyYXRlIGEgcnVsZSBmb3IgZGVmYXVsdCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdCA9IHsgZnVuY3Rpb246IG9wdGlvbnMuZGVmYXVsdCwgZGVwZW5kc09uOiBcIlwiIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1Byb3BlcnR5T3B0aW9ucyhvcHRpb25zLmRlZmF1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGRlZmF1bHQgb2JqZWN0IGFzIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5kZWZhdWx0ID09PSBudWxsIHx8IHR5cGVfMS5pc1ZhbHVlKG9wdGlvbnMuZGVmYXVsdCkgfHwgdHlwZV8xLmlzVmFsdWVBcnJheShvcHRpb25zLmRlZmF1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RhbnRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdENvbnN0YW50XzEgPSBvcHRpb25zLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2Fubm90IHNldCBkZWZhdWx0IGNvbnN0YW50IHZhbHVlIGZvciBlbnRpdHktdHlwZWQgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZV8xLmlzRW50aXR5VHlwZShfdGhpcy5wcm9wZXJ0eVR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgYSBjb25zdGFudCBkZWZhdWx0IHZhbHVlIGZvciBhIHByb3BlcnR5IG9mIHR5cGUgJ1wiICsgX3RoaXMucHJvcGVydHlUeXBlLm1ldGEuZnVsbE5hbWUgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29uc3RhbnQgdmFsdWUgaXMgb2YgdGhlIHByb3BlciBidWlsdC1pbiB0eXBlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdCAhPT0gbnVsbCAmJiB0eXBlXzEuaXNWYWx1ZShvcHRpb25zLmRlZmF1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0T3B0aW9uVHlwZU5hbWUgPSBoZWxwZXJzXzEuZ2V0VHlwZU5hbWUoZGVmYXVsdENvbnN0YW50XzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlUeXBlTmFtZSA9IGhlbHBlcnNfMS5nZXRDb25zdHJ1Y3Rvck5hbWUoX3RoaXMucHJvcGVydHlUeXBlKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdE9wdGlvblR5cGVOYW1lICE9PSBwcm9wZXJ0eVR5cGVOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IGEgZGVmYXVsdCB2YWx1ZSBvZiB0eXBlICdcIiArIGRlZmF1bHRPcHRpb25UeXBlTmFtZSArIFwiJyBmb3IgYSBwcm9wZXJ0eSBvZiB0eXBlICdcIiArIHByb3BlcnR5VHlwZU5hbWUgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGV4dGVuZGluZyBiYXNlVHlwZSBwcm9wZXJ0eSBzcGVjaWZpY2FsbHkgZm9yIGEgY2hpbGQgdHlwZSwgdXNlIGEgcnVsZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5jb250YWluaW5nVHlwZSA9PT0gdGFyZ2V0VHlwZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2RlZmF1bHRWYWx1ZSA9IGRlZmF1bHRDb25zdGFudF8xO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0ID0geyBmdW5jdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVmYXVsdENvbnN0YW50XzE7IH0sIGRlcGVuZHNPbjogXCJcIiB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSAnZGVmYXVsdCcgb3B0aW9uIG9mIHR5cGUgJ1wiICsgaGVscGVyc18xLmdldFR5cGVOYW1lKG9wdGlvbnMuZGVmYXVsdCkgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlPcHRpb25zKG9wdGlvbnMuZGVmYXVsdCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdE9wdGlvbnNfMSA9IG9wdGlvbnMuZGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLmRlZmF1bHQuZnVuY3Rpb24pICE9PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSAnZGVmYXVsdCcgZnVuY3Rpb24gb2YgdHlwZSAnXCIgKyBoZWxwZXJzXzEuZ2V0VHlwZU5hbWUob3B0aW9ucy5kZWZhdWx0LmZ1bmN0aW9uKSArIFwiJy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0Rm5fMSA9IG9wdGlvbnMuZGVmYXVsdC5mdW5jdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlLm1vZGVsLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IGNhbGN1bGF0ZWRfcHJvcGVydHlfcnVsZV8xLkNhbGN1bGF0ZWRQcm9wZXJ0eVJ1bGUodGFyZ2V0VHlwZSwgbnVsbCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IF90aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlOiBkZWZhdWx0Rm5fMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlT2Y6IHJlc29sdmVEZXBlbmRzT24oX3RoaXMsIFwiZGVmYXVsdFwiLCBkZWZhdWx0T3B0aW9uc18xLmRlcGVuZHNPbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlZmF1bHRWYWx1ZTogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZWdpc3RlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFsbG93ZWQgVmFsdWVzXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFsbG93ZWRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMuYWxsb3dlZFZhbHVlcykgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEFsbG93ZWRWYWx1ZXNfMSA9IG9wdGlvbnMuYWxsb3dlZFZhbHVlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWxsb3dlZFZhbHVlc0Z1bmN0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JpZ2luYWxBbGxvd2VkVmFsdWVzXzEuY2FsbCh0aGlzKTsgfTtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmdldCA9IHsgZnVuY3Rpb246IGFsbG93ZWRWYWx1ZXNGdW5jdGlvbiwgZGVwZW5kc09uOiBcIlwiIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eU9wdGlvbnMob3B0aW9ucy5hbGxvd2VkVmFsdWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbGxvd2VkVmFsdWVzT3B0aW9uc18xID0gb3B0aW9ucy5hbGxvd2VkVmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMuYWxsb3dlZFZhbHVlcy5mdW5jdGlvbikgIT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb3BlcnR5ICdhbGxvd2VkVmFsdWVzJyBmdW5jdGlvbiBvZiB0eXBlICdcIiArIGhlbHBlcnNfMS5nZXRUeXBlTmFtZShvcHRpb25zLmFsbG93ZWRWYWx1ZXMuZnVuY3Rpb24pICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VHlwZS5tb2RlbC5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChuZXcgYWxsb3dlZF92YWx1ZXNfcnVsZV8xLkFsbG93ZWRWYWx1ZXNSdWxlKHRhcmdldFR5cGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBfdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogYWxsb3dlZFZhbHVlc09wdGlvbnNfMS5mdW5jdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZVZhbGlkYXRpb246IGFsbG93ZWRWYWx1ZXNPcHRpb25zXzEuaWdub3JlVmFsaWRhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZlbnRJbnZhbGlkVmFsdWVzOiBhbGxvd2VkVmFsdWVzT3B0aW9uc18xLnByZXZlbnRJbnZhbGlkVmFsdWVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2VPZjogcmVzb2x2ZURlcGVuZHNPbihfdGhpcywgXCJhbGxvd2VkVmFsdWVzXCIsIGFsbG93ZWRWYWx1ZXNPcHRpb25zXzEuZGVwZW5kc09uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkucmVnaXN0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvcGVydHkgJ2dldCcgb3B0aW9uIG9mIHR5cGUgJ1wiICsgaGVscGVyc18xLmdldFR5cGVOYW1lKG9wdGlvbnMuZ2V0KSArIFwiJy5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmFuZ2VcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtaW5fMTtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnJhbmdlLm1pbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlWYWx1ZUZ1bmN0aW9uKG9wdGlvbnMucmFuZ2UubWluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5fMSA9IG9wdGlvbnMucmFuZ2UubWluO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlXzEuaXNWYWx1ZShvcHRpb25zLnJhbmdlLm1pbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkNvbnN0YW50XzEgPSBvcHRpb25zLnJhbmdlLm1pbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluXzEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtaW5Db25zdGFudF8xOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSAncmFuZ2UubWluJyBvcHRpb24gb2YgdHlwZSAnXCIgKyBoZWxwZXJzXzEuZ2V0VHlwZU5hbWUob3B0aW9ucy5yYW5nZS5taW4pICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF4XzE7XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yYW5nZS5tYXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VmFsdWVGdW5jdGlvbihvcHRpb25zLnJhbmdlLm1heCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4XzEgPSBvcHRpb25zLnJhbmdlLm1heDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZV8xLmlzVmFsdWUob3B0aW9ucy5yYW5nZS5tYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhDb25zdGFudF8xID0gb3B0aW9ucy5yYW5nZS5tYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF8xID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4Q29uc3RhbnRfMTsgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvcGVydHkgJ3JhbmdlLm1heCcgb3B0aW9uIG9mIHR5cGUgJ1wiICsgaGVscGVyc18xLmdldFR5cGVOYW1lKG9wdGlvbnMucmFuZ2UubWF4KSArIFwiJy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0VHlwZS5tb2RlbC5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9uQ2hhbmdlT2YgPSByZXNvbHZlRGVwZW5kc09uKF90aGlzLCBcInJhbmdlXCIsIG9wdGlvbnMucmFuZ2UuZGVwZW5kc09uKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXcgcmFuZ2VfcnVsZV8xLlJhbmdlUnVsZSh0YXJnZXRUeXBlLCB7IHByb3BlcnR5OiBfdGhpcywgb25DaGFuZ2VPZjogb25DaGFuZ2VPZiwgbWluOiBtaW5fMSwgbWF4OiBtYXhfMSB9KS5yZWdpc3RlcigpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTGVuZ3RoXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1pbl8yO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoLm1pbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvcGVydHlWYWx1ZUZ1bmN0aW9uKG9wdGlvbnMubGVuZ3RoLm1pbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluXzIgPSBvcHRpb25zLmxlbmd0aC5taW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVfMS5pc1ZhbHVlKG9wdGlvbnMubGVuZ3RoLm1pbiwgTnVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWluQ29uc3RhbnRfMiA9IG9wdGlvbnMubGVuZ3RoLm1pbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluXzIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtaW5Db25zdGFudF8yOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm9wZXJ0eSAnbGVuZ3RoLm1pbicgb3B0aW9uIG9mIHR5cGUgJ1wiICsgaGVscGVyc18xLmdldFR5cGVOYW1lKG9wdGlvbnMubGVuZ3RoLm1pbikgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBtYXhfMjtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aC5tYXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb3BlcnR5VmFsdWVGdW5jdGlvbihvcHRpb25zLmxlbmd0aC5tYXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF8yID0gb3B0aW9ucy5sZW5ndGgubWF4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlXzEuaXNWYWx1ZShvcHRpb25zLmxlbmd0aC5tYXgsIE51bWJlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heENvbnN0YW50XzIgPSBvcHRpb25zLmxlbmd0aC5tYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF8yID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4Q29uc3RhbnRfMjsgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvcGVydHkgJ2xlbmd0aC5tYXgnIG9wdGlvbiBvZiB0eXBlICdcIiArIGhlbHBlcnNfMS5nZXRUeXBlTmFtZShvcHRpb25zLmxlbmd0aC5tYXgpICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRUeXBlLm1vZGVsLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb25DaGFuZ2VPZiA9IHJlc29sdmVEZXBlbmRzT24oX3RoaXMsIFwibGVuZ3RoXCIsIG9wdGlvbnMubGVuZ3RoLmRlcGVuZHNPbik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgbGlzdF9sZW5ndGhfcnVsZV8xLkxpc3RMZW5ndGhSdWxlKHRhcmdldFR5cGUsIHsgcHJvcGVydHk6IF90aGlzLCBvbkNoYW5nZU9mOiBvbkNoYW5nZU9mLCBtaW46IG1pbl8yLCBtYXg6IG1heF8yIH0pLnJlZ2lzdGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgc3RyaW5nX2xlbmd0aF9ydWxlXzEuU3RyaW5nTGVuZ3RoUnVsZSh0YXJnZXRUeXBlLCB7IHByb3BlcnR5OiBfdGhpcywgb25DaGFuZ2VPZjogb25DaGFuZ2VPZiwgbWluOiBtaW5fMiwgbWF4OiBtYXhfMiB9KS5yZWdpc3RlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlcXVpcmVkXHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWRPcHRpb25zID0gb3B0aW9ucy5yZXF1aXJlZDtcclxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHJlcXVpcmVkIG9wdGlvbnMgb24gcHJvcGVydHkgc28gdGhhdCB0aGV5IGNhbiBiZSByZWZlcmVuY2VkIGV4dGVybmFsbHlcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlcXVpcmVkID0gcmVxdWlyZWRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIFJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zLnJlcXVpcmVkKSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1aXJlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRUeXBlLm1vZGVsLnJlYWR5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZFJ1bGUgPSBuZXcgcmVxdWlyZWRfcnVsZV8xLlJlcXVpcmVkUnVsZSh0YXJnZXRUeXBlLCB7IHByb3BlcnR5OiBfdGhpcyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkUnVsZS5yZWdpc3RlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBDb25kaXRpb25hbGx5IFJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWRGbl8xO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXF1aXJlZE1lc3NhZ2VfMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWlyZWREZXBlbmRzT25fMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9wZXJ0eU9wdGlvbnMob3B0aW9ucy5yZXF1aXJlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRGbl8xID0gb3B0aW9ucy5yZXF1aXJlZC5mdW5jdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRNZXNzYWdlXzEgPSBvcHRpb25zLnJlcXVpcmVkLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkRGVwZW5kc09uXzEgPSBvcHRpb25zLnJlcXVpcmVkLmRlcGVuZHNPbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkRm5fMSA9IG9wdGlvbnMucmVxdWlyZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFR5cGUubW9kZWwucmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAobmV3IHJlcXVpcmVkX3J1bGVfMS5SZXF1aXJlZFJ1bGUodGFyZ2V0VHlwZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IF90aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlbjogcmVxdWlyZWRGbl8xLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVxdWlyZWRNZXNzYWdlXzEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZU9mOiByZXF1aXJlZERlcGVuZHNPbl8xID8gcmVzb2x2ZURlcGVuZHNPbihfdGhpcywgXCJyZXF1aXJlZFwiLCByZXF1aXJlZERlcGVuZHNPbl8xKSA6IG51bGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpLnJlZ2lzdGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRXJyb3JcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KG9wdGlvbnMuZXJyb3IpID8gb3B0aW9ucy5lcnJvciA6IFtvcHRpb25zLmVycm9yXSkuZm9yRWFjaChmdW5jdGlvbiAoZXJyb3JPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yRm4gPSBlcnJvck9wdGlvbnMuZnVuY3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yT3B0aW9ucy5yZXNvdXJjZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JGbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck9wdGlvbnMuZnVuY3Rpb24uY2FsbCh0aGlzKSA/IHRhcmdldFR5cGUubW9kZWwuZ2V0UmVzb3VyY2UoZXJyb3JPcHRpb25zLnJlc291cmNlKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yRGVwZW5kc09uID0gZXJyb3JPcHRpb25zLmRlcGVuZHNPbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChlcnJvckZuKSAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvcGVydHkgJ2Vycm9yJyBmdW5jdGlvbiBvZiB0eXBlICdcIiArIGhlbHBlcnNfMS5nZXRUeXBlTmFtZShlcnJvck9wdGlvbnMuZnVuY3Rpb24pICsgXCInLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbmRpdGlvblR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yT3B0aW9ucy5jb2RlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb25UeXBlID0gY29uZGl0aW9uX3R5cGVfMS5Db25kaXRpb25UeXBlLmdldChlcnJvck9wdGlvbnMuY29kZSkgfHwgbmV3IGNvbmRpdGlvbl90eXBlXzEuRXJyb3JDb25kaXRpb25UeXBlKGVycm9yT3B0aW9ucy5jb2RlLCBcImVycm9yXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFR5cGUubW9kZWwucmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAobmV3IHZhbGlkYXRpb25fcnVsZV8xLlZhbGlkYXRpb25SdWxlKHRhcmdldFR5cGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBfdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IGVycm9yT3B0aW9ucy5wcm9wZXJ0aWVzID8gaGVscGVyc18xLmZsYXRNYXAoZXJyb3JPcHRpb25zLnByb3BlcnRpZXMsIGZ1bmN0aW9uIChwKSB7IHJldHVybiB0YXJnZXRUeXBlLmdldFBhdGhzKHApOyB9KSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZU9mOiByZXNvbHZlRGVwZW5kc09uKF90aGlzLCBcIlwiLCBlcnJvckRlcGVuZHNPbiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvckZuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uVHlwZTogY29uZGl0aW9uVHlwZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkucmVnaXN0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgUHJvcGVydHkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChwcm9wKSB7XHJcbiAgICAgICAgaWYgKHByb3AgPT09IG51bGwgfHwgcHJvcCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3AgaW5zdGFuY2VvZiBwcm9wZXJ0eV9jaGFpbl8xLlByb3BlcnR5Q2hhaW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHByb3AuZXF1YWxzKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJvcCBpbnN0YW5jZW9mIFByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzID09PSBwcm9wO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUuZWFjaCA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrLCBmaWx0ZXIpIHtcclxuICAgICAgICBpZiAoZmlsdGVyID09PSB2b2lkIDApIHsgZmlsdGVyID0gbnVsbDsgfVxyXG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlciA9PT0gdGhpcylcclxuICAgICAgICAgICAgY2FsbGJhY2sob2JqLCB0aGlzKTtcclxuICAgIH07XHJcbiAgICBQcm9wZXJ0eS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwidGhpczxcIiArIHRoaXMuY29udGFpbmluZ1R5cGUgKyBcIj4uXCIgKyB0aGlzLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgUHJvcGVydHkucHJvdG90eXBlLmNhblNldFZhbHVlID0gZnVuY3Rpb24gKG9iaiwgdmFsKSB7XHJcbiAgICAgICAgLy8gTk9URTogb25seSBhbGxvdyB2YWx1ZXMgb2YgdGhlIGNvcnJlY3QgZGF0YSB0eXBlIHRvIGJlIHNldCBpbiB0aGUgbW9kZWxcclxuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogV2FybiBhYm91dCBzZXR0aW5nIHZhbHVlIHRvIHVuZGVmaW5lZD9cclxuICAgICAgICAgICAgLy8gbG9nV2FybmluZyhcIllvdSBzaG91bGQgbm90IHNldCBwcm9wZXJ0eSB2YWx1ZXMgdG8gdW5kZWZpbmVkLCB1c2UgbnVsbCBpbnN0ZWFkOiBwcm9wZXJ0eSA9IC5cIiArIHRoaXMuX25hbWUgKyBcIi5cIik7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihgWW91IHNob3VsZCBub3Qgc2V0IHByb3BlcnR5IHZhbHVlcyB0byB1bmRlZmluZWQsIHVzZSBudWxsIGluc3RlYWQ6IHByb3BlcnR5ID0gJHt0aGlzLm5hbWV9LmApO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZm9yIGVudGl0aWVzIGNoZWNrIGJhc2UgdHlwZXMgYXMgd2VsbFxyXG4gICAgICAgIGlmICh2YWwuY29uc3RydWN0b3IgJiYgdmFsLmNvbnN0cnVjdG9yLm1ldGEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgdmFsVHlwZSA9IHZhbC5jb25zdHJ1Y3Rvci5tZXRhOyB2YWxUeXBlOyB2YWxUeXBlID0gdmFsVHlwZS5iYXNlVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbFR5cGUuanN0eXBlID09PSB0aGlzLnByb3BlcnR5VHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGF0YSB0eXBlc1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdmFsT2JqZWN0VHlwZSA9IHZhbC5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgLy8gXCJOb3JtYWxpemVcIiBkYXRhIHR5cGUgaW4gY2FzZSBpdCBjYW1lIGZyb20gYW5vdGhlciBmcmFtZSBhcyB3ZWxsIGFzIGVuc3VyZSB0aGF0IHRoZSB0eXBlcyBhcmUgdGhlIHNhbWVcclxuICAgICAgICAgICAgc3dpdGNoIChoZWxwZXJzXzEuZ2V0VHlwZU5hbWUodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbE9iamVjdFR5cGUgPSBTdHJpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsT2JqZWN0VHlwZSA9IE51bWJlcjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsT2JqZWN0VHlwZSA9IEJvb2xlYW47XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGF0ZVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbE9iamVjdFR5cGUgPSBEYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsT2JqZWN0VHlwZSA9IEFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHZhbHVlIHByb3BlcnR5IHR5cGUgY2hlY2tcclxuICAgICAgICAgICAgcmV0dXJuIHZhbE9iamVjdFR5cGUgPT09IHRoaXMucHJvcGVydHlUeXBlIHx8XHJcbiAgICAgICAgICAgICAgICAvLyBlbnRpdHkgYXJyYXkgdHlwZSBjaGVja1xyXG4gICAgICAgICAgICAgICAgKHZhbE9iamVjdFR5cGUgPT09IEFycmF5ICYmIHRoaXMuaXNMaXN0ICYmICghdGhpcy5wcm9wZXJ0eVR5cGUgfHwgdmFsLmV2ZXJ5KGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlXzEuaXNFbnRpdHlUeXBlKHRoaXMucHJvcGVydHlUeXBlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuY29uc3RydWN0b3IgJiYgY2hpbGQuY29uc3RydWN0b3IubWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY2hpbGRUeXBlID0gY2hpbGQuY29uc3RydWN0b3IubWV0YTsgY2hpbGRUeXBlOyBjaGlsZFR5cGUgPSBjaGlsZFR5cGUuYmFzZVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRUeXBlLmpzdHlwZSA9PT0gdGhpcy5wcm9wZXJ0eVR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtT2JqZWN0VHlwZSA9IGNoaWxkLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcIk5vcm1hbGl6ZVwiIGRhdGEgdHlwZSBpbiBjYXNlIGl0IGNhbWUgZnJvbSBhbm90aGVyIGZyYW1lIGFzIHdlbGwgYXMgZW5zdXJlIHRoYXQgdGhlIHR5cGVzIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGhlbHBlcnNfMS5nZXRUeXBlTmFtZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtT2JqZWN0VHlwZSA9IFN0cmluZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtT2JqZWN0VHlwZSA9IE51bWJlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbU9iamVjdFR5cGUgPSBCb29sZWFuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtT2JqZWN0VHlwZSA9IERhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtT2JqZWN0VHlwZSA9IEFycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtT2JqZWN0VHlwZSA9PT0gdGhpcy5wcm9wZXJ0eVR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgdGhpcykpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUHJvcGVydHkucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24gKG9iaiwgdmFsLCBhZGRpdGlvbmFsQXJncykge1xyXG4gICAgICAgIGlmIChvYmogPT09IHZvaWQgMCkgeyBvYmogPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHZhbCA9PT0gdm9pZCAwKSB7IHZhbCA9IG51bGw7IH1cclxuICAgICAgICBpZiAoYWRkaXRpb25hbEFyZ3MgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsQXJncyA9IG51bGw7IH1cclxuICAgICAgICBpZiAob2JqID09PSB1bmRlZmluZWQgfHwgb2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBcIiArIChhcmd1bWVudHMubGVuZ3RoID4gMSA/IFwic2V0XCIgOiBcImdldFwiKSArIFwiIHZhbHVlIGZvciBwcm9wZXJ0eSBcXFwiXCIgKyB0aGlzLm5hbWUgKyBcIlxcXCIgb24gdHlwZSBcXFwiXCIgKyB0aGlzLmNvbnRhaW5pbmdUeXBlICsgXCJcXFwiOiB0YXJnZXQgaXMgbnVsbCBvciB1bmRlZmluZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgUHJvcGVydHkkc2V0dGVyKHRoaXMsIG9iaiwgdmFsLCBhZGRpdGlvbmFsQXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvcGVydHkkZ2V0dGVyKHRoaXMsIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFByb3BlcnR5LnByb3RvdHlwZS5pc0luaXRlZCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAvLyBJZiB0aGUgYmFja2luZyBmaWVsZCBoYXMgYmVlbiBjcmVhdGVkLCB0aGUgcHJvcGVydHkgaXMgaW5pdGlhbGl6ZWRcclxuICAgICAgICByZXR1cm4gb2JqLl9fZmllbGRzX18uaGFzT3duUHJvcGVydHkodGhpcy5uYW1lKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJvcGVydHk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUHJvcGVydHkgPSBQcm9wZXJ0eTtcclxuZnVuY3Rpb24gaXNQcm9wZXJ0eVZhbHVlRnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIChvYmopID09PSBcImZ1bmN0aW9uXCI7XHJcbn1cclxuZXhwb3J0cy5pc1Byb3BlcnR5VmFsdWVGdW5jdGlvbiA9IGlzUHJvcGVydHlWYWx1ZUZ1bmN0aW9uO1xyXG5mdW5jdGlvbiBpc1Byb3BlcnR5Qm9vbGVhbkZ1bmN0aW9uQW5kT3B0aW9ucyhvYmopIHtcclxuICAgIHJldHVybiB0eXBlb2YgKG9iaikgPT09IFwib2JqZWN0XCI7XHJcbn1cclxuZXhwb3J0cy5pc1Byb3BlcnR5Qm9vbGVhbkZ1bmN0aW9uQW5kT3B0aW9ucyA9IGlzUHJvcGVydHlCb29sZWFuRnVuY3Rpb25BbmRPcHRpb25zO1xyXG5mdW5jdGlvbiBpc1Byb3BlcnR5Qm9vbGVhbkZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIHR5cGVvZiAob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xyXG59XHJcbmV4cG9ydHMuaXNQcm9wZXJ0eUJvb2xlYW5GdW5jdGlvbiA9IGlzUHJvcGVydHlCb29sZWFuRnVuY3Rpb247XHJcbmZ1bmN0aW9uIGlzUHJvcGVydHlPcHRpb25zKG9iaiwgY2hlY2spIHtcclxuICAgIGlmIChjaGVjayA9PT0gdm9pZCAwKSB7IGNoZWNrID0gbnVsbDsgfVxyXG4gICAgcmV0dXJuIGhlbHBlcnNfMS5pc1R5cGUob2JqLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gaGVscGVyc18xLmdldFR5cGVOYW1lKGQpID09PSBcIm9iamVjdFwiICYmICghY2hlY2sgfHwgY2hlY2soZCkpOyB9KTtcclxufVxyXG5leHBvcnRzLmlzUHJvcGVydHlPcHRpb25zID0gaXNQcm9wZXJ0eU9wdGlvbnM7XHJcbi8qKlxyXG4gKiBHZXRzIGEgZm9ybWF0IG9iamVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5J3MgbGFiZWwsIGlmIGl0IGlzIGR5bmFtaWMgKGkuZS4gY29udGFpbnMgZm9ybWF0IHRva2VucylcclxuICovXHJcbmZ1bmN0aW9uIGdldExhYmVsRm9ybWF0KHByb3BlcnR5KSB7XHJcbiAgICBpZiAocHJvcGVydHkubGFiZWwgJiYgcHJvcGVydHkubGFiZWxJc0Zvcm1hdCkge1xyXG4gICAgICAgIHZhciBsYWJlbFNvdXJjZVR5cGUgPSBnZXRMYWJlbFNvdXJjZVR5cGUocHJvcGVydHkpO1xyXG4gICAgICAgIHJldHVybiBsYWJlbFNvdXJjZVR5cGUubW9kZWwuZ2V0Rm9ybWF0KGxhYmVsU291cmNlVHlwZS5qc3R5cGUsIHByb3BlcnR5LmxhYmVsKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldExhYmVsRm9ybWF0ID0gZ2V0TGFiZWxGb3JtYXQ7XHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBtb2RlbCB0eXBlIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZXZhbHVhdGUgdGhlXHJcbiAqIHByb3BlcnR5J3MgbGFiZWwsIGlmIGl0IGlzIGR5bmFtaWMgKGkuZS4gY29udGFpbnMgZm9ybWF0IHRva2VucylcclxuICovXHJcbmZ1bmN0aW9uIGdldExhYmVsU291cmNlVHlwZShwcm9wZXJ0eSkge1xyXG4gICAgLy8gSWYgYSBsYWJlbCBzb3VyY2UgaXMgc3BlY2lmaWVkLCB0aGVuIGRldGVybWluZSBpdCdzIG1vZGVsIHR5cGVcclxuICAgIGlmIChwcm9wZXJ0eS5sYWJlbFNvdXJjZSkge1xyXG4gICAgICAgIHZhciBsYWJlbFNvdXJjZVR5cGUgPSBwcm9wZXJ0eS5sYWJlbFNvdXJjZS5wcm9wZXJ0eVR5cGU7XHJcbiAgICAgICAgaWYgKHR5cGVfMS5pc0VudGl0eVR5cGUobGFiZWxTb3VyY2VUeXBlKSlcclxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsU291cmNlVHlwZS5tZXRhO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb3BlcnR5LmNvbnRhaW5pbmdUeXBlO1xyXG59XHJcbmV4cG9ydHMuZ2V0TGFiZWxTb3VyY2VUeXBlID0gZ2V0TGFiZWxTb3VyY2VUeXBlO1xyXG4vKipcclxuICogRXZhbHVhdGVzIHRoZSBnaXZlbiBwcm9wZXJ0eSdzIGxhYmVsLCB1c2luZyB0aGUgZ2l2ZW4gZW50aXR5IGFzIGNvbnRleHQgaWYgdGhlIGxhYmVsIGlzIGR5bmFtaWMgKGkuZS4gY29udGFpbnMgZm9ybWF0IHRva2VucylcclxuICovXHJcbmZ1bmN0aW9uIGV2YWx1YXRlTGFiZWwocHJvcGVydHksIGVudGl0eSkge1xyXG4gICAgaWYgKHByb3BlcnR5LmxhYmVsSXNGb3JtYXQpIHtcclxuICAgICAgICB2YXIgbGFiZWxGb3JtYXQgPSBnZXRMYWJlbEZvcm1hdChwcm9wZXJ0eSk7XHJcbiAgICAgICAgdmFyIGxhYmVsRm9ybWF0SW5zdGFuY2UgPSBlbnRpdHk7XHJcbiAgICAgICAgaWYgKHByb3BlcnR5LmxhYmVsU291cmNlKSB7XHJcbiAgICAgICAgICAgIGxhYmVsRm9ybWF0SW5zdGFuY2UgPSBwcm9wZXJ0eS5sYWJlbFNvdXJjZS52YWx1ZShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGFiZWxGb3JtYXQuY29udmVydChsYWJlbEZvcm1hdEluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eS5sYWJlbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmV2YWx1YXRlTGFiZWwgPSBldmFsdWF0ZUxhYmVsO1xyXG5mdW5jdGlvbiBQcm9wZXJ0eSRmb3JtYXQocHJvcCwgdmFsKSB7XHJcbiAgICBpZiAocHJvcC5mb3JtYXQpIHtcclxuICAgICAgICByZXR1cm4gcHJvcC5mb3JtYXQuY29udmVydCh2YWwpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUHJvcGVydHkkZm9ybWF0ID0gUHJvcGVydHkkZm9ybWF0O1xyXG4vLyBleHBvcnQgZnVuY3Rpb24gUHJvcGVydHkkZXF1YWxzKHByb3AxOiBQcm9wZXJ0eSB8IElQcm9wZXJ0eUNoYWluLCBwcm9wMjogUHJvcGVydHkgfCBJUHJvcGVydHlDaGFpbik6IGJvb2xlYW4ge1xyXG4vLyBcdGlmIChwcm9wMSA9PT0gbnVsbCB8fCBwcm9wMSA9PT0gdW5kZWZpbmVkIHx8IHByb3AyID09PSBudWxsIHx8IHByb3AyID09PSB1bmRlZmluZWQpIHtcclxuLy8gXHRcdHJldHVybjtcclxuLy8gXHR9XHJcbi8vIFx0aWYgKFByb3BlcnR5Q2hhaW4kaXNQcm9wZXJ0eUNoYWluKHByb3AxKSkge1xyXG4vLyBcdFx0cmV0dXJuIChwcm9wMSBhcyBQcm9wZXJ0eUNoYWluKS5lcXVhbHMocHJvcDIpO1xyXG4vLyBcdH1cclxuLy8gXHRpZiAoUHJvcGVydHlDaGFpbiRpc1Byb3BlcnR5Q2hhaW4ocHJvcDIpKSB7XHJcbi8vIFx0XHRyZXR1cm4gKHByb3AyIGFzIFByb3BlcnR5Q2hhaW4pLmVxdWFscyhwcm9wMSk7XHJcbi8vIFx0fVxyXG4vLyBcdGlmIChQcm9wZXJ0eSRpc1Byb3BlcnR5KHByb3AxKSAmJiBQcm9wZXJ0eSRpc1Byb3BlcnR5KHByb3AyKSkge1xyXG4vLyBcdFx0cmV0dXJuIHByb3AxID09PSBwcm9wMjtcclxuLy8gXHR9XHJcbi8vIH1cclxuZnVuY3Rpb24gUHJvcGVydHkkZ2VuZXJhdGVTaG9ydGN1dHMocHJvcGVydHksIHRhcmdldCwgb3ZlcndyaXRlKSB7XHJcbiAgICBpZiAob3ZlcndyaXRlID09PSB2b2lkIDApIHsgb3ZlcndyaXRlID0gbnVsbDsgfVxyXG4gICAgdmFyIHNob3J0Y3V0TmFtZSA9IFwiJFwiICsgcHJvcGVydHkubmFtZTtcclxuICAgIGlmICghKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHNob3J0Y3V0TmFtZSkpIHx8IG92ZXJ3cml0ZSkge1xyXG4gICAgICAgIHRhcmdldFtzaG9ydGN1dE5hbWVdID0gcHJvcGVydHk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Qcm9wZXJ0eSRnZW5lcmF0ZVNob3J0Y3V0cyA9IFByb3BlcnR5JGdlbmVyYXRlU2hvcnRjdXRzO1xyXG5mdW5jdGlvbiBQcm9wZXJ0eSRnZW5lcmF0ZVN0YXRpY1Byb3BlcnR5KHByb3BlcnR5LCB0YXJnZXQpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5Lm5hbWUsIHtcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgZ2V0OiBwcm9wZXJ0eS5nZXR0ZXIsXHJcbiAgICAgICAgc2V0OiBwcm9wZXJ0eS5zZXR0ZXJcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuUHJvcGVydHkkZ2VuZXJhdGVTdGF0aWNQcm9wZXJ0eSA9IFByb3BlcnR5JGdlbmVyYXRlU3RhdGljUHJvcGVydHk7XHJcbmZ1bmN0aW9uIFByb3BlcnR5JGdlbmVyYXRlUHJvdG90eXBlUHJvcGVydHkocHJvcGVydHksIHRhcmdldCkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkubmFtZSwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IHByb3BlcnR5LmdldHRlcixcclxuICAgICAgICBzZXQ6IHByb3BlcnR5LnNldHRlclxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5Qcm9wZXJ0eSRnZW5lcmF0ZVByb3RvdHlwZVByb3BlcnR5ID0gUHJvcGVydHkkZ2VuZXJhdGVQcm90b3R5cGVQcm9wZXJ0eTtcclxuZnVuY3Rpb24gUHJvcGVydHkkZ2VuZXJhdGVPd25Qcm9wZXJ0eShwcm9wZXJ0eSwgb2JqKSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wZXJ0eS5uYW1lLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogcHJvcGVydHkuZ2V0dGVyLFxyXG4gICAgICAgIHNldDogcHJvcGVydHkuc2V0dGVyXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLlByb3BlcnR5JGdlbmVyYXRlT3duUHJvcGVydHkgPSBQcm9wZXJ0eSRnZW5lcmF0ZU93blByb3BlcnR5O1xyXG5mdW5jdGlvbiBQcm9wZXJ0eSRwZW5kaW5nSW5pdChvYmosIHByb3AsIHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IG51bGw7IH1cclxuICAgIHZhciBwZW5kaW5nSW5pdDtcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBcIl9fcGVuZGluZ0luaXRfX1wiKSkge1xyXG4gICAgICAgIHBlbmRpbmdJbml0ID0gb2JqLl9fcGVuZGluZ0luaXRfXztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIFwiX19wZW5kaW5nSW5pdF9fXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIHZhbHVlOiAocGVuZGluZ0luaXQgPSB7fSksIHdyaXRhYmxlOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkZWxldGUgcGVuZGluZ0luaXRbcHJvcC5uYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdJbml0W3Byb3AubmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gb2JqLl9fZmllbGRzX19bcHJvcC5uYW1lXTtcclxuICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgfHwgcGVuZGluZ0luaXRbcHJvcC5uYW1lXSA9PT0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlByb3BlcnR5JHBlbmRpbmdJbml0ID0gUHJvcGVydHkkcGVuZGluZ0luaXQ7XHJcbmZ1bmN0aW9uIFByb3BlcnR5JHN1YkFycmF5RXZlbnRzKG9iaiwgcHJvcGVydHksIGFycmF5KSB7XHJcbiAgICBhcnJheS5jaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgIFByb3BlcnR5JHBlbmRpbmdJbml0KG9iaiwgcHJvcGVydHksIGZhbHNlKTtcclxuICAgICAgICAvLyBEb24ndCByYWlzZSBhIG5vLW9wIGxpc3QgY2hhbmdlIGV2ZW50XHJcbiAgICAgICAgaWYgKCFhcmdzLmNoYW5nZXMubGVuZ3RoKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gTk9URTogb2xkVmFsdWUgaXMgbm90IGN1cnJlbnRseSBpbXBsZW1lbnRlZCBmb3IgbGlzdHNcclxuICAgICAgICB2YXIgZXZlbnRBcmdzID0geyBlbnRpdHk6IG9iaiwgcHJvcGVydHk6IHByb3BlcnR5LCBuZXdWYWx1ZTogYXJyYXkgfTtcclxuICAgICAgICAvLyBBc3NpZ24gYWRkaXRpb25hbCBjb2xsZWN0aW9uIGNoYW5nZSBldmVudCBhcmd1bWVudHMgdG8gdGhlIHByb3BlcnR5IGNoYW5nZSBldmVudFxyXG4gICAgICAgIHZhciBhZGRpdGlvbmFsQXJncyA9IF9fYXNzaWduKHsgY2hhbmdlczogYXJncy5jaGFuZ2VzLCBjb2xsZWN0aW9uQ2hhbmdlZDogdHJ1ZSB9LCBhcmdzLmFkZGl0aW9uYWxBcmdzKTtcclxuICAgICAgICBwcm9wZXJ0eS5jb250YWluaW5nVHlwZS5tb2RlbC5saXN0Q2hhbmdlZC5wdWJsaXNoKG9iaiwgaGVscGVyc18xLm1lcmdlKGV2ZW50QXJncywgYWRkaXRpb25hbEFyZ3MpKTtcclxuICAgICAgICBwcm9wZXJ0eS5jaGFuZ2VkLnB1Ymxpc2gob2JqLCBoZWxwZXJzXzEubWVyZ2UoZXZlbnRBcmdzLCBhZGRpdGlvbmFsQXJncykpO1xyXG4gICAgICAgIG9iai5jaGFuZ2VkLnB1Ymxpc2gob2JqLCBoZWxwZXJzXzEubWVyZ2UoZXZlbnRBcmdzLCBhZGRpdGlvbmFsQXJncykpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gUHJvcGVydHkkZ2V0SW5pdGlhbFZhbHVlKHByb3BlcnR5KSB7XHJcbiAgICAvLyBDb25zdGFudFxyXG4gICAgaWYgKHByb3BlcnR5LmlzQ29uc3RhbnQpXHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9wZXJ0eS5jb25zdGFudCA9PT0gXCJmdW5jdGlvblwiID8gKHByb3BlcnR5LmNvbnN0YW50ID0gcHJvcGVydHkuY29uc3RhbnQoKSkgOiBwcm9wZXJ0eS5jb25zdGFudDtcclxuICAgIHZhciB2YWwgPSBwcm9wZXJ0eS5kZWZhdWx0VmFsdWU7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XHJcbiAgICAgICAgdmFsID0gb2JzZXJ2YWJsZV9hcnJheV8xLk9ic2VydmFibGVBcnJheS5lbnN1cmVPYnNlcnZhYmxlKHZhbCk7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgdG9TdHJpbmcgb24gYXJyYXlzIHNvIHRoYXQgd2UgZ2V0IGEgY29tbWEtZGVsaW1pdGVkIGxpc3RcclxuICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgdG9TdHJpbmcgb24gb2JzZXJ2YWJsZSBsaXN0P1xyXG4gICAgICAgIC8vIHZhbC50b1N0cmluZyA9IFByb3BlcnR5JF9hcnJheVRvU3RyaW5nLmJpbmQodmFsKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWw7XHJcbn1cclxuZnVuY3Rpb24gUHJvcGVydHkkaW5pdChwcm9wZXJ0eSwgb2JqLCB2YWwpIHtcclxuICAgIFByb3BlcnR5JHBlbmRpbmdJbml0KG9iaiwgcHJvcGVydHksIGZhbHNlKTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmouX19maWVsZHNfXywgcHJvcGVydHkubmFtZSwgeyB2YWx1ZTogdmFsLCB3cml0YWJsZTogdHJ1ZSB9KTtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcclxuICAgICAgICBQcm9wZXJ0eSRzdWJBcnJheUV2ZW50cyhvYmosIHByb3BlcnR5LCBvYnNlcnZhYmxlX2FycmF5XzEuT2JzZXJ2YWJsZUFycmF5LmVuc3VyZU9ic2VydmFibGUodmFsKSk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgb2JzZXJ2YWJsZT9cclxuICAgIG9iai5jaGFuZ2VkLnB1Ymxpc2gob2JqLCB7IGVudGl0eTogb2JqLCBwcm9wZXJ0eTogcHJvcGVydHksIG5ld1ZhbHVlOiB2YWwgfSk7XHJcbn1cclxuZXhwb3J0cy5Qcm9wZXJ0eSRpbml0ID0gUHJvcGVydHkkaW5pdDtcclxuZnVuY3Rpb24gUHJvcGVydHkkZW5zdXJlSW5pdGVkKHByb3BlcnR5LCBvYmopIHtcclxuICAgIC8vIERldGVybWluZSBpZiB0aGUgcHJvcGVydHkgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgd2l0aCBhIHZhbHVlIGFuZCBpbml0aWFsaXplIHRoZSBwcm9wZXJ0eSBpZiBuZWNlc3NhcnlcclxuICAgIGlmICghb2JqLl9fZmllbGRzX18uaGFzT3duUHJvcGVydHkocHJvcGVydHkubmFtZSkpIHtcclxuICAgICAgICBQcm9wZXJ0eSRwZW5kaW5nSW5pdChvYmosIHByb3BlcnR5LCB0cnVlKTtcclxuICAgICAgICAvLyBEbyBub3QgaW5pdGlhbGl6ZSBjYWxjdWxhdGVkIHByb3BlcnRpZXMuIENhbGN1bGF0ZWQgcHJvcGVydGllcyBzaG91bGQgYmUgaW5pdGlhbGl6ZWQgdXNpbmcgYSBwcm9wZXJ0eSBnZXQgcnVsZS5cclxuICAgICAgICBpZiAoIXByb3BlcnR5LmlzQ2FsY3VsYXRlZCkge1xyXG4gICAgICAgICAgICB2YXIgc2V0UGVuZGluZ0luaXQgPSAhcHJvcGVydHkuaXNDb25zdGFudDtcclxuICAgICAgICAgICAgUHJvcGVydHkkaW5pdChwcm9wZXJ0eSwgb2JqLCBQcm9wZXJ0eSRnZXRJbml0aWFsVmFsdWUocHJvcGVydHkpKTtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5LmluaXRpYWxpemVyKSB7XHJcbiAgICAgICAgICAgICAgICBvYmoudXBkYXRlKHByb3BlcnR5Lm5hbWUsIHByb3BlcnR5LmluaXRpYWxpemVyLmNhbGwob2JqKSk7XHJcbiAgICAgICAgICAgICAgICBzZXRQZW5kaW5nSW5pdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE1hcmsgdGhlIHByb3BlcnR5IGFzIHBlbmRpbmcgaW5pdGlhbGl6YXRpb24gaWYgdGhlIHByb3BlcnR5IHZhbHVlIG1heSBuZWVkIHRvXHJcbiAgICAgICAgICAgIC8vIGJlIGVzdGFibGlzaGVkIGJ5IGEgZGVmYXVsdCBjYWxjdWxhdGlvbiBydWxlLCBvciBzb21lIG90aGVyIGV4dGVybmFsIGxvZ2ljLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG5vdCByZWxldmFudCBpZiBpdCBpcyBhIGNvbnN0YW50IG9yIGl0cyB2YWx1ZSBpcyBlc3RhYmxpc2hlZCB2aWEgYW4gaW5pdGlsaXplci5cclxuICAgICAgICAgICAgaWYgKHNldFBlbmRpbmdJbml0KVxyXG4gICAgICAgICAgICAgICAgUHJvcGVydHkkcGVuZGluZ0luaXQob2JqLCBwcm9wZXJ0eSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIFByb3BlcnR5JGdldHRlcihwcm9wZXJ0eSwgb2JqKSB7XHJcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgaGFzIGFuIGluaXRpYWwgKHBvc3NpYmx5IGRlZmF1bHQpIHZhbHVlXHJcbiAgICBQcm9wZXJ0eSRlbnN1cmVJbml0ZWQocHJvcGVydHksIG9iaik7XHJcbiAgICAvLyBSYWlzZSBhY2Nlc3MgZXZlbnRzXHJcbiAgICBwcm9wZXJ0eS5hY2Nlc3NlZC5wdWJsaXNoKG9iaiwgeyBlbnRpdHk6IG9iaiwgcHJvcGVydHk6IHByb3BlcnR5LCB2YWx1ZTogb2JqLl9fZmllbGRzX19bcHJvcGVydHkubmFtZV0gfSk7XHJcbiAgICBvYmouYWNjZXNzZWQucHVibGlzaChvYmosIHsgZW50aXR5OiBvYmosIHByb3BlcnR5OiBwcm9wZXJ0eSB9KTtcclxuICAgIC8vIFJldHVybiB0aGUgcHJvcGVydHkgdmFsdWVcclxuICAgIHJldHVybiBvYmouX19maWVsZHNfX1twcm9wZXJ0eS5uYW1lXTtcclxufVxyXG5mdW5jdGlvbiBQcm9wZXJ0eSRzZXR0ZXIocHJvcGVydHksIG9iaiwgdmFsLCBhZGRpdGlvbmFsQXJncykge1xyXG4gICAgaWYgKGFkZGl0aW9uYWxBcmdzID09PSB2b2lkIDApIHsgYWRkaXRpb25hbEFyZ3MgPSBudWxsOyB9XHJcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcHJvcGVydHkgaGFzIGFuIGluaXRpYWwgKHBvc3NpYmx5IGRlZmF1bHQpIHZhbHVlXHJcbiAgICBQcm9wZXJ0eSRlbnN1cmVJbml0ZWQocHJvcGVydHksIG9iaik7XHJcbiAgICB2YXIgb2xkID0gb2JqLl9fZmllbGRzX19bcHJvcGVydHkubmFtZV07XHJcbiAgICBpZiAoUHJvcGVydHkkc2hvdWxkU2V0VmFsdWUocHJvcGVydHksIG9iaiwgb2xkLCB2YWwpKSB7XHJcbiAgICAgICAgUHJvcGVydHkkc2V0VmFsdWUocHJvcGVydHksIG9iaiwgb2xkLCB2YWwsIGFkZGl0aW9uYWxBcmdzKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIFNldCBwZW5kaW5nSW5pdCB0byBmYWxzZSBoZXJlLCBzaW5jZSB0aGUgc2V0dGVyIGlzIG5vdCBjYWxsZWQgc2luY2UgdGhlIHZhbHVlIGlzIG5vdCBjaGFuZ2luZ1xyXG4gICAgICAgIFByb3BlcnR5JHBlbmRpbmdJbml0KG9iaiwgcHJvcGVydHksIGZhbHNlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlByb3BlcnR5JHNldHRlciA9IFByb3BlcnR5JHNldHRlcjtcclxuZnVuY3Rpb24gUHJvcGVydHkkc2hvdWxkU2V0VmFsdWUocHJvcGVydHksIG9iaiwgb2xkLCB2YWwpIHtcclxuICAgIGlmICghcHJvcGVydHkuY2FuU2V0VmFsdWUob2JqLCB2YWwpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBcIiArIHByb3BlcnR5Lm5hbWUgKyBcIj1cIiArICh2YWwgPT09IHVuZGVmaW5lZCA/IFwiPHVuZGVmaW5lZD5cIiA6IHZhbCkgKyBcIiBmb3IgaW5zdGFuY2UgXCIgKyBvYmoubWV0YS50eXBlLmZ1bGxOYW1lICsgXCJ8XCIgKyBvYmoubWV0YS5pZCArIFwiOiBhIHZhbHVlIG9mIHR5cGUgXCIgKyAodHlwZV8xLmlzRW50aXR5VHlwZShwcm9wZXJ0eS5wcm9wZXJ0eVR5cGUpID8gcHJvcGVydHkucHJvcGVydHlUeXBlLm1ldGEuZnVsbE5hbWUgOiBoZWxwZXJzXzEucGFyc2VGdW5jdGlvbk5hbWUocHJvcGVydHkucHJvcGVydHlUeXBlKSkgKyBcIiB3YXMgZXhwZWN0ZWQuXCIpO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHByb3BlcnR5LnJ1bGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBydWxlID0gX2FbX2ldO1xyXG4gICAgICAgIGlmIChydWxlIGluc3RhbmNlb2YgYWxsb3dlZF92YWx1ZXNfcnVsZV8xLkFsbG93ZWRWYWx1ZXNSdWxlICYmIHJ1bGUucHJldmVudEludmFsaWRWYWx1ZXMgJiYgIXJ1bGUudmFsdWVzKG9iaikuaW5jbHVkZXModmFsKSAmJiB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBcIiArIHByb3BlcnR5Lm5hbWUgKyBcIiwgXFxcIlwiICsgdmFsICsgXCJcXFwiIGlzIG5vdCBhbiBhbGxvd2VkIHZhbHVlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBVcGRhdGUgbGlzdHMgYXMgYmF0Y2ggcmVtb3ZlL2FkZCBvcGVyYXRpb25zXHJcbiAgICBpZiAocHJvcGVydHkuaXNDb25zdGFudCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnN0YW50IHByb3BlcnRpZXMgY2Fubm90IGJlIG1vZGlmaWVkLlwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIGNvbXBhcmUgdmFsdWVzIHNvIHRoYXQgdGhpcyBjaGVjayBpcyBhY2N1cmF0ZSBmb3IgcHJpbWl0aXZlc1xyXG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IChvbGQgPT09IHVuZGVmaW5lZCB8fCBvbGQgPT09IG51bGwpID8gb2xkIDogb2xkLnZhbHVlT2YoKTtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSAodmFsID09PSB1bmRlZmluZWQgfHwgdmFsID09PSBudWxsKSA/IHZhbCA6IHZhbC52YWx1ZU9mKCk7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGUgbmV3IHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBvbGQgdmFsdWUuIEFjY291bnQgZm9yIE5hTiBudW1iZXJzLCB3aGljaCBhcmVcclxuICAgICAgICAvLyBub3QgZXF1aXZhbGVudCAoZXZlbiB0byB0aGVtc2VsdmVzKS4gQWx0aG91Z2ggaXNOYU4gcmV0dXJucyB0cnVlIGZvciBub24tTnVtYmVyIHZhbHVlcywgd2Ugd29uJ3RcclxuICAgICAgICAvLyBnZXQgdGhpcyBmYXIgZm9yIE51bWJlciBwcm9wZXJ0aWVzIHVubGVzcyB0aGUgdmFsdWUgaXMgYWN0dWFsbHkgb2YgdHlwZSBOdW1iZXIgKGEgbnVtYmVyIG9yIE5hTikuXHJcbiAgICAgICAgcmV0dXJuIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUgJiYgIShwcm9wZXJ0eS5wcm9wZXJ0eVR5cGUgPT09IE51bWJlciAmJiBpc05hTihvbGRWYWx1ZSkgJiYgaXNOYU4obmV3VmFsdWUpKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gUHJvcGVydHkkc2V0VmFsdWUocHJvcGVydHksIG9iaiwgY3VycmVudFZhbHVlLCBuZXdWYWx1ZSwgYWRkaXRpb25hbEFyZ3MpIHtcclxuICAgIGlmIChhZGRpdGlvbmFsQXJncyA9PT0gdm9pZCAwKSB7IGFkZGl0aW9uYWxBcmdzID0gbnVsbDsgfVxyXG4gICAgLy8gVXBkYXRlIGxpc3RzIGFzIGJhdGNoIHJlbW92ZS9hZGQgb3BlcmF0aW9uc1xyXG4gICAgaWYgKHByb3BlcnR5LmlzTGlzdCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50QXJyYXkgPSBjdXJyZW50VmFsdWU7XHJcbiAgICAgICAgY3VycmVudEFycmF5LmJhdGNoVXBkYXRlKGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgICAgICBvYnNlcnZhYmxlX2FycmF5XzEudXBkYXRlQXJyYXkoYXJyYXksIG5ld1ZhbHVlKTtcclxuICAgICAgICB9LCBhZGRpdGlvbmFsQXJncyk7XHJcbiAgICAgICAgLy8gU2V0IHBlbmRpbmdJbml0IHRvIGZhbHNlIGhlcmUsIHNpbmNlIGFuIGFycmF5IGNoYW5nZSBldmVudCB3aWxsIG5vdCBiZSByYWlzZWQgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcclxuICAgICAgICAvLyAoZXg6IGFycmF5IHdhcyBwcmV2aW91c2x5IGFuIGVtcHR5IGFycmF5IGFuZCBuZXdWYWx1ZSBpcyBhbHNvIGFuIGVtcHR5IGFycmF5KS5cclxuICAgICAgICBQcm9wZXJ0eSRwZW5kaW5nSW5pdChvYmosIHByb3BlcnR5LCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgb2xkVmFsdWUgPSBjdXJyZW50VmFsdWU7XHJcbiAgICAgICAgLy8gU2V0IG9yIGNyZWF0ZSB0aGUgYmFja2luZyBmaWVsZCB2YWx1ZVxyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLl9fZmllbGRzX18sIHByb3BlcnR5Lm5hbWUpKSB7XHJcbiAgICAgICAgICAgIG9iai5fX2ZpZWxkc19fW3Byb3BlcnR5Lm5hbWVdID0gbmV3VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLl9fZmllbGRzX18sIHByb3BlcnR5Lm5hbWUsIHsgdmFsdWU6IG5ld1ZhbHVlLCB3cml0YWJsZTogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByb3BlcnR5LmlzSWRlbnRpZmllciAmJiBuZXdWYWx1ZSAmJiBuZXdWYWx1ZSAhPT0gb2JqLm1ldGEuaWQpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGlkZW50aWZpZXIgcHJvcGVydHkgaXMgc2V0IG9yIGNoYW5nZWQsIHRoZW4gY2hhbmdlIHRoZSBvYmplY3QncyBpZCBhbmQgcmUtcG9vbCB3aXRoIHRoZSBuZXcgaWRcclxuICAgICAgICAgICAgb2JqLm1ldGEudHlwZS5jaGFuZ2VPYmplY3RJZChvYmoubWV0YS5pZCwgbmV3VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBQcm9wZXJ0eSRwZW5kaW5nSW5pdChvYmosIHByb3BlcnR5LCBmYWxzZSk7XHJcbiAgICAgICAgLy8gRG8gbm90IHJhaXNlIGNoYW5nZSBpZiB0aGUgcHJvcGVydHkgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLlxyXG4gICAgICAgIGlmIChvbGRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudEFyZ3MgPSB7IGVudGl0eTogb2JqLCBwcm9wZXJ0eTogcHJvcGVydHksIG5ld1ZhbHVlOiBuZXdWYWx1ZSwgb2xkVmFsdWU6IG9sZFZhbHVlIH07XHJcbiAgICAgICAgICAgIHByb3BlcnR5LmNvbnRhaW5pbmdUeXBlLm1vZGVsLmFmdGVyUHJvcGVydHlTZXQucHVibGlzaChvYmosIGhlbHBlcnNfMS5tZXJnZShldmVudEFyZ3MsIGFkZGl0aW9uYWxBcmdzKSk7XHJcbiAgICAgICAgICAgIHByb3BlcnR5LmNoYW5nZWQucHVibGlzaChvYmosIGhlbHBlcnNfMS5tZXJnZShldmVudEFyZ3MsIGFkZGl0aW9uYWxBcmdzKSk7XHJcbiAgICAgICAgICAgIG9iai5jaGFuZ2VkLnB1Ymxpc2gob2JqLCBoZWxwZXJzXzEubWVyZ2UoZXZlbnRBcmdzLCBhZGRpdGlvbmFsQXJncykpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBQcm9wZXJ0eSRtYWtlR2V0dGVyKHByb3BlcnR5LCBnZXR0ZXIpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoYWRkaXRpb25hbEFyZ3MpIHtcclxuICAgICAgICBpZiAoYWRkaXRpb25hbEFyZ3MgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsQXJncyA9IG51bGw7IH1cclxuICAgICAgICAvLyBlbnN1cmUgdGhlIHByb3BlcnR5IGlzIGluaXRpYWxpemVkXHJcbiAgICAgICAgcmV0dXJuIGdldHRlcihwcm9wZXJ0eSwgdGhpcywgYWRkaXRpb25hbEFyZ3MpO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBQcm9wZXJ0eSRtYWtlU2V0dGVyKHByb3AsIHNldHRlciwgc2tpcFR5cGVDaGVjaykge1xyXG4gICAgLy8gVE9ETzogSXMgc2V0dGVyIFwiX19ub3RpZmllc1wiIG5lZWRlZD9cclxuICAgIC8vIHNldHRlci5fX25vdGlmaWVzID0gdHJ1ZTtcclxuICAgIGlmIChza2lwVHlwZUNoZWNrID09PSB2b2lkIDApIHsgc2tpcFR5cGVDaGVjayA9IGZhbHNlOyB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgYWRkaXRpb25hbEFyZ3MpIHtcclxuICAgICAgICBpZiAoYWRkaXRpb25hbEFyZ3MgPT09IHZvaWQgMCkgeyBhZGRpdGlvbmFsQXJncyA9IG51bGw7IH1cclxuICAgICAgICBzZXR0ZXIocHJvcCwgdGhpcywgdmFsLCBhZGRpdGlvbmFsQXJncywgc2tpcFR5cGVDaGVjayk7XHJcbiAgICB9O1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlJhbmdlUnVsZSA9IHZvaWQgMDtcclxudmFyIHZhbGlkYXRpb25fcnVsZV8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvbi1ydWxlXCIpO1xyXG52YXIgcHJvcGVydHlfMSA9IHJlcXVpcmUoXCIuL3Byb3BlcnR5XCIpO1xyXG52YXIgbW9kZWxfMSA9IHJlcXVpcmUoXCIuL21vZGVsXCIpO1xyXG4vKipcclxuICogQSBydWxlIHRoYXQgdmFsaWRhdGVzIHRoYXQgYSBwcm9wZXJ0eSB2YWx1ZSBpcyB3aXRoaW4gYSBzcGVjaWZpYyByYW5nZVxyXG4gKi9cclxudmFyIFJhbmdlUnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSYW5nZVJ1bGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBydWxlIHRoYXQgdmFsaWRhdGVzIGEgcHJvcGVydHkgdmFsdWUgaXMgd2l0aGluIGEgc3BlY2lmaWMgcmFuZ2VcclxuICAgICAqIEBwYXJhbSByb290VHlwZSBUaGUgbW9kZWwgdHlwZSB0aGUgcnVsZSBpcyBmb3JcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgcnVsZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSYW5nZVJ1bGUocm9vdFR5cGUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcnVsZSBuYW1lIGlzIHNwZWNpZmllZFxyXG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBcIlJhbmdlXCI7XHJcbiAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5wcm9wZXJ0eS5mb3JtYXQ7XHJcbiAgICAgICAgICAgIHZhciB2YWwgPSBtb2RlbF8xLm5vcm1hbGl6ZShvcHRpb25zLnByb3BlcnR5LnZhbHVlKHRoaXMpLCBmb3JtYXQpO1xyXG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHt9O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5taW4gJiYgb3B0aW9ucy5taW4gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByYW5nZS5taW4gPSBtb2RlbF8xLm5vcm1hbGl6ZShvcHRpb25zLm1pbi5jYWxsKHRoaXMpLCBmb3JtYXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaWxlbnRseSBpZ25vcmUgbWluIGVycm9yc1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heCAmJiBvcHRpb25zLm1heCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1heCA9IG1vZGVsXzEubm9ybWFsaXplKG9wdGlvbnMubWF4LmNhbGwodGhpcyksIGZvcm1hdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbGVudGx5IGlnbm9yZSBtYXggZXJyb3JzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChyYW5nZS5taW4gPT0gbnVsbCB8fCB2YWwgPj0gcmFuZ2UubWluKSAmJiAocmFuZ2UubWF4ID09IG51bGwgfHwgdmFsIDw9IHJhbmdlLm1heCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFZhbHVlIGlzIHdpdGhpbiByYW5nZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGhhc01pbiA9IHJhbmdlLm1pbiB8fCByYW5nZS5taW4gPT09IDA7XHJcbiAgICAgICAgICAgIHZhciBoYXNNYXggPSByYW5nZS5tYXggfHwgcmFuZ2UubWF4ID09PSAwO1xyXG4gICAgICAgICAgICBpZiAoaGFzTWluICYmIGhhc01heClcclxuICAgICAgICAgICAgICAgIHJldHVybiByb290VHlwZS5tb2RlbC5nZXRSZXNvdXJjZShcInJhbmdlLWJldHdlZW5cIikucmVwbGFjZShcInttaW59XCIsIHByb3BlcnR5XzEuUHJvcGVydHkkZm9ybWF0KG9wdGlvbnMucHJvcGVydHksIHJhbmdlLm1pbikgfHwgcmFuZ2UubWluKS5yZXBsYWNlKFwie21heH1cIiwgcHJvcGVydHlfMS5Qcm9wZXJ0eSRmb3JtYXQob3B0aW9ucy5wcm9wZXJ0eSwgcmFuZ2UubWF4KSB8fCByYW5nZS5tYXgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wcm9wZXJ0eS5wcm9wZXJ0eVR5cGUgPT09IERhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNNaW4pXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RUeXBlLm1vZGVsLmdldFJlc291cmNlKFwicmFuZ2Utb24tb3ItYWZ0ZXJcIikucmVwbGFjZShcInttaW59XCIsIHByb3BlcnR5XzEuUHJvcGVydHkkZm9ybWF0KG9wdGlvbnMucHJvcGVydHksIHJhbmdlLm1pbikgfHwgcmFuZ2UubWluKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFR5cGUubW9kZWwuZ2V0UmVzb3VyY2UoXCJyYW5nZS1vbi1vci1iZWZvcmVcIikucmVwbGFjZShcInttYXh9XCIsIHByb3BlcnR5XzEuUHJvcGVydHkkZm9ybWF0KG9wdGlvbnMucHJvcGVydHksIHJhbmdlLm1heCkgfHwgcmFuZ2UubWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGFzTWluKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RUeXBlLm1vZGVsLmdldFJlc291cmNlKFwicmFuZ2UtYXQtbGVhc3RcIikucmVwbGFjZShcInttaW59XCIsIHByb3BlcnR5XzEuUHJvcGVydHkkZm9ybWF0KG9wdGlvbnMucHJvcGVydHksIHJhbmdlLm1pbikgfHwgcmFuZ2UubWluKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3RUeXBlLm1vZGVsLmdldFJlc291cmNlKFwicmFuZ2UtYXQtbW9zdFwiKS5yZXBsYWNlKFwie21heH1cIiwgcHJvcGVydHlfMS5Qcm9wZXJ0eSRmb3JtYXQob3B0aW9ucy5wcm9wZXJ0eSwgcmFuZ2UubWF4KSB8fCByYW5nZS5tYXgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gY2FsbCB0aGUgYmFzZSB0eXBlIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290VHlwZSwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBnZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVsZVxyXG4gICAgUmFuZ2VSdWxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5jb250YWluaW5nVHlwZS5mdWxsTmFtZSArIFwiLlwiICsgdGhpcy5wcm9wZXJ0eS5uYW1lICsgXCIgaW4gcmFuZ2UsIG1pbjogLCBtYXg6IFwiO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSYW5nZVJ1bGU7XHJcbn0odmFsaWRhdGlvbl9ydWxlXzEuVmFsaWRhdGlvblJ1bGUpKTtcclxuZXhwb3J0cy5SYW5nZVJ1bGUgPSBSYW5nZVJ1bGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlJlcXVpcmVkUnVsZSA9IHZvaWQgMDtcclxudmFyIHZhbGlkYXRpb25fcnVsZV8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvbi1ydWxlXCIpO1xyXG4vKipcclxuICogQSBydWxlIHRoYXQgdmFsaWRhdGVzIHRoYXQgYSBwcm9wZXJ0eSBoYXMgYSB2YWx1ZVxyXG4gKi9cclxudmFyIFJlcXVpcmVkUnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSZXF1aXJlZFJ1bGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBydWxlIHRoYXQgdmFsaWRhdGVzIHRoYXQgYSBwcm9wZXJ0eSBoYXMgYSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSByb290VHlwZSBUaGUgbW9kZWwgdHlwZSB0aGUgcnVsZSBpcyBmb3JcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgcnVsZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXF1aXJlZFJ1bGUocm9vdFR5cGUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcnVsZSBuYW1lIGlzIHNwZWNpZmllZFxyXG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBcIlJlcXVpcmVkXCI7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy53aGVuKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZUZuXzEgPSBvcHRpb25zLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2hlbiAmJiAhb3B0aW9ucy53aGVuLmNhbGwodGhpcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlRm5fMS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBlcnJvciBtZXNzYWdlIGlzIHNwZWNpZmllZFxyXG4gICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2UgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcm9vdFR5cGUubW9kZWwuZ2V0UmVzb3VyY2UoXCJyZXF1aXJlZFwiKTsgfTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2hlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkRm5fMSA9IG9wdGlvbnMuaXNWYWxpZDtcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndoZW4gJiYgIW9wdGlvbnMud2hlbi5jYWxsKHRoaXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZCB3aGV0aGVyIG9yIG5vdCB0aGVyZSBpcyBhIHZhbHVlLCBzaW5jZSByZXF1aXJlZG5lc3MgaXMgbm90IGluIGVmZmVjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRGbl8xLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbiBiYXNlZCBvbiB0aGUgcnVsZSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmlzVmFsaWQgPSBmdW5jdGlvbiAocHJvcCwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMud2hlbiAmJiAhb3B0aW9ucy53aGVuLmNhbGwodGhpcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWQgd2hldGhlciBvciBub3QgdGhlcmUgaXMgYSB2YWx1ZSwgc2luY2UgcmVxdWlyZWRuZXNzIGlzIG5vdCBpbiBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCB8fCB2YWwgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCbGFuayBzdHJpbmcgZG9lcyBub3QgcGFzcyByZXF1aXJlZCBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiICYmIHZhbC50cmltKCkgPT09IFwiXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBFbXB0eSBhcnJheSBkb2VzIG5vdCBwYXNzIHJlcXVpcmVkIGNoZWNrXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsc2UgZG9lcyBub3QgcGFzcyByZXF1aXJlZCBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcImJvb2xlYW5cIiAmJiB2YWwgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbGwgdGhlIGJhc2UgdHlwZSBjb25zdHJ1Y3RvclxyXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcm9vdFR5cGUsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gZ2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bGVcclxuICAgIFJlcXVpcmVkUnVsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuY29udGFpbmluZ1R5cGUuZnVsbE5hbWUgKyBcIi5cIiArIHRoaXMucHJvcGVydHkubmFtZSArIFwiIGlzIHJlcXVpcmVkXCI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlcXVpcmVkUnVsZTtcclxufSh2YWxpZGF0aW9uX3J1bGVfMS5WYWxpZGF0aW9uUnVsZSkpO1xyXG5leHBvcnRzLlJlcXVpcmVkUnVsZSA9IFJlcXVpcmVkUnVsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9yZXNvdXJjZVwiKTtcclxucmVzb3VyY2VfMS5kZWZpbmVSZXNvdXJjZXMoXCJlblwiLCB7XHJcbiAgICBcImFsbG93ZWQtdmFsdWVzXCI6IFwie3Byb3BlcnR5fSBpcyBub3QgaW4gdGhlIGxpc3Qgb2YgYWxsb3dlZCB2YWx1ZXMuXCIsXHJcbiAgICBcImxpc3RsZW5ndGgtYXQtbGVhc3RcIjogXCJQbGVhc2Ugc3BlY2lmeSBhdCBsZWFzdCB7bWlufSB7cHJvcGVydHl9LlwiLFxyXG4gICAgXCJsaXN0bGVuZ3RoLWF0LW1vc3RcIjogXCJQbGVhc2Ugc3BlY2lmeSBubyBtb3JlIHRoYW4ge21heH0ge3Byb3BlcnR5fS5cIixcclxuICAgIFwibGlzdGxlbmd0aC1iZXR3ZWVuXCI6IFwiUGxlYXNlIHNwZWNpZnkgYmV0d2VlbiB7bWlufSBhbmQge21heH0ge3Byb3BlcnR5fS5cIixcclxuICAgIFwicmFuZ2UtYXQtbGVhc3RcIjogXCJ7cHJvcGVydHl9IG11c3QgYmUgYXQgbGVhc3Qge21pbn0uXCIsXHJcbiAgICBcInJhbmdlLWF0LW1vc3RcIjogXCJ7cHJvcGVydHl9IG11c3QgYmUgYXQgbW9zdCB7bWF4fS5cIixcclxuICAgIFwicmFuZ2UtYmV0d2VlblwiOiBcIntwcm9wZXJ0eX0gbXVzdCBiZSBiZXR3ZWVuIHttaW59IGFuZCB7bWF4fS5cIixcclxuICAgIFwicmFuZ2Utb24tb3ItYWZ0ZXJcIjogXCJ7cHJvcGVydHl9IG11c3QgYmUgb24gb3IgYWZ0ZXIge21pbn0uXCIsXHJcbiAgICBcInJhbmdlLW9uLW9yLWJlZm9yZVwiOiBcIntwcm9wZXJ0eX0gbXVzdCBiZSBvbiBvciBiZWZvcmUge21heH0uXCIsXHJcbiAgICBcInJlcXVpcmVkXCI6IFwie3Byb3BlcnR5fSBpcyByZXF1aXJlZC5cIixcclxuICAgIFwic3RyaW5nLWZvcm1hdFwiOiBcIntwcm9wZXJ0eX0gbXVzdCBiZSBmb3JtYXR0ZWQgYXMge2Zvcm1hdERlc2NyaXB0aW9ufS5cIixcclxuICAgIFwic3RyaW5nLWxlbmd0aC1hdC1sZWFzdFwiOiBcIntwcm9wZXJ0eX0gbXVzdCBiZSBhdCBsZWFzdCB7bWlufSBjaGFyYWN0ZXJzLlwiLFxyXG4gICAgXCJzdHJpbmctbGVuZ3RoLWF0LW1vc3RcIjogXCJ7cHJvcGVydHl9IG11c3QgYmUgYXQgbW9zdCB7bWF4fSBjaGFyYWN0ZXJzLlwiLFxyXG4gICAgXCJzdHJpbmctbGVuZ3RoLWJldHdlZW5cIjogXCJ7cHJvcGVydHl9IG11c3QgYmUgYmV0d2VlbiB7bWlufSBhbmQge21heH0gY2hhcmFjdGVycy5cIixcclxuICAgIFwiZm9ybWF0LXdpdGgtZGVzY3JpcHRpb25cIjogXCJ7cHJvcGVydHl9IG11c3QgYmUgZm9ybWF0dGVkIGFzIHtkZXNjcmlwdGlvbn0uXCIsXHJcbiAgICBcImZvcm1hdC13aXRob3V0LWRlc2NyaXB0aW9uXCI6IFwie3Byb3BlcnR5fSBpcyBub3QgcHJvcGVybHkgZm9ybWF0dGVkLlwiLFxyXG4gICAgXCJmb3JtYXQtY3VycmVuY3lcIjogXCIkIywjIyMuIyNcIixcclxuICAgIFwiZm9ybWF0LXBlcmNlbnRhZ2VcIjogXCIjLiMjJVwiLFxyXG4gICAgXCJmb3JtYXQtaW50ZWdlclwiOiBcIiMsIyMjXCIsXHJcbiAgICBcImZvcm1hdC1kZWNpbWFsXCI6IFwiIywjIyMuIyNcIlxyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5yZXNvdXJjZUV4aXN0cyA9IGV4cG9ydHMuZ2V0UmVzb3VyY2UgPSBleHBvcnRzLmRlZmluZVJlc291cmNlcyA9IGV4cG9ydHMuc2V0RGVmYXVsdExvY2FsZSA9IGV4cG9ydHMuUmVzb3VyY2VzID0gdm9pZCAwO1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxuLyoqXHJcbiAqIFRoZSBkaWN0aW9uYXJ5IG9mIGxvY2FsaXplZCByZXNvdXJjZSBtZXNzYWdlc1xyXG4gKi9cclxuZXhwb3J0cy5SZXNvdXJjZXMgPSB7fTtcclxuZnVuY3Rpb24gbWFwQ29udGFpbnNSZXNvdXJjZShyZXNvdXJjZXMsIGxvY2FsZSwgbmFtZSkge1xyXG4gICAgcmV0dXJuIGhlbHBlcnNfMS5oYXNPd25Qcm9wZXJ0eShyZXNvdXJjZXMsIGxvY2FsZSkgJiYgaGVscGVyc18xLmhhc093blByb3BlcnR5KHJlc291cmNlc1tsb2NhbGVdLCBuYW1lKTtcclxufVxyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbG9jYWxlLCBjYW4gYmUgY2hhbmdlZCB2aWEgYHNldERlZmF1bHRMb2NhbGUobG9jYWxlKWAuXHJcbiAqL1xyXG52YXIgZGVmYXVsdExvY2FsZSA9IG51bGw7XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBkZWZhdWx0IGxvY2FsZVxyXG4gKiBAcGFyYW0gbG9jYWxlIFRoZSBkZWZhdWx0IGxvY2FsZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0RGVmYXVsdExvY2FsZShsb2NhbGUpIHtcclxuICAgIGRlZmF1bHRMb2NhbGUgPSBsb2NhbGU7XHJcbn1cclxuZXhwb3J0cy5zZXREZWZhdWx0TG9jYWxlID0gc2V0RGVmYXVsdExvY2FsZTtcclxuLyoqXHJcbiAqIEdsb2JhbGx5IGRlZmluZWQgcmVzb3VyY2VzXHJcbiAqL1xyXG52YXIgZ2xvYmFsUmVzb3VyY2VzID0ge307XHJcbi8qKlxyXG4gKiBHbG9iYWxseSBkZWZpbmUgbG9jYWxpemVkIHJlc291cmNlIG1lc3NhZ2VzIGZvciB0aGUgZ2l2ZW4gbG9jYWxlXHJcbiAqIEBwYXJhbSBsb2NhbGUgVGhlIGxvY2FsZSB0byBzZXQgbWVzc2FnZXMgZm9yXHJcbiAqIEBwYXJhbSByZXNvdXJjZXMgVGhlIHJlc291cmNlcyBtZXNzYWdlc1xyXG4gKi9cclxuZnVuY3Rpb24gZGVmaW5lUmVzb3VyY2VzKGxvY2FsZSwgcmVzb3VyY2VzKSB7XHJcbiAgICBnbG9iYWxSZXNvdXJjZXNbbG9jYWxlXSA9IGhlbHBlcnNfMS5oYXNPd25Qcm9wZXJ0eShnbG9iYWxSZXNvdXJjZXMsIGxvY2FsZSkgPyBoZWxwZXJzXzEubWVyZ2UoZ2xvYmFsUmVzb3VyY2VzW2xvY2FsZV0sIHJlc291cmNlcykgOiByZXNvdXJjZXM7XHJcbn1cclxuZXhwb3J0cy5kZWZpbmVSZXNvdXJjZXMgPSBkZWZpbmVSZXNvdXJjZXM7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcclxuZnVuY3Rpb24gZ2V0UmVzb3VyY2UobmFtZSwgYXJnMiwgYXJnMykge1xyXG4gICAgdmFyIGN1c3RvbVJlc291cmNlcztcclxuICAgIHZhciBsb2NhbGU7XHJcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBjdXN0b21SZXNvdXJjZXMgPSBhcmcyO1xyXG4gICAgICAgICAgICBsb2NhbGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICBjdXN0b21SZXNvdXJjZXMgPSBudWxsO1xyXG4gICAgICAgICAgICBsb2NhbGUgPSBhcmcyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykge1xyXG4gICAgICAgIGN1c3RvbVJlc291cmNlcyA9IGFyZzI7XHJcbiAgICAgICAgbG9jYWxlID0gYXJnMztcclxuICAgIH1cclxuICAgIGlmICghbG9jYWxlKVxyXG4gICAgICAgIGxvY2FsZSA9IGRlZmF1bHRMb2NhbGUgfHwgXCJlblwiO1xyXG4gICAgdmFyIHJlcztcclxuICAgIGlmIChjdXN0b21SZXNvdXJjZXMgJiYgbWFwQ29udGFpbnNSZXNvdXJjZShjdXN0b21SZXNvdXJjZXMsIGxvY2FsZSwgbmFtZSkpXHJcbiAgICAgICAgcmVzID0gY3VzdG9tUmVzb3VyY2VzW2xvY2FsZV1bbmFtZV07XHJcbiAgICBlbHNlIGlmIChtYXBDb250YWluc1Jlc291cmNlKGdsb2JhbFJlc291cmNlcywgbG9jYWxlLCBuYW1lKSlcclxuICAgICAgICByZXMgPSBnbG9iYWxSZXNvdXJjZXNbbG9jYWxlXVtuYW1lXTtcclxuICAgIGVsc2VcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNvdXJjZSAnXCIgKyBuYW1lICsgXCInIGlzIG5vdCBkZWZpbmVkIGZvciBsb2NhbGUgJ1wiICsgbG9jYWxlICsgXCInLlwiKTtcclxuICAgIHJldHVybiByZXM7XHJcbn1cclxuZXhwb3J0cy5nZXRSZXNvdXJjZSA9IGdldFJlc291cmNlO1xyXG5mdW5jdGlvbiByZXNvdXJjZUV4aXN0cyhuYW1lLCBjdXN0b21SZXNvdXJjZXMsIGxvY2FsZSkge1xyXG4gICAgaWYgKCFsb2NhbGUpXHJcbiAgICAgICAgbG9jYWxlID0gZGVmYXVsdExvY2FsZSB8fCBcImVuXCI7XHJcbiAgICByZXR1cm4gbWFwQ29udGFpbnNSZXNvdXJjZShnbG9iYWxSZXNvdXJjZXMsIGxvY2FsZSwgbmFtZSkgfHwgKGN1c3RvbVJlc291cmNlcyAmJiBtYXBDb250YWluc1Jlc291cmNlKGN1c3RvbVJlc291cmNlcywgbG9jYWxlLCBuYW1lKSk7XHJcbn1cclxuZXhwb3J0cy5yZXNvdXJjZUV4aXN0cyA9IHJlc291cmNlRXhpc3RzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlJ1bGVJbnZvY2F0aW9uVHlwZSA9IHZvaWQgMDtcclxudmFyIFJ1bGVJbnZvY2F0aW9uVHlwZTtcclxuKGZ1bmN0aW9uIChSdWxlSW52b2NhdGlvblR5cGUpIHtcclxuICAgIC8qKiBPY2N1cnMgd2hlbiBhbiBleGlzdGluZyBpbnN0YW5jZSBpcyBpbml0aWFsaXplZC4gKi9cclxuICAgIFJ1bGVJbnZvY2F0aW9uVHlwZVtSdWxlSW52b2NhdGlvblR5cGVbXCJJbml0RXhpc3RpbmdcIl0gPSAyXSA9IFwiSW5pdEV4aXN0aW5nXCI7XHJcbiAgICAvKiogT2NjdXJzIHdoZW4gYSBuZXcgaW5zdGFuY2UgaXMgaW5pdGlhbGl6ZWQuICovXHJcbiAgICBSdWxlSW52b2NhdGlvblR5cGVbUnVsZUludm9jYXRpb25UeXBlW1wiSW5pdE5ld1wiXSA9IDRdID0gXCJJbml0TmV3XCI7XHJcbiAgICAvKiogT2NjdXJzIHdoZW4gYSBwcm9wZXJ0eSB2YWx1ZSBpcyByZXRyaWV2ZWQuICovXHJcbiAgICBSdWxlSW52b2NhdGlvblR5cGVbUnVsZUludm9jYXRpb25UeXBlW1wiUHJvcGVydHlHZXRcIl0gPSA4XSA9IFwiUHJvcGVydHlHZXRcIjtcclxuICAgIC8qKiBPY2N1cnMgd2hlbiBhIHByb3BlcnR5IHZhbHVlIGlzIGNoYW5nZWQuICovXHJcbiAgICBSdWxlSW52b2NhdGlvblR5cGVbUnVsZUludm9jYXRpb25UeXBlW1wiUHJvcGVydHlDaGFuZ2VkXCJdID0gMTZdID0gXCJQcm9wZXJ0eUNoYW5nZWRcIjtcclxufSkoUnVsZUludm9jYXRpb25UeXBlID0gZXhwb3J0cy5SdWxlSW52b2NhdGlvblR5cGUgfHwgKGV4cG9ydHMuUnVsZUludm9jYXRpb25UeXBlID0ge30pKTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5SdWxlJGVuc3VyZUNvbmRpdGlvblR5cGUgPSBleHBvcnRzLlJ1bGUgPSB2b2lkIDA7XHJcbnZhciBwcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4vcHJvcGVydHlcIik7XHJcbnZhciB0eXBlXzEgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xyXG52YXIgcnVsZV9pbnZvY2F0aW9uX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3J1bGUtaW52b2NhdGlvbi10eXBlXCIpO1xyXG52YXIgY29uZGl0aW9uX3R5cGVfMSA9IHJlcXVpcmUoXCIuL2NvbmRpdGlvbi10eXBlXCIpO1xyXG52YXIgUnVsZSRjdXN0b21SdWxlSW5kZXggPSAwO1xyXG52YXIgUnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIHJ1bGUgdGhhdCBleGVjdXRlcyBhIGRlbGVnYXRlIHdoZW4gc3BlY2lmaWVkIG1vZGVsIGV2ZW50cyBvY2N1ci5cclxuICAgICAqIEBwYXJhbSByb290VHlwZSBUaGUgbW9kZWwgdHlwZSB0aGUgcnVsZSBpcyBmb3IuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHJ1bGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJ1bGUocm9vdFR5cGUsIG5hbWUsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmludm9jYXRpb25UeXBlcyA9IDA7XHJcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVzID0gW107XHJcbiAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZXMgPSBbXTtcclxuICAgICAgICAvLyBUcmFjayB0aGUgcm9vdCB0eXBlXHJcbiAgICAgICAgdGhpcy5yb290VHlwZSA9IHJvb3RUeXBlO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgKG9wdGlvbnMgPyBvcHRpb25zLm5hbWUgOiBudWxsKSB8fCAocm9vdFR5cGUuZnVsbE5hbWUgKyBcIi5DdXN0b20uXCIgKyAoKytSdWxlJGN1c3RvbVJ1bGVJbmRleCkpO1xyXG4gICAgICAgIC8vIENvbmZpZ3VyZSB0aGUgcnVsZSBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIG9wdGlvbnNcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbkluaXQpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5pdCgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbkluaXROZXcpXHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uSW5pdE5ldygpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbkluaXRFeGlzdGluZylcclxuICAgICAgICAgICAgICAgIHRoaXMub25Jbml0RXhpc3RpbmcoKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMub25DaGFuZ2VPZilcclxuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VPZihvcHRpb25zLm9uQ2hhbmdlT2YpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXR1cm5zKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5zKG9wdGlvbnMucmV0dXJucyk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmV4ZWN1dGUgaW5zdGFuY2VvZiBGdW5jdGlvbilcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V4ZWN1dGUgPSBvcHRpb25zLmV4ZWN1dGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bGUucHJvdG90eXBlLCBcIm1vZGVsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdFR5cGUubW9kZWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bGUucHJvdG90eXBlLCBcImV2ZW50U2NvcGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290VHlwZS5tb2RlbC5ldmVudFNjb3BlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFJ1bGUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V4ZWN1dGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZS5jYWxsKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBXYXJuIGFib3V0IGV4ZWN1dGUgZnVuY3Rpb24gbm90IGltcGxlbWVudGVkP1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBJbmRpY2F0ZXMgdGhhdCB0aGUgcnVsZSBzaG91bGQgcnVuIG9ubHkgZm9yIG5ldyBpbnN0YW5jZXMgd2hlbiBpbml0aWFsaXplZFxyXG4gICAgUnVsZS5wcm90b3R5cGUub25Jbml0TmV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcnVsZSBoYXMgbm90IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWQpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bGVzIGNhbm5vdCBiZSBjb25maWd1cmVkIG9uY2UgdGhleSBoYXZlIGJlZW4gcmVnaXN0ZXJlZDogXCIgKyB0aGlzLm5hbWUpO1xyXG4gICAgICAgIC8vIGNvbmZpZ3VyZSB0aGUgcnVsZSB0byBydW4gb24gaW5pdCBuZXdcclxuICAgICAgICB0aGlzLmludm9jYXRpb25UeXBlcyB8PSBydWxlX2ludm9jYXRpb25fdHlwZV8xLlJ1bGVJbnZvY2F0aW9uVHlwZS5Jbml0TmV3O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8vIGluZGljYXRlcyB0aGF0IHRoZSBydWxlIHNob3VsZCBydW4gb25seSBmb3IgZXhpc3RpbmcgaW5zdGFuY2VzIHdoZW4gaW5pdGlhbGl6ZWRcclxuICAgIFJ1bGUucHJvdG90eXBlLm9uSW5pdEV4aXN0aW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcnVsZSBoYXMgbm90IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWQpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bGVzIGNhbm5vdCBiZSBjb25maWd1cmVkIG9uY2UgdGhleSBoYXZlIGJlZW4gcmVnaXN0ZXJlZDogXCIgKyB0aGlzLm5hbWUpO1xyXG4gICAgICAgIC8vIGNvbmZpZ3VyZSB0aGUgcnVsZSB0byBydW4gb24gaW5pdCBleGlzdGluZ2hcclxuICAgICAgICB0aGlzLmludm9jYXRpb25UeXBlcyB8PSBydWxlX2ludm9jYXRpb25fdHlwZV8xLlJ1bGVJbnZvY2F0aW9uVHlwZS5Jbml0RXhpc3Rpbmc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLy8gaW5kaWNhdGVzIHRoYXQgdGhlIHJ1bGUgc2hvdWxkIHJ1biBmb3IgYm90aCBuZXcgYW5kIGV4aXN0aW5nIGluc3RhbmNlcyB3aGVuIGluaXRpYWxpemVkXHJcbiAgICBSdWxlLnByb3RvdHlwZS5vbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZW5zdXJlIHRoZSBydWxlIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlZ2lzdGVyZWRcclxuICAgICAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVsZXMgY2Fubm90IGJlIGNvbmZpZ3VyZWQgb25jZSB0aGV5IGhhdmUgYmVlbiByZWdpc3RlcmVkOiBcIiArIHRoaXMubmFtZSk7XHJcbiAgICAgICAgLy8gY29uZmlndXJlIHRoZSBydWxlIHRvIHJ1biBvbiBib3RoIGluaXQgbmV3IGFuZCBpbml0IGV4aXN0aW5nXHJcbiAgICAgICAgdGhpcy5pbnZvY2F0aW9uVHlwZXMgfD0gcnVsZV9pbnZvY2F0aW9uX3R5cGVfMS5SdWxlSW52b2NhdGlvblR5cGUuSW5pdE5ldyB8IHJ1bGVfaW52b2NhdGlvbl90eXBlXzEuUnVsZUludm9jYXRpb25UeXBlLkluaXRFeGlzdGluZztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBSdWxlLnByb3RvdHlwZS5vbkNoYW5nZU9mID0gZnVuY3Rpb24gKHByZWRpY2F0ZXMpIHtcclxuICAgICAgICAvLyBlbnN1cmUgdGhlIHJ1bGUgaGFzIG5vdCBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZFxyXG4gICAgICAgIGlmICh0aGlzLl9yZWdpc3RlcmVkKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSdWxlcyBjYW5ub3QgYmUgY29uZmlndXJlZCBvbmNlIHRoZXkgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQ6IFwiICsgdGhpcy5uYW1lKTtcclxuICAgICAgICAvLyBhbGxvdyBjaGFuZ2Ugb2YgcHJlZGljYXRlcyB0byBiZSBzcGVjaWZpZWQgYXMgYSBwYXJhbWV0ZXIgYXJyYXkgd2l0aG91dCBbXSdzXHJcbiAgICAgICAgaWYgKCEocHJlZGljYXRlcyBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgICAgICBwcmVkaWNhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRkIHRvIHRoZSBzZXQgb2YgZXhpc3RpbmcgY2hhbmdlIHByZWRpY2F0ZXNcclxuICAgICAgICB0aGlzLnByZWRpY2F0ZXMgPSB0aGlzLnByZWRpY2F0ZXMubGVuZ3RoID4gMCA/IHRoaXMucHJlZGljYXRlcy5jb25jYXQocHJlZGljYXRlcykgOiBwcmVkaWNhdGVzO1xyXG4gICAgICAgIC8vIGFsc28gY29uZmlndXJlIHRoZSBydWxlIHRvIHJ1biBvbiBwcm9wZXJ0eSBjaGFuZ2UgdW5sZXNzIGl0IGhhcyBhbHJlYWR5IGJlZW4gY29uZmlndXJlZCB0byBydW4gb24gcHJvcGVydHkgZ2V0XHJcbiAgICAgICAgaWYgKCh0aGlzLmludm9jYXRpb25UeXBlcyAmIHJ1bGVfaW52b2NhdGlvbl90eXBlXzEuUnVsZUludm9jYXRpb25UeXBlLlByb3BlcnR5R2V0KSA9PT0gMClcclxuICAgICAgICAgICAgdGhpcy5pbnZvY2F0aW9uVHlwZXMgfD0gcnVsZV9pbnZvY2F0aW9uX3R5cGVfMS5SdWxlSW52b2NhdGlvblR5cGUuUHJvcGVydHlDaGFuZ2VkO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFJ1bGUucHJvdG90eXBlLnJldHVybnMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xyXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgcnVsZSBoYXMgbm90IGFscmVhZHkgYmVlbiByZWdpc3RlcmVkXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlZ2lzdGVyZWQpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bGVzIGNhbm5vdCBiZSBjb25maWd1cmVkIG9uY2UgdGhleSBoYXZlIGJlZW4gcmVnaXN0ZXJlZDogXCIgKyB0aGlzLm5hbWUpO1xyXG4gICAgICAgIC8vIEFsbG93IHJldHVybiBwcm9wZXJ0aWVzIHRvIGJlIHNwZWNpZmllZCBhcyBhIHBhcmFtZXRlciBhcnJheSB3aXRob3V0IFtdJ3NcclxuICAgICAgICBpZiAocHJvcGVydGllcyAmJiBwcm9wZXJ0aWVzLmNvbnN0cnVjdG9yID09PSBTdHJpbmcpXHJcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICghcHJvcGVydGllcylcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUnVsZSBtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIHByb3BlcnR5IGZvciByZXR1cm5zLlwiKTtcclxuICAgICAgICAvLyBBZGQgdG8gdGhlIHNldCBvZiBleGlzdGluZyByZXR1cm4gdmFsdWUgcHJvcGVydGllc1xyXG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWVzID0gdGhpcy5yZXR1cm5WYWx1ZXMubGVuZ3RoID4gMCA/IHRoaXMucmV0dXJuVmFsdWVzLmNvbmNhdChwcm9wZXJ0aWVzKSA6IHByb3BlcnRpZXM7XHJcbiAgICAgICAgLy8gQ29uZmlndXJlIHRoZSBydWxlIHRvIHJ1biBvbiBwcm9wZXJ0eSBnZXQgYW5kIG5vdCBvbiBwcm9wZXJ0eSBjaGFuZ2VcclxuICAgICAgICB0aGlzLmludm9jYXRpb25UeXBlcyB8PSBydWxlX2ludm9jYXRpb25fdHlwZV8xLlJ1bGVJbnZvY2F0aW9uVHlwZS5Qcm9wZXJ0eUdldDtcclxuICAgICAgICB0aGlzLmludm9jYXRpb25UeXBlcyAmPSB+cnVsZV9pbnZvY2F0aW9uX3R5cGVfMS5SdWxlSW52b2NhdGlvblR5cGUuUHJvcGVydHlDaGFuZ2VkO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8vIHJlZ2lzdGVycyB0aGUgcnVsZSBiYXNlZCBvbiB0aGUgY29uZmlndXJlZCBpbnZvY2F0aW9uIHR5cGVzLCBwcmVkaWNhdGVzLCBhbmQgcmV0dXJuIHZhbHVlc1xyXG4gICAgUnVsZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzO1xyXG4gICAgICAgIGlmIChydWxlLl9yZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJ1bGVzIGNhbm5vdCBiZSByZWdpc3RlcmVkIG1vcmUgdGhhbiBvbmNlOiBcIiArIHJ1bGUubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluZGljYXRlIHRoYXQgdGhlIHJ1bGUgc2hvdWxkIG5vdyBiZSBjb25zaWRlcmVkIHJlZ2lzdGVyZWQgYW5kIGNhbm5vdCBiZSByZWNvbmZpZ3VyZWRcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcmVnaXN0ZXJlZFwiLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogdHJ1ZSwgd3JpdGFibGU6IGZhbHNlIH0pO1xyXG4gICAgICAgIC8vIHJlZ2lzdGVyIGZvciBpbml0IG5ld1xyXG4gICAgICAgIGlmIChydWxlLmludm9jYXRpb25UeXBlcyAmIHJ1bGVfaW52b2NhdGlvbl90eXBlXzEuUnVsZUludm9jYXRpb25UeXBlLkluaXROZXcpIHtcclxuICAgICAgICAgICAgcnVsZS5yb290VHlwZS5pbml0TmV3LnN1YnNjcmliZShmdW5jdGlvbiAoYXJncykgeyBleGVjdXRlUnVsZShydWxlLCBhcmdzLmVudGl0eSk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZWdpc3RlciBmb3IgaW5pdCBleGlzdGluZ1xyXG4gICAgICAgIGlmIChydWxlLmludm9jYXRpb25UeXBlcyAmIHJ1bGVfaW52b2NhdGlvbl90eXBlXzEuUnVsZUludm9jYXRpb25UeXBlLkluaXRFeGlzdGluZykge1xyXG4gICAgICAgICAgICBydWxlLnJvb3RUeXBlLmluaXRFeGlzdGluZy5zdWJzY3JpYmUoZnVuY3Rpb24gKGFyZ3MpIHsgZXhlY3V0ZVJ1bGUocnVsZSwgYXJncy5lbnRpdHkpOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVnaXN0ZXIgZm9yIHByb3BlcnR5IGNoYW5nZVxyXG4gICAgICAgIGlmIChydWxlLmludm9jYXRpb25UeXBlcyAmIHJ1bGVfaW52b2NhdGlvbl90eXBlXzEuUnVsZUludm9jYXRpb25UeXBlLlByb3BlcnR5Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICBydWxlLnByZWRpY2F0ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZGljYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVkaWNhdGUuY2hhbmdlZC5zdWJzY3JpYmUoZnVuY3Rpb24gKGFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuRXhlY3V0ZVJ1bGUocnVsZSwgYXJncy5lbnRpdHkpICYmICFwZW5kaW5nSW52b2NhdGlvbihhcmdzLmVudGl0eS5tZXRhLCBydWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nSW52b2NhdGlvbihhcmdzLmVudGl0eS5tZXRhLCBydWxlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5ldmVudFNjb3BlLm9uRXhpdChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0ludm9jYXRpb24oYXJncy5lbnRpdHkubWV0YSwgcnVsZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLmFib3J0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVSdWxlKHJ1bGUsIGFyZ3MuZW50aXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZWdpc3RlciBmb3IgcHJvcGVydHkgZ2V0XHJcbiAgICAgICAgaWYgKHJ1bGUuaW52b2NhdGlvblR5cGVzICYgcnVsZV9pbnZvY2F0aW9uX3R5cGVfMS5SdWxlSW52b2NhdGlvblR5cGUuUHJvcGVydHlHZXQgJiYgcnVsZS5yZXR1cm5WYWx1ZXMpIHtcclxuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgZm9yIHByb3BlcnR5IGdldCBldmVudHMgZm9yIGVhY2ggcmV0dXJuIHZhbHVlIHRvIGNhbGN1bGF0ZSB0aGUgcHJvcGVydHkgd2hlbiBhY2Nlc3NlZFxyXG4gICAgICAgICAgICBydWxlLnJldHVyblZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXR1cm5WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUuYWNjZXNzZWQuc3Vic2NyaWJlKGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcnVuIHRoZSBydWxlIHRvIGluaXRpYWxpemUgdGhlIHByb3BlcnR5IGlmIGl0IGlzIHBlbmRpbmcgaW5pdGlhbGl6YXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuRXhlY3V0ZVJ1bGUocnVsZSwgYXJncy5lbnRpdHkpICYmIHByb3BlcnR5XzEuUHJvcGVydHkkcGVuZGluZ0luaXQoYXJncy5lbnRpdHksIHJldHVyblZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eV8xLlByb3BlcnR5JHBlbmRpbmdJbml0KGFyZ3MuZW50aXR5LCByZXR1cm5WYWx1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlUnVsZShydWxlLCBhcmdzLmVudGl0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyByZWdpc3RlciBmb3IgcHJvcGVydHkgY2hhbmdlIGV2ZW50cyBmb3IgZWFjaCBwcmVkaWNhdGUgdG8gaW52YWxpZGF0ZSB0aGUgcHJvcGVydHkgdmFsdWUgd2hlbiBpbnB1dHMgY2hhbmdlXHJcbiAgICAgICAgICAgIHJ1bGUucHJlZGljYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcclxuICAgICAgICAgICAgICAgIHByZWRpY2F0ZS5jaGFuZ2VkLnN1YnNjcmliZShmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChydWxlLnJldHVyblZhbHVlcy5zb21lKGZ1bmN0aW9uIChyZXR1cm5WYWx1ZSkgeyByZXR1cm4gcmV0dXJuVmFsdWUuY2hhbmdlZC5oYXNTdWJzY3JpYmVycygpOyB9KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbW1lZGlhdGVseSBleGVjdXRlIHRoZSBydWxlIGlmIHRoZXJlIGFyZSBleHBsaWNpdCBldmVudCBzdWJzY3JpcHRpb25zIGZvciB0aGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkV4ZWN1dGVSdWxlKHJ1bGUsIGFyZ3MuZW50aXR5KSAmJiAhcGVuZGluZ0ludm9jYXRpb24oYXJncy5lbnRpdHkubWV0YSwgcnVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdJbnZvY2F0aW9uKGFyZ3MuZW50aXR5Lm1ldGEsIHJ1bGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5ldmVudFNjb3BlLm9uRXhpdChmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdJbnZvY2F0aW9uKGFyZ3MuZW50aXR5Lm1ldGEsIHJ1bGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUuYWJvcnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVSdWxlKHJ1bGUsIGFyZ3MuZW50aXR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGp1c3QgbWFyayB0aGUgcHJvcGVydHkgYXMgcGVuZGluZyBpbml0aWFsaXphdGlvbiBhbmQgcmFpc2UgcHJvcGVydHkgY2hhbmdlIGZvciBVSSBzdWJzY3JpYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLnJldHVyblZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXR1cm5WYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHlfMS5Qcm9wZXJ0eSRwZW5kaW5nSW5pdChhcmdzLmVudGl0eSwgcmV0dXJuVmFsdWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmZXIgY2hhbmdlIG5vdGlmaWNhdGlvbiB1bnRpbCB0aGUgc2NvcGUgb2Ygd29yayBoYXMgY29tcGxldGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUuZXZlbnRTY29wZS5vbkV4aXQoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZS5hYm9ydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUucmV0dXJuVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHJldHVyblZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuZW50aXR5LmNoYW5nZWQucHVibGlzaChhcmdzLmVudGl0eSwgeyBlbnRpdHk6IGFyZ3MuZW50aXR5LCBwcm9wZXJ0eTogcmV0dXJuVmFsdWUsIG5ld1ZhbHVlOiByZXR1cm5WYWx1ZS52YWx1ZShhcmdzLmVudGl0eSkgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJ1bGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUnVsZSA9IFJ1bGU7XHJcbmZ1bmN0aW9uIHBlbmRpbmdJbnZvY2F0aW9uKHRhcmdldCwgcnVsZSwgdmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gbnVsbDsgfVxyXG4gICAgdmFyIHBlbmRpbmdJbnZvY2F0aW9uO1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIFwiX19wZW5kaW5nSW52b2NhdGlvbl9fXCIpKSB7XHJcbiAgICAgICAgcGVuZGluZ0ludm9jYXRpb24gPSB0YXJnZXQuX19wZW5kaW5nSW52b2NhdGlvbl9fO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgXCJfX3BlbmRpbmdJbnZvY2F0aW9uX19cIiwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IChwZW5kaW5nSW52b2NhdGlvbiA9IFtdKSwgd3JpdGFibGU6IHRydWUgfSk7XHJcbiAgICB9XHJcbiAgICB2YXIgaW5kZXhPZlJ1bGUgPSBwZW5kaW5nSW52b2NhdGlvbi5pbmRleE9mKHJ1bGUpO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICYmIGluZGV4T2ZSdWxlIDwgMCkge1xyXG4gICAgICAgICAgICBwZW5kaW5nSW52b2NhdGlvbi5wdXNoKHJ1bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgaW5kZXhPZlJ1bGUgPj0gMCkge1xyXG4gICAgICAgICAgICBwZW5kaW5nSW52b2NhdGlvbi5zcGxpY2UoaW5kZXhPZlJ1bGUsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBpbmRleE9mUnVsZSA+PSAwO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGNhbkV4ZWN1dGVSdWxlKHJ1bGUsIG9iaikge1xyXG4gICAgLy8gZW5zdXJlIHRoZSBydWxlIHRhcmdldCBpcyBhIHZhbGlkIHJ1bGUgcm9vdCB0eXBlXHJcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgcnVsZS5yb290VHlwZS5qc3R5cGU7XHJcbn1cclxuZnVuY3Rpb24gZXhlY3V0ZVJ1bGUocnVsZSwgb2JqKSB7XHJcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcnVsZSBjYW4gYmUgZXhlY3V0ZWQuXHJcbiAgICBpZiAoIWNhbkV4ZWN1dGVSdWxlKHJ1bGUsIG9iaikpIHtcclxuICAgICAgICAvLyBUT0RPOiBXYXJuIHRoYXQgcnVsZSBjYW4ndCBiZSBleGVjdXRlZD9cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJ1bGUuZXZlbnRTY29wZS5wZXJmb3JtKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcnVsZS5leGVjdXRlKG9iaik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcIkVycm9yIGVuY291bnRlcmVkIHdoaWxlIHJ1bm5pbmcgcnVsZSBcXFwiXCIgKyBydWxlLm5hbWUgKyBcIlxcXCIuXCIpO1xyXG4gICAgICAgIGlmIChlKVxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XHJcbiAgICB9XHJcbn1cclxuO1xyXG5mdW5jdGlvbiBSdWxlJGVuc3VyZUNvbmRpdGlvblR5cGUocnVsZU5hbWUsIHR5cGVPclByb3AsIGNhdGVnb3J5KSB7XHJcbiAgICB2YXIgZ2VuZXJhdGVkQ29kZSA9IHR5cGVPclByb3AgaW5zdGFuY2VvZiBwcm9wZXJ0eV8xLlByb3BlcnR5ID8gdHlwZU9yUHJvcC5jb250YWluaW5nVHlwZS5mdWxsTmFtZSArIFwiLlwiICsgdHlwZU9yUHJvcC5uYW1lICsgXCIuXCIgKyBydWxlTmFtZSA6XHJcbiAgICAgICAgdHlwZU9yUHJvcCBpbnN0YW5jZW9mIHR5cGVfMS5UeXBlID8gdHlwZU9yUHJvcCArIFwiLlwiICsgcnVsZU5hbWUgOlxyXG4gICAgICAgICAgICBydWxlTmFtZTtcclxuICAgIHZhciBjb3VudGVyID0gXCJcIjtcclxuICAgIHdoaWxlIChjb25kaXRpb25fdHlwZV8xLkNvbmRpdGlvblR5cGUuZ2V0KGdlbmVyYXRlZENvZGUgKyBjb3VudGVyKSlcclxuICAgICAgICBjb3VudGVyID0gKHR5cGVvZiBjb3VudGVyID09PSBcInN0cmluZ1wiID8gMCA6IGNvdW50ZXIpICsgMTtcclxuICAgIHZhciBEZXNpcmVkQ29uZGl0aW9uVHlwZTtcclxuICAgIGlmIChjYXRlZ29yeSA9PT0gXCJFcnJvclwiKSB7XHJcbiAgICAgICAgRGVzaXJlZENvbmRpdGlvblR5cGUgPSBjb25kaXRpb25fdHlwZV8xLkVycm9yQ29uZGl0aW9uVHlwZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNhdGVnb3J5ID09PSBcIldhcm5pbmdcIikge1xyXG4gICAgICAgIERlc2lyZWRDb25kaXRpb25UeXBlID0gY29uZGl0aW9uX3R5cGVfMS5XYXJuaW5nQ29uZGl0aW9uVHlwZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgY29uZGl0aW9uIHR5cGUgZm9yIHVuc3VwcG9ydGVkIGNhdGVnb3J5ICdcIiArIGNhdGVnb3J5ICsgXCInLlwiKTtcclxuICAgIH1cclxuICAgIC8vIHJldHVybiBhIG5ldyBjbGllbnQgY29uZGl0aW9uIHR5cGUgb2YgdGhlIHNwZWNpZmllZCBjYXRlZ29yeVxyXG4gICAgcmV0dXJuIG5ldyBEZXNpcmVkQ29uZGl0aW9uVHlwZShnZW5lcmF0ZWRDb2RlICsgY291bnRlciwgXCJHZW5lcmF0ZWQgY29uZGl0aW9uIHR5cGUgZm9yIFwiICsgcnVsZU5hbWUgKyBcIiBydWxlLlwiKTtcclxufVxyXG5leHBvcnRzLlJ1bGUkZW5zdXJlQ29uZGl0aW9uVHlwZSA9IFJ1bGUkZW5zdXJlQ29uZGl0aW9uVHlwZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU3RyaW5nRm9ybWF0UnVsZSA9IHZvaWQgMDtcclxudmFyIHZhbGlkYXRpb25fcnVsZV8xID0gcmVxdWlyZShcIi4vdmFsaWRhdGlvbi1ydWxlXCIpO1xyXG52YXIgU3RyaW5nRm9ybWF0UnVsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTdHJpbmdGb3JtYXRSdWxlLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcnVsZSB0aGF0IHZhbGlkYXRlcyB0aGF0IGEgc3RyaW5nIHByb3BlcnR5IHZhbHVlIGlzIGNvcnJlY3RseSBmb3JtYXR0ZWQuXHJcbiAgICAgKiBAcGFyYW0gcm9vdFR5cGUgVGhlIG1vZGVsIHR5cGUgdGhlIHJ1bGUgaXMgZm9yLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBydWxlcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nRm9ybWF0UnVsZShyb290VHlwZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gZXhpdCBpbW1lZGlhdGVseSBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHNcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgLy8gZW5zdXJlIHRoZSBydWxlIG5hbWUgaXMgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBcIlN0cmluZ0Zvcm1hdFwiO1xyXG4gICAgICAgICAgICAvLyBzZWUgaWYgdGhlIGVycm9yIG1lc3NhZ2UgaXMgYSB2YWxpZCByZXNvdXJjZToge3Jlc291cmNlLW5hbWV9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tZXNzYWdlID09PSBcInN0cmluZ1wiICYmIHJvb3RUeXBlLm1vZGVsLnJlc291cmNlRXhpc3RzKG9wdGlvbnMubWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlXzEgPSBvcHRpb25zLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb290VHlwZS5tb2RlbC5nZXRSZXNvdXJjZShtZXNzYWdlXzEpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgZGVmYXVsdCB2YWxpZGF0aW9uIG1lc3NhZ2UgaWYgbm90IHNwZWNpZmllZFxyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMubWVzc2FnZSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm9vdFR5cGUubW9kZWwuZ2V0UmVzb3VyY2UoXCJzdHJpbmctZm9ybWF0XCIpLnJlcGxhY2UoXCJ7Zm9ybWF0RGVzY3JpcHRpb259XCIsIG9wdGlvbnMuZGVzY3JpcHRpb24pOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uXzEgPSBvcHRpb25zLmV4cHJlc3Npb24gaW5zdGFuY2VvZiBSZWdFeHAgPyBvcHRpb25zLmV4cHJlc3Npb24gOiBSZWdFeHAob3B0aW9ucy5leHByZXNzaW9uKTtcclxuICAgICAgICAgICAgdmFyIHJlZm9ybWF0XzEgPSBvcHRpb25zLnJlZm9ybWF0O1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHN0cmluZyBmb3JtYXQgdmFsaWRhdGlvbiBmdW5jdGlvblxyXG4gICAgICAgICAgICBvcHRpb25zLmlzVmFsaWQgPSBmdW5jdGlvbiAocHJvcCwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsICYmIHZhbCAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb25fMS5sYXN0SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBleHByZXNzaW9uXzEudGVzdCh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkICYmIG9wdGlvbnMucmVmb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlZm9ybWF0XzEgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcmVmb3JtYXRfMSh2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbl8xLmxhc3RJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShleHByZXNzaW9uXzEsIHJlZm9ybWF0XzEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AudmFsdWUodGhpcywgdmFsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FsbCB0aGUgYmFzZSB0eXBlIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290VHlwZSwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICAvLyBkZWZpbmUgcHJvcGVydGllcyBmb3IgdGhlIHJ1bGVcclxuICAgICAgICBfdGhpcy5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gZ2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bGVcclxuICAgIFN0cmluZ0Zvcm1hdFJ1bGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb3BlcnR5LmNvbnRhaW5pbmdUeXBlLmZ1bGxOYW1lICsgXCIuXCIgKyB0aGlzLnByb3BlcnR5Lm5hbWUgKyBcIiBmb3JtYXR0ZWQgYXMgXCIgKyB0aGlzLmRlc2NyaXB0aW9uO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHJpbmdGb3JtYXRSdWxlO1xyXG59KHZhbGlkYXRpb25fcnVsZV8xLlZhbGlkYXRpb25SdWxlKSk7XHJcbmV4cG9ydHMuU3RyaW5nRm9ybWF0UnVsZSA9IFN0cmluZ0Zvcm1hdFJ1bGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlN0cmluZ0xlbmd0aFJ1bGUgPSB2b2lkIDA7XHJcbnZhciB2YWxpZGF0aW9uX3J1bGVfMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb24tcnVsZVwiKTtcclxuLyoqXHJcbiAqIEEgcnVsZSB0aGF0IHZhbGlkYXRlcyB0aGF0IHZhbGlkYXRlcyB0aGF0IHRoZSBsZW5ndGggb2YgYSBzdHJpbmcgcHJvcGVydHkgaXMgd2l0aGluIGEgc3BlY2lmaWMgcmFuZ2VcclxuICovXHJcbnZhciBTdHJpbmdMZW5ndGhSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFN0cmluZ0xlbmd0aFJ1bGUsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBydWxlIHRoYXQgdmFsaWRhdGVzIHRoYXQgdGhlIGxlbmd0aCBvZiBhIHN0cmluZyBwcm9wZXJ0eSBpcyB3aXRoaW4gYSBzcGVjaWZpYyByYW5nZVxyXG4gICAgICogQHBhcmFtIHJvb3RUeXBlIFRoZSBtb2RlbCB0eXBlIHRoZSBydWxlIGlzIGZvclxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBydWxlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFN0cmluZ0xlbmd0aFJ1bGUocm9vdFR5cGUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcnVsZSBuYW1lIGlzIHNwZWNpZmllZFxyXG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBcIlN0cmluZ0xlbmd0aFwiO1xyXG4gICAgICAgIG9wdGlvbnMubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJhbmdlID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1pbiAmJiBvcHRpb25zLm1pbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1pbiA9IG9wdGlvbnMubWluLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbGVudGx5IGlnbm9yZSBtaW4gZXJyb3JzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF4ICYmIG9wdGlvbnMubWF4IGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubWF4ID0gb3B0aW9ucy5tYXguY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2lsZW50bHkgaWdub3JlIG1heCBlcnJvcnNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdmFsID0gb3B0aW9ucy5wcm9wZXJ0eS52YWx1ZSh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsIHx8IHR5cGVvZiB2YWwgIT09IFwic3RyaW5nXCIgfHwgdmFsLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChyYW5nZS5taW4gPT0gbnVsbCB8fCB2YWwubGVuZ3RoID49IHJhbmdlLm1pbikgJiYgKHJhbmdlLm1heCA9PSBudWxsIHx8IHZhbC5sZW5ndGggPD0gcmFuZ2UubWF4KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVmFsdWUgaXMgd2l0aGluIHJhbmdlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmFuZ2UubWluICE9IG51bGwgJiYgcmFuZ2UubWF4ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFR5cGUubW9kZWwuZ2V0UmVzb3VyY2UoXCJzdHJpbmctbGVuZ3RoLWJldHdlZW5cIikucmVwbGFjZShcInttaW59XCIsIHJhbmdlLm1pbi50b1N0cmluZygpKS5yZXBsYWNlKFwie21heH1cIiwgcmFuZ2UubWF4LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBpZiAocmFuZ2UubWluICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdFR5cGUubW9kZWwuZ2V0UmVzb3VyY2UoXCJzdHJpbmctbGVuZ3RoLWF0LWxlYXN0XCIpLnJlcGxhY2UoXCJ7bWlufVwiLCByYW5nZS5taW4udG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiByb290VHlwZS5tb2RlbC5nZXRSZXNvdXJjZShcInN0cmluZy1sZW5ndGgtYXQtbW9zdFwiKS5yZXBsYWNlKFwie21heH1cIiwgcmFuZ2UubWF4LnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gY2FsbCB0aGUgYmFzZSB0eXBlIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb290VHlwZSwgb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBnZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgcnVsZVxyXG4gICAgU3RyaW5nTGVuZ3RoUnVsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuY29udGFpbmluZ1R5cGUuZnVsbE5hbWUgKyBcIi5cIiArIHRoaXMucHJvcGVydHkubmFtZSArIFwiIHN0cmluZyBsZW5ndGgsIG1pbjogLCBtYXg6IFwiO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHJpbmdMZW5ndGhSdWxlO1xyXG59KHZhbGlkYXRpb25fcnVsZV8xLlZhbGlkYXRpb25SdWxlKSk7XHJcbmV4cG9ydHMuU3RyaW5nTGVuZ3RoUnVsZSA9IFN0cmluZ0xlbmd0aFJ1bGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5UeXBlJGdlbmVyYXRlQ29uc3RydWN0b3IgPSBleHBvcnRzLlR5cGUkZ2VuZXJhdGVNZXRob2QgPSBleHBvcnRzLmdldElkRnJvbVN0YXRlID0gZXhwb3J0cy5pc0VudGl0eVR5cGUgPSBleHBvcnRzLmlzVmFsdWVBcnJheSA9IGV4cG9ydHMuaXNWYWx1ZSA9IGV4cG9ydHMuaXNWYWx1ZVR5cGUgPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLlR5cGUkbmV3SWRQcmVmaXggPSB2b2lkIDA7XHJcbnZhciBlbnRpdHlfMSA9IHJlcXVpcmUoXCIuL2VudGl0eVwiKTtcclxudmFyIHByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eVwiKTtcclxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnNcIik7XHJcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcclxudmFyIG9ic2VydmFibGVfYXJyYXlfMSA9IHJlcXVpcmUoXCIuL29ic2VydmFibGUtYXJyYXlcIik7XHJcbnZhciBydWxlXzEgPSByZXF1aXJlKFwiLi9ydWxlXCIpO1xyXG52YXIgZm9ybWF0XzEgPSByZXF1aXJlKFwiLi9mb3JtYXRcIik7XHJcbnZhciBwcm9wZXJ0eV9jaGFpbl8xID0gcmVxdWlyZShcIi4vcHJvcGVydHktY2hhaW5cIik7XHJcbmV4cG9ydHMuVHlwZSRuZXdJZFByZWZpeCA9IFwiK2NcIjtcclxudmFyIFR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyByZWFkb25seSBjb25kaXRpb25zQ2hhbmdlZDogRXZlbnRTdWJzY3JpYmVyPFR5cGUsIENvbmRpdGlvblRhcmdldHNDaGFuZ2VkRXZlbnRBcmdzPjtcclxuICAgIGZ1bmN0aW9uIFR5cGUobW9kZWwsIGZ1bGxOYW1lLCBiYXNlVHlwZSwgZm9ybWF0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGJhc2VUeXBlID09PSB2b2lkIDApIHsgYmFzZVR5cGUgPSBudWxsOyB9XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMuZnVsbE5hbWUgPSBmdWxsTmFtZTtcclxuICAgICAgICB0aGlzLmpzdHlwZSA9IFR5cGUkZ2VuZXJhdGVDb25zdHJ1Y3Rvcih0aGlzLCBmdWxsTmFtZSwgYmFzZVR5cGUsIG1vZGVsLnNldHRpbmdzLnVzZUdsb2JhbE9iamVjdCA/IGhlbHBlcnNfMS5nZXRHbG9iYWxPYmplY3QoKSA6IG51bGwpO1xyXG4gICAgICAgIHRoaXMuYmFzZVR5cGUgPSBiYXNlVHlwZTtcclxuICAgICAgICB0aGlzLmRlcml2ZWRUeXBlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2lkZW50aWZpZXIgPSBudWxsO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fcG9vbF9fXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IHt9IH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9fcHJvcGVydGllc19fXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IHt9IH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9sYXN0SWRcIiwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlOiAwIH0pO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9mb3JtYXRzXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2NoYWluc1wiLCB7IGVudW1lcmFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0pO1xyXG4gICAgICAgIGlmIChiYXNlVHlwZSkge1xyXG4gICAgICAgICAgICBiYXNlVHlwZS5kZXJpdmVkVHlwZXMucHVzaCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbml0TmV3ID0gbmV3IGV2ZW50c18xLkV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5pbml0RXhpc3RpbmcgPSBuZXcgZXZlbnRzXzEuRXZlbnQoKTtcclxuICAgICAgICAvLyB0aGlzLmNvbmRpdGlvbnNDaGFuZ2VkID0gbmV3IEV2ZW50PFR5cGUsIENvbmRpdGlvblRhcmdldHNDaGFuZ2VkRXZlbnRBcmdzPigpO1xyXG4gICAgICAgIC8vIFNldCBGb3JtYXRcclxuICAgICAgICBpZiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGZvcm1hdCkgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0ID0gdGhpcy5tb2RlbC5nZXRGb3JtYXQodGhpcy5qc3R5cGUsIGZvcm1hdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFwcGx5IHR5cGUgb3B0aW9uc1xyXG4gICAgICAgIGlmIChvcHRpb25zKVxyXG4gICAgICAgICAgICB0aGlzLmV4dGVuZChvcHRpb25zKTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUeXBlLnByb3RvdHlwZSwgXCJpZGVudGlmaWVyXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lkZW50aWZpZXIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faWRlbnRpZmllcjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVR5cGUgPyB0aGlzLmJhc2VUeXBlLmlkZW50aWZpZXIgOiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lkZW50aWZpZXIgPSB2YWw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVHlwZS5wcm90b3R5cGUuY3JlYXRlSWZOb3RFeGlzdHMgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICB2YXIgaWQgPSBnZXRJZEZyb21TdGF0ZSh0aGlzLCBzdGF0ZSk7XHJcbiAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KGlkKTtcclxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgQ3RvciA9IHRoaXMuanN0eXBlO1xyXG4gICAgICAgIC8vIENvbnN0cnVjdCBhbiBpbnN0YW5jZSB1c2luZyB0aGUga25vd24gaWQgaWYgaXQgaXMgcHJlc2VudFxyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IChpZCA/IG5ldyBDdG9yKGlkLCBzdGF0ZSkgOiBuZXcgQ3RvcihzdGF0ZSkpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH07XHJcbiAgICBUeXBlLnByb3RvdHlwZS5jcmVhdGVTeW5jID0gZnVuY3Rpb24gKHN0YXRlKSB7XHJcbiAgICAgICAgdmFyIGlkID0gZ2V0SWRGcm9tU3RhdGUodGhpcywgc3RhdGUpO1xyXG4gICAgICAgIGlmIChpZCAmJiB0aGlzLmdldChpZCkpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgaW5zdGFuY2Ugb2YgdHlwZSAnXCIgKyB0aGlzLmZ1bGxOYW1lICsgXCInIHdpdGggaWRlbnRpZmllciAnXCIgKyBpZCArIFwiJyBiZWNhdXNlIHRoaXMgb2JqZWN0IGFscmVhZHkgZXhpc3RzLlwiKTtcclxuICAgICAgICB2YXIgQ3RvciA9IHRoaXMuanN0eXBlO1xyXG4gICAgICAgIC8vIENvbnN0cnVjdCBhbiBpbnN0YW5jZSB1c2luZyB0aGUga25vd24gaWQgaWYgaXQgaXMgcHJlc2VudFxyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IChpZCA/IG5ldyBDdG9yKGlkLCBzdGF0ZSkgOiBuZXcgQ3RvcihzdGF0ZSkpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH07XHJcbiAgICBUeXBlLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLmNyZWF0ZVN5bmMoc3RhdGUpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5pbml0aWFsaXplZC50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RhbmNlOyB9KTtcclxuICAgIH07XHJcbiAgICAvKiogR2VuZXJhdGVzIGEgdW5pcXVlIGlkIHN1aXRhYmxlIGZvciBhbiBpbnN0YW5jZSBpbiB0aGUgY3VycmVudCB0eXBlIGhpZXJhcmNoeS4gKi9cclxuICAgIFR5cGUucHJvdG90eXBlLm5ld0lkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsYXN0SWQ7XHJcbiAgICAgICAgZm9yICh2YXIgdHlwZSA9IHRoaXM7IHR5cGU7IHR5cGUgPSB0eXBlLmJhc2VUeXBlKSB7XHJcbiAgICAgICAgICAgIGxhc3RJZCA9IE1hdGgubWF4KGxhc3RJZCB8fCAwLCB0eXBlLl9sYXN0SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV4dElkID0gbGFzdElkICsgMTtcclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgaWQgZm9yIGVhY2ggdHlwZSBpbiB0aGUgaGVpcmFyY2h5LlxyXG4gICAgICAgIGZvciAodmFyIHR5cGUgPSB0aGlzOyB0eXBlOyB0eXBlID0gdHlwZS5iYXNlVHlwZSkge1xyXG4gICAgICAgICAgICB0eXBlLl9sYXN0SWQgPSBuZXh0SWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgbmV3IGlkLlxyXG4gICAgICAgIHJldHVybiBleHBvcnRzLlR5cGUkbmV3SWRQcmVmaXggKyBuZXh0SWQ7XHJcbiAgICB9O1xyXG4gICAgVHlwZS5wcm90b3R5cGUuYXNzZXJ0VmFsaWRJZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCB8fCBpZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklkIGNhbm5vdCBiZSBcIiArIChpZCA9PT0gbnVsbCA/IFwibnVsbFwiIDogXCJ1bmRlZmluZWRcIikgKyBcIiAoZW50aXR5ID0gXCIgKyB0aGlzLmZ1bGxOYW1lICsgXCIpLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGVscGVyc18xLmdldFR5cGVOYW1lKGlkKSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJZCBtdXN0IGJlIGEgc3RyaW5nOiAgZW5jb3VudGVyZWQgaWQgXCIgKyBpZCArIFwiIG9mIHR5cGUgXFxcIlwiICsgaGVscGVyc18xLnBhcnNlRnVuY3Rpb25OYW1lKGlkLmNvbnN0cnVjdG9yKSArIFwiXFxcIiAoZW50aXR5ID0gXCIgKyB0aGlzLmZ1bGxOYW1lICsgXCIpLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaWQgPT09IFwiXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWQgY2Fubm90IGJlIGEgYmxhbmsgc3RyaW5nIChlbnRpdHkgPSBcIiArIHRoaXMuZnVsbE5hbWUgKyBcIikuXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUeXBlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICB0aGlzLmFzc2VydFZhbGlkSWQob2JqLm1ldGEuaWQpO1xyXG4gICAgICAgIHZhciBrZXkgPSBvYmoubWV0YS5pZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGZvciAodmFyIHQgPSB0aGlzOyB0OyB0ID0gdC5iYXNlVHlwZSkge1xyXG4gICAgICAgICAgICBpZiAodC5fX3Bvb2xfXy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3QgXFxcIlwiICsgdGhpcy5mdWxsTmFtZSArIFwifFwiICsgb2JqLm1ldGEuaWQgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0Ll9fcG9vbF9fW2tleV0gPSBvYmo7XHJcbiAgICAgICAgICAgIGlmICh0Ll9fa25vd25fXykge1xyXG4gICAgICAgICAgICAgICAgdC5fX2tub3duX18ucHVzaChvYmopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm1vZGVsLnNldHRpbmdzLmNyZWF0ZU93blByb3BlcnRpZXMgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzLl9fcHJvcGVydGllc19fKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX19wcm9wZXJ0aWVzX18sIHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5fX3Byb3BlcnRpZXNfX1twcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eV8xLlByb3BlcnR5JGdlbmVyYXRlT3duUHJvcGVydHkocHJvcGVydHksIG9iaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tb2RlbC5lbnRpdHlSZWdpc3RlcmVkLnB1Ymxpc2godGhpcy5tb2RlbCwgeyBlbnRpdHk6IG9iaiB9KTtcclxuICAgIH07XHJcbiAgICBUeXBlLnByb3RvdHlwZS5jaGFuZ2VPYmplY3RJZCA9IGZ1bmN0aW9uIChvbGRJZCwgbmV3SWQpIHtcclxuICAgICAgICB0aGlzLmFzc2VydFZhbGlkSWQob2xkSWQpO1xyXG4gICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRJZChuZXdJZCk7XHJcbiAgICAgICAgdmFyIG9sZEtleSA9IG9sZElkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgdmFyIG5ld0tleSA9IG5ld0lkLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX19wb29sX19bbmV3S2V5XSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnRpdHkgJ1wiICsgdGhpcy5mdWxsTmFtZSArIFwifFwiICsgbmV3S2V5ICsgXCInIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLl9fcG9vbF9fW29sZEtleV07XHJcbiAgICAgICAgaWYgKCFvYmopIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogVGhyb3cgZXJyb3Igb3Igd2FybiB3aGVuIGF0dGVtcHRpbmcgdG8gY2hhbmdlIGFuIG9iamVjdCBJZCB0aGF0IGlzIHVua25vd24/XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgdCA9IHRoaXM7IHQ7IHQgPSB0LmJhc2VUeXBlKSB7XHJcbiAgICAgICAgICAgIHQuX19wb29sX19bbmV3S2V5XSA9IG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqLm1ldGEuaWQgPSBuZXdJZDtcclxuICAgICAgICBvYmoubWFya1BlcnNpc3RlZCgpO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgVHlwZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkLCBleGFjdFR5cGVPbmx5KSB7XHJcbiAgICAgICAgaWYgKGV4YWN0VHlwZU9ubHkgPT09IHZvaWQgMCkgeyBleGFjdFR5cGVPbmx5ID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAoIWlkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBcXFwiXCIgKyB0aGlzLmZ1bGxOYW1lICsgXCIubWV0YS5nZXQoKVxcXCIgd2FzIGNhbGxlZCB3aXRob3V0IGEgdmFsaWQgaWQgYXJndW1lbnQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2V5ID0gaWQudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB2YXIgb2JqID0gdGhpcy5fX3Bvb2xfX1trZXldO1xyXG4gICAgICAgIC8vIElmIGV4YWN0VHlwZU9ubHkgaXMgc3BlY2lmaWVkLCBkb24ndCByZXR1cm4gc3ViLXR5cGVzLlxyXG4gICAgICAgIGlmIChvYmogJiYgZXhhY3RUeXBlT25seSA9PT0gdHJ1ZSAmJiBvYmoubWV0YS50eXBlICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBlbnRpdHkgd2l0aCBpZD0nXCIgKyBpZCArIFwiJyBpcyBleHBlY3RlZCB0byBiZSBvZiB0eXBlICdcIiArIHRoaXMuZnVsbE5hbWUgKyBcIicgYnV0IGZvdW5kIHR5cGUgJ1wiICsgb2JqLm1ldGEudHlwZS5mdWxsTmFtZSArIFwiJy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyBhbiBhcnJheSBvZiBhbGwgb2JqZWN0cyBvZiB0aGlzIHR5cGUgdGhhdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZC5cclxuICAgIC8vIFRoZSByZXR1cm5lZCBhcnJheSBpcyBvYnNlcnZhYmxlIGFuZCBjb2xsZWN0aW9uIGNoYW5nZWQgZXZlbnRzIHdpbGwgYmUgcmFpc2VkXHJcbiAgICAvLyB3aGVuIG5ldyBvYmplY3RzIGFyZSByZWdpc3RlcmVkLlxyXG4gICAgLy8gVGhlIGFycmF5IGlzIGluIG5vIHBhcnRpY3VsYXIgb3JkZXIuXHJcbiAgICBUeXBlLnByb3RvdHlwZS5rbm93biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIga25vd24gPSB0aGlzLl9fa25vd25fXztcclxuICAgICAgICBpZiAoIWtub3duKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuX19wb29sX18pIHtcclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fX3Bvb2xfXywgaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMuX19wb29sX19baWRdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBrbm93biA9IG9ic2VydmFibGVfYXJyYXlfMS5PYnNlcnZhYmxlQXJyYXkuZW5zdXJlT2JzZXJ2YWJsZShsaXN0KTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX19rbm93bl9fXCIsIHsgZW51bWVyYWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgdmFsdWU6IGtub3duIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ga25vd247XHJcbiAgICB9O1xyXG4gICAgVHlwZS5wcm90b3R5cGUuZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHZhciBwcm9wO1xyXG4gICAgICAgIGZvciAodmFyIHQgPSB0aGlzOyB0ICYmICFwcm9wOyB0ID0gdC5iYXNlVHlwZSkge1xyXG4gICAgICAgICAgICBwcm9wID0gdC5fX3Byb3BlcnRpZXNfX1tuYW1lXTtcclxuICAgICAgICAgICAgaWYgKHByb3ApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKiBHZXRzIHRoZSB7UHJvcGVydHl9IG9yIHtQcm9wZXJ0eUNoYWlufSBmb3IgdGhlIHNwZWNpZmllZCBzaW1wbGUgcGF0aCB7c3RyaW5nfS4gKi9cclxuICAgIFR5cGUucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xyXG4gICAgICAgIC8vIEdldCBzaW5nbGUgcHJvcGVydHlcclxuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmdldFByb3BlcnR5KHBhdGgpO1xyXG4gICAgICAgIC8vIEdldCBjYWNoZWQgcHJvcGVydHkgY2hhaW5cclxuICAgICAgICBpZiAoIXByb3BlcnR5KVxyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuX2NoYWluc1twYXRoXTtcclxuICAgICAgICAvLyBDcmVhdGUgYW5kIGNhY2hlIHByb3BlcnR5IGNoYWluXHJcbiAgICAgICAgaWYgKCFwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHRoaXMuX2NoYWluc1twYXRoXSA9IG5ldyBwcm9wZXJ0eV9jaGFpbl8xLlByb3BlcnR5Q2hhaW4odGhpcywgcGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybiB0aGUgcHJvcGVydHkgcGF0aFxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eTtcclxuICAgIH07XHJcbiAgICAvKiogR2V0cyBhbmQgYXJyYXkgb2Yge1Byb3BlcnR5fSBvciB7UHJvcGVydHlDaGFpbn0gaW5zdGFuY2VzIGZvciB0aGUgc3BlY2lmaWVkIGNvbXBsZXggZ3JhcGggcGF0aCB7c3RyaW5nfS4gKi9cclxuICAgIFR5cGUucHJvdG90eXBlLmdldFBhdGhzID0gZnVuY3Rpb24gKHBhdGgpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSAwO1xyXG4gICAgICAgIHZhciBwYXRocyA9IFtdO1xyXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhdGhcclxuICAgICAgICBpZiAoL3t8LHx9L2cudGVzdChwYXRoKSkge1xyXG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBbXTtcclxuICAgICAgICAgICAgdmFyIHBhcmVudF8xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBwYXRoLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgICAgIGlmIChjID09PSBcIntcIiB8fCBjID09PSBcIixcIiB8fCBjID09PSBcIn1cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBwYXRoLnN1YnN0cmluZyhzdGFydCwgaSkudHJpbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwie1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChwYXJlbnRfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMSArPSBcIi5cIiArIHNlZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudF8xID0gc2VnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyAnLCcgb3IgJ30nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaCh0aGlzLmdldFBhdGgocGFyZW50XzEgPyBwYXJlbnRfMSArIFwiLlwiICsgc2VnIDogc2VnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09IFwifVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMSA9IChzdGFjay5sZW5ndGggPT09IDApID8gdW5kZWZpbmVkIDogc3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgfHwgcGFyZW50XzEpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2xvc2VkICd7JyBpbiBwYXRoOiBcIiArIHBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdGFydCA8IHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gcGF0aC5zdWJzdHJpbmcoc3RhcnQpLnRyaW0oKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhzLnB1c2godGhpcy5nZXRQYXRoKHNlZykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHN0YXJ0IHRvIHBhc3QgdGhlIGVuZCBvZiB0aGUgbGlzdCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBlbnRpcmUgc3RyaW5nIHdhcyBwcm9jZXNzZWRcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gcGF0aC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgc2ltcGxlIHByb3BlcnR5IG9yIHBhdGgsIHRoZW4gYWRkIHRoZSBzaW5nbGUgcHJvcGVydHkgb3IgY2hhaW5cclxuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcclxuICAgICAgICAgICAgcGF0aHMucHVzaCh0aGlzLmdldFBhdGgocGF0aC50cmltKCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGhzO1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUeXBlLnByb3RvdHlwZSwgXCJwcm9wZXJ0aWVzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXNPYmplY3QgPSBfX2Fzc2lnbih7fSwgdGhpcy5fX3Byb3BlcnRpZXNfXyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHR5cGUgPSB0aGlzLmJhc2VUeXBlOyB0eXBlICE9IG51bGw7IHR5cGUgPSB0eXBlLmJhc2VUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gdHlwZS5fX3Byb3BlcnRpZXNfXykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJvcGVydGllc09iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXNPYmplY3RbcHJvcGVydHlOYW1lXSA9IHR5cGUuX19wcm9wZXJ0aWVzX19bcHJvcGVydHlOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMocHJvcGVydGllc09iamVjdCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVHlwZS5wcm90b3R5cGUuYWRkUnVsZSA9IGZ1bmN0aW9uIChvcHRpb25zT3JGdW5jdGlvbikge1xyXG4gICAgICAgIHZhciBvcHRpb25zO1xyXG4gICAgICAgIGlmIChvcHRpb25zT3JGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBhcmUgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGVcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnNPckZ1bmN0aW9uIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IGV4ZWN1dGU6IG9wdGlvbnNPckZ1bmN0aW9uIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yRnVuY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJ1bGUgPSBuZXcgcnVsZV8xLlJ1bGUodGhpcywgb3B0aW9ucy5uYW1lLCBvcHRpb25zKTtcclxuICAgICAgICAvLyBUT0RPOiBUcmFjayBydWxlcyBvbiB0aGUgdHlwZT9cclxuICAgICAgICByZXR1cm4gcnVsZTtcclxuICAgIH07XHJcbiAgICBUeXBlLnByb3RvdHlwZS5oYXNNb2RlbFByb3BlcnR5ID0gZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICByZXR1cm4gcHJvcC5jb250YWluaW5nVHlwZSA9PT0gdGhpcyB8fCB0aGlzLmlzU3ViY2xhc3NPZihwcm9wLmNvbnRhaW5pbmdUeXBlKTtcclxuICAgIH07XHJcbiAgICBUeXBlLnByb3RvdHlwZS5pc1N1YmNsYXNzT2YgPSBmdW5jdGlvbiAodHlwZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICBoZWxwZXJzXzEubmF2aWdhdGVBdHRyaWJ1dGUodGhpcywgXCJiYXNlVHlwZVwiLCBmdW5jdGlvbiAoYmFzZVR5cGUpIHtcclxuICAgICAgICAgICAgaWYgKGJhc2VUeXBlID09PSB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBUeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mdWxsTmFtZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgdGhlIGN1cnJlbnQgdHlwZSB3aXRoIHRoZSBzcGVjaWZpZWQgZm9ybWF0LCBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyBzcGVjaWZ5aW5nIGhvdyB0byBleHRlbmQgdGhlIHR5cGVcclxuICAgICAqL1xyXG4gICAgVHlwZS5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0eXBlID0gdGhpcztcclxuICAgICAgICAvLyBVdGlsaXR5IGZ1bmN0aW9uIHRvIGNvbnZlcnQgYSBwYXRoIHN0cmluZyBpbnRvIGEgcmVzb2x2ZWQgYXJyYXkgb2YgUHJvcGVydHkgYW5kIFByb3BlcnR5Q2hhaW4gaW5zdGFuY2VzXHJcbiAgICAgICAgZnVuY3Rpb24gcmVzb2x2ZURlcGVuZHNPbihydWxlLCBkZXBlbmRzT24pIHtcclxuICAgICAgICAgICAgLy8gcmV0dXJuIGFuIGVtcHR5IGRlcGVuZGVuY3kgYXJyYXkgaWYgbm8gcGF0aCB3YXMgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIGlmICghZGVwZW5kc09uKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgZGVwZW5kc09uIGlzIG5vdCBhIHN0cmluZ1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIChkZXBlbmRzT24pICE9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkZXBlbmRzT24gcHJvcGVydHkgZm9yICdcIiArIHJ1bGUgKyBcIicgcnVsZSBvbiAnXCIgKyB0eXBlICsgXCIuXCIpO1xyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIHByb3BlcnR5IHBhdGhzIGZvciB0aGUgc3BlY2lmaWVkIGRlcGVuZGVuY3kgc3RyaW5nXHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlLmdldFBhdGhzKGRlcGVuZHNPbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVzZSBwcmVwYXJlKCkgdG8gZGVmZXIgcHJvcGVydHkgcGF0aCByZXNvbHV0aW9uIHdoaWxlIHRoZSBtb2RlbCBpcyBiZWluZyBleHRlbmRlZFxyXG4gICAgICAgIHRoaXMubW9kZWwucHJlcGFyZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpc1J1bGVNZXRob2QgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLmhhc093blByb3BlcnR5KFwiZnVuY3Rpb25cIik7IH07XHJcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG5hbWVfMSwgbWVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobmFtZV8xLnN0YXJ0c1dpdGgoXCIkXCIpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgVHlwZSBhbmQgRm9ybWF0IHZhbHVlcywgd2hpY2ggZG8gbm90IHJlcHJlc2VudCB0eXBlIG1lbWJlcnNcclxuICAgICAgICAgICAgICAgIGlmIChtZW1iZXIgaW5zdGFuY2VvZiBUeXBlIHx8IG1lbWJlciBpbnN0YW5jZW9mIGZvcm1hdF8xLkZvcm1hdClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xyXG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydHkgVHlwZSBOYW1lXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChtZW1iZXIpID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IHsgdHlwZTogbWVtYmVyIH07XHJcbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0eSBUeXBlXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1ZhbHVlVHlwZShtZW1iZXIpKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IHsgdHlwZTogbWVtYmVyIH07XHJcbiAgICAgICAgICAgICAgICAvLyBOb24tUnVsZSBNZXRob2QvRnVuY3Rpb25cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG1lbWJlcikgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIFR5cGUkZ2VuZXJhdGVNZXRob2QoX3RoaXMsIF90aGlzLmpzdHlwZS5wcm90b3R5cGUsIG5hbWVfMSwgbWVtYmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJ1bGUgTWV0aG9kXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1J1bGVNZXRob2QobWVtYmVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmdW5jID0gbWVtYmVyLmZ1bmN0aW9uLCBkZXBlbmRzT25fMSA9IG1lbWJlci5kZXBlbmRzT247XHJcbiAgICAgICAgICAgICAgICAgICAgVHlwZSRnZW5lcmF0ZU1ldGhvZChfdGhpcywgX3RoaXMuanN0eXBlLnByb3RvdHlwZSwgbmFtZV8xLCBmdW5jKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb2RlbC5yZWFkeShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBydWxlXzEuUnVsZShfdGhpcywgX3RoaXMuZnVsbE5hbWUgKyBcIi5cIiArIG5hbWVfMSArIFwiUnVsZVwiLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiAobmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXMuXCIgKyBuYW1lXzEgKyBcIigpO1wiKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZU9mOiByZXNvbHZlRGVwZW5kc09uKFwiZ2V0XCIsIGRlcGVuZHNPbl8xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZWdpc3RlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydHlcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IF9fYXNzaWduKHt9LCBtZW1iZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBQcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IF90aGlzLmdldFByb3BlcnR5KG5hbWVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIFByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAobWVtYmVyLnR5cGUgJiYgaXNFbnRpdHlUeXBlKHByb3BlcnR5LnByb3BlcnR5VHlwZSkgJiYgcHJvcGVydHkucHJvcGVydHlUeXBlLm1ldGEuZnVsbE5hbWUgIT09IG1lbWJlci50eXBlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAobWVtYmVyLnR5cGUgJiYgaXNWYWx1ZVR5cGUobWVtYmVyLnR5cGUpICYmIGlzVmFsdWVUeXBlKHByb3BlcnR5LnByb3BlcnR5VHlwZSkgJiYgcHJvcGVydHkucHJvcGVydHlUeXBlICE9PSBtZW1iZXIudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSAmIElzTGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNMaXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG1lbWJlci50eXBlKSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGVOYW1lID0gbWVtYmVyLnR5cGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlIG5hbWVzIGVuZGluZyBpbiBbXSBhcmUgbGlzdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlTmFtZS5sYXN0SW5kZXhPZihcIltdXCIpID09PSAodHlwZU5hbWUubGVuZ3RoIC0gMikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0xpc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVOYW1lID0gdHlwZU5hbWUuc3Vic3RyKDAsIHR5cGVOYW1lLmxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0eXBlIG5hbWVzIHRvIGphdmFzY3JpcHQgdHlwZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlci50eXBlID0gX3RoaXMubW9kZWwuZ2V0SnNUeXBlKHR5cGVOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhcm4gaWYgdGhlIHR5cGUgY291bGRuJ3QgYmUgZm91bmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVtYmVyLnR5cGUgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IHJlc29sdmUgdHlwZSAnXCIgKyB0eXBlTmFtZSArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJZGVudGlmaWVyID0gbWVtYmVyLmlkZW50aWZpZXIgPT09IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBQcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcGVydHlfMiA9IG5ldyBwcm9wZXJ0eV8xLlByb3BlcnR5KF90aGlzLCBuYW1lXzEsIG1lbWJlci50eXBlLCBpc0lkZW50aWZpZXIsIGlzTGlzdCwgbWVtYmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWRlbnRpZmllciA9IHByb3BlcnR5XzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX19wcm9wZXJ0aWVzX19bbmFtZV8xXSA9IHByb3BlcnR5XzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5XzEuUHJvcGVydHkkZ2VuZXJhdGVTaG9ydGN1dHMocHJvcGVydHlfMiwgX3RoaXMuanN0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5tb2RlbC5zZXR0aW5ncy5jcmVhdGVPd25Qcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eV8xLlByb3BlcnR5JGdlbmVyYXRlUHJvdG90eXBlUHJvcGVydHkocHJvcGVydHlfMiwgX3RoaXMuanN0eXBlLnByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5LmV4dGVuZChtZW1iZXIsIF90aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIFR5cGUgTWVtYmVyc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gaGVscGVyc18xLmVudHJpZXMob3B0aW9ucyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIG5hbWVfMSA9IF9iWzBdLCBtZW1iZXIgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIF9sb29wXzEobmFtZV8xLCBtZW1iZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFR5cGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuVHlwZSA9IFR5cGU7XHJcbmZ1bmN0aW9uIGlzVmFsdWVUeXBlKHR5cGUpIHtcclxuICAgIHJldHVybiB0eXBlID09PSBTdHJpbmcgfHwgdHlwZSA9PT0gTnVtYmVyIHx8IHR5cGUgPT09IERhdGUgfHwgdHlwZSA9PT0gQm9vbGVhbjtcclxufVxyXG5leHBvcnRzLmlzVmFsdWVUeXBlID0gaXNWYWx1ZVR5cGU7XHJcbmZ1bmN0aW9uIGlzVmFsdWUodmFsdWUsIHR5cGUpIHtcclxuICAgIGlmICh0eXBlID09PSB2b2lkIDApIHsgdHlwZSA9IG51bGw7IH1cclxuICAgIGlmICh2YWx1ZSA9PSBudWxsKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHZhciB2YWx1ZVR5cGUgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcclxuICAgIGlmICh0eXBlICE9IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlVHlwZSA9PT0gdHlwZTtcclxuICAgIHJldHVybiBpc1ZhbHVlVHlwZSh2YWx1ZVR5cGUpO1xyXG59XHJcbmV4cG9ydHMuaXNWYWx1ZSA9IGlzVmFsdWU7XHJcbmZ1bmN0aW9uIGlzVmFsdWVBcnJheSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgdmFyIGl0ZW0gPSB2YWx1ZVswXTtcclxuICAgIGlmIChpdGVtID09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgdmFyIGl0ZW1UeXBlID0gaXRlbS5jb25zdHJ1Y3RvcjtcclxuICAgIHJldHVybiBpc1ZhbHVlVHlwZShpdGVtVHlwZSk7XHJcbn1cclxuZXhwb3J0cy5pc1ZhbHVlQXJyYXkgPSBpc1ZhbHVlQXJyYXk7XHJcbmZ1bmN0aW9uIGlzRW50aXR5VHlwZSh0eXBlKSB7XHJcbiAgICByZXR1cm4gdHlwZS5tZXRhICYmIHR5cGUubWV0YSBpbnN0YW5jZW9mIFR5cGU7XHJcbn1cclxuZXhwb3J0cy5pc0VudGl0eVR5cGUgPSBpc0VudGl0eVR5cGU7XHJcbmZ1bmN0aW9uIGdldElkRnJvbVN0YXRlKHR5cGUsIHN0YXRlKSB7XHJcbiAgICBpZiAodHlwZS5pZGVudGlmaWVyICYmIHR5cGVvZiBzdGF0ZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHZhciBpZCA9IHN0YXRlW3R5cGUuaWRlbnRpZmllci5uYW1lXTtcclxuICAgICAgICBpZiAoaWQgJiYgdHlwZW9mIGlkID09PSBcInN0cmluZ1wiICYmIGlkLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHJldHVybiBpZDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldElkRnJvbVN0YXRlID0gZ2V0SWRGcm9tU3RhdGU7XHJcbmZ1bmN0aW9uIFR5cGUkZ2VuZXJhdGVNZXRob2QodHlwZSwgdGFyZ2V0LCBuYW1lLCBmbikge1xyXG4gICAgdGFyZ2V0W25hbWVdID0gZm47XHJcbn1cclxuZXhwb3J0cy5UeXBlJGdlbmVyYXRlTWV0aG9kID0gVHlwZSRnZW5lcmF0ZU1ldGhvZDtcclxuLy8gVE9ETzogR2V0IHJpZCBvZiBkaXNhYmxlQ29uc3RydWN0aW9uP1xyXG52YXIgZGlzYWJsZUNvbnN0cnVjdGlvbiA9IGZhbHNlO1xyXG5mdW5jdGlvbiBUeXBlJGdlbmVyYXRlQ29uc3RydWN0b3IodHlwZSwgZnVsbE5hbWUsIGJhc2VUeXBlLCBnbG9iYWwpIHtcclxuICAgIGlmIChiYXNlVHlwZSA9PT0gdm9pZCAwKSB7IGJhc2VUeXBlID0gbnVsbDsgfVxyXG4gICAgaWYgKGdsb2JhbCA9PT0gdm9pZCAwKSB7IGdsb2JhbCA9IG51bGw7IH1cclxuICAgIC8vIENyZWF0ZSBuYW1lc3BhY2VzIGFzIG5lZWRlZFxyXG4gICAgdmFyIG5hbWVUb2tlbnMgPSBmdWxsTmFtZS5zcGxpdChcIi5cIik7XHJcbiAgICB2YXIgdG9rZW4gPSBuYW1lVG9rZW5zLnNoaWZ0KCk7XHJcbiAgICB2YXIgbmFtZXNwYWNlT2JqID0gdHlwZS5tb2RlbC4kbmFtZXNwYWNlIHx8IHR5cGUubW9kZWw7XHJcbiAgICB2YXIgbmFtZXNwYWNlUHJlZml4ID0gXCJcIjtcclxuICAgIHZhciBnbG9iYWxPYmogPSBnbG9iYWw7XHJcbiAgICB3aGlsZSAobmFtZVRva2Vucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgbmFtZXNwYWNlUHJlZml4ID0gbmFtZXNwYWNlUHJlZml4ICsgdG9rZW4gKyBcIi5cIjtcclxuICAgICAgICBuYW1lc3BhY2VPYmogPSBoZWxwZXJzXzEuZW5zdXJlTmFtZXNwYWNlKHRva2VuLCBuYW1lc3BhY2VPYmopO1xyXG4gICAgICAgIGlmIChnbG9iYWwpIHtcclxuICAgICAgICAgICAgZ2xvYmFsT2JqID0gaGVscGVyc18xLmVuc3VyZU5hbWVzcGFjZSh0b2tlbiwgZ2xvYmFsT2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9rZW4gPSBuYW1lVG9rZW5zLnNoaWZ0KCk7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgZmluYWwgbmFtZSB0byB1c2UgaXMgdGhlIGxhc3QgdG9rZW5cclxuICAgIHZhciBmaW5hbE5hbWUgPSB0b2tlbjtcclxuICAgIHZhciBCYXNlQ29uc3RydWN0b3I7XHJcbiAgICBpZiAoYmFzZVR5cGUpIHtcclxuICAgICAgICBCYXNlQ29uc3RydWN0b3IgPSBiYXNlVHlwZS5qc3R5cGU7XHJcbiAgICAgICAgLy8gLy8gVE9ETzogSW1wbGVtZW50IGBpbmhlcml0QmFzZVR5cGVQcm9wU2hvcnRjdXRzYFxyXG4gICAgICAgIC8vIC8vIGluaGVyaXQgYWxsIHNob3J0Y3V0IHByb3BlcnRpZXMgdGhhdCBoYXZlIGFsZWFkeSBiZWVuIGRlZmluZWRcclxuICAgICAgICAvLyBpbmhlcml0QmFzZVR5cGVQcm9wU2hvcnRjdXRzKGN0b3IsIGJhc2VUeXBlKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIEJhc2VDb25zdHJ1Y3RvciA9IGVudGl0eV8xLkVudGl0eTtcclxuICAgIH1cclxuICAgIHZhciBjdG9yRmFjdG9yeSA9IG5ldyBGdW5jdGlvbihcImNvbnN0cnVjdFwiLCBcInJldHVybiBmdW5jdGlvbiBcIiArIGZpbmFsTmFtZSArIFwiICgpIHsgY29uc3RydWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cIik7XHJcbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3QoKSB7XHJcbiAgICAgICAgaWYgKCFkaXNhYmxlQ29uc3RydWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHlfMS5FbnRpdHkuY3RvckRlcHRoKys7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LmZyb20oYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIGlmICghKGFyZ3NbMF0gaW5zdGFuY2VvZiBUeXBlKSlcclxuICAgICAgICAgICAgICAgICAgICBhcmdzLnVuc2hpZnQodHlwZSk7XHJcbiAgICAgICAgICAgICAgICBCYXNlQ29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHlfMS5FbnRpdHkuY3RvckRlcHRoLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgY3RvciA9IGN0b3JGYWN0b3J5KGNvbnN0cnVjdCk7XHJcbiAgICB2YXIgbmFtZXNwYWNlS2V5ID0gZmluYWxOYW1lO1xyXG4gICAgLy8gSWYgdGhlIG5hbWVzcGFjZSBhbHJlYWR5IGNvbnRhaW5zIGEgdHlwZSB3aXRoIHRoaXMgbmFtZSwgcHJlcGVuZCBhICckJyB0byB0aGUgbmFtZVxyXG4gICAgd2hpbGUgKG5hbWVzcGFjZU9ialtuYW1lc3BhY2VLZXldKSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTmFtZXNwYWNlIHBhdGggJ1wiICsgbmFtZXNwYWNlUHJlZml4ICsgbmFtZXNwYWNlS2V5ICsgXCInIGlzIGFscmVhZHkgYXNzaWduZWQuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuYW1lc3BhY2VLZXkgPSBcIiRcIiArIG5hbWVzcGFjZUtleTtcclxuICAgIH1cclxuICAgIG5hbWVzcGFjZU9ialtuYW1lc3BhY2VLZXldID0gY3RvcjtcclxuICAgIGlmIChnbG9iYWwpIHtcclxuICAgICAgICB2YXIgZ2xvYmFsS2V5ID0gZmluYWxOYW1lO1xyXG4gICAgICAgIC8vIElmIHRoZSBnbG9iYWwgb2JqZWN0IGFscmVhZHkgY29udGFpbnMgYSB0eXBlIHdpdGggdGhpcyBuYW1lLCBhcHBlbmQgYSAnJCcgdG8gdGhlIG5hbWVcclxuICAgICAgICB3aGlsZSAoZ2xvYmFsT2JqW2dsb2JhbEtleV0pIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkdsb2JhbCBwYXRoICdcIiArIG5hbWVzcGFjZVByZWZpeCArIGdsb2JhbEtleSArIFwiJyBpcyBhbHJlYWR5IGFzc2lnbmVkLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnbG9iYWxLZXkgPSBcIiRcIiArIGdsb2JhbEtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2xvYmFsT2JqW2dsb2JhbEtleV0gPSBjdG9yO1xyXG4gICAgfVxyXG4gICAgLy8gU2V0dXAgaW5oZXJpdGFuY2VcclxuICAgIGRpc2FibGVDb25zdHJ1Y3Rpb24gPSB0cnVlO1xyXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgQmFzZUNvbnN0cnVjdG9yKCk7XHJcbiAgICBkaXNhYmxlQ29uc3RydWN0aW9uID0gZmFsc2U7XHJcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XHJcbiAgICAvLyBBZGQgdGhlICdtZXRhJyBoZWxwZXJcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLCBcIm1ldGFcIiwgeyBlbnVtZXJhYmxlOiBmYWxzZSwgdmFsdWU6IHR5cGUsIGNvbmZpZ3VyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSB9KTtcclxuICAgIHJldHVybiBjdG9yO1xyXG59XHJcbmV4cG9ydHMuVHlwZSRnZW5lcmF0ZUNvbnN0cnVjdG9yID0gVHlwZSRnZW5lcmF0ZUNvbnN0cnVjdG9yO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5WYWxpZGF0aW9uUnVsZSA9IHZvaWQgMDtcclxudmFyIGNvbmRpdGlvbl9ydWxlXzEgPSByZXF1aXJlKFwiLi9jb25kaXRpb24tcnVsZVwiKTtcclxudmFyIHByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9wcm9wZXJ0eVwiKTtcclxudmFyIFZhbGlkYXRpb25SdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZhbGlkYXRpb25SdWxlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvblJ1bGUocm9vdFR5cGUsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgcnVsZSBuYW1lIGlzIHNwZWNpZmllZFxyXG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBcIlZhbGlkYXRlZFByb3BlcnR5XCI7XHJcbiAgICAgICAgLy8gc3RvcmUgdGhlIHByb3BlcnR5IGJlaW5nIHZhbGlkYXRlZFxyXG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IG9wdGlvbnMucHJvcGVydHk7XHJcbiAgICAgICAgLy8gZW5zdXJlIHRoZSBwcm9wZXJ0aWVzIGFuZCBwcmVkaWNhdGVzIHRvIGluY2x1ZGUgdGhlIHRhcmdldCBwcm9wZXJ0eVxyXG4gICAgICAgIGlmICghb3B0aW9ucy5wcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICBvcHRpb25zLnByb3BlcnRpZXMgPSBbXTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMucHJvcGVydGllcy5pbmNsdWRlcyhwcm9wZXJ0eSkpXHJcbiAgICAgICAgICAgIG9wdGlvbnMucHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMub25DaGFuZ2VPZikge1xyXG4gICAgICAgICAgICBvcHRpb25zLm9uQ2hhbmdlT2YgPSBbcHJvcGVydHldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uQ2hhbmdlT2YuaW5kZXhPZihwcm9wZXJ0eSkgPCAwKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMub25DaGFuZ2VPZi5wdXNoKHByb3BlcnR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVmYXVsdCBjb25kaXRpb24gY2F0ZWdvcnkgdG8gRXJyb3IgaWYgYSBjb25kaXRpb24gY2F0ZWdvcnkgd2FzIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICBpZiAoIW9wdGlvbnMuY29uZGl0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICBvcHRpb25zLmNhdGVnb3J5ID0gXCJFcnJvclwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXBsYWNlIHRoZSBwcm9wZXJ0eSBsYWJlbCB0b2tlbiBpbiB0aGUgdmFsaWRhdGlvbiBtZXNzYWdlIGlmIHByZXNlbnRcclxuICAgICAgICBpZiAob3B0aW9ucy5tZXNzYWdlICYmICh0eXBlb2Ygb3B0aW9ucy5tZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgfHwgKHR5cGVvZiBvcHRpb25zLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIgJiYgb3B0aW9ucy5tZXNzYWdlLmluZGV4T2YoXCJ7cHJvcGVydHl9XCIpID49IDApKSkge1xyXG4gICAgICAgICAgICAvLyBQcm9wZXJ0eSBsYWJlbCB3aXRoIGR5bmFtaWMgZm9ybWF0IHRva2Vuc1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydHkubGFiZWxJc0Zvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsU291cmNlVHlwZV8xID0gcHJvcGVydHlfMS5nZXRMYWJlbFNvdXJjZVR5cGUocHJvcGVydHkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsRm9ybWF0ID0gcHJvcGVydHlfMS5nZXRMYWJlbEZvcm1hdChwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdG9rZW5zIGluY2x1ZGVkIGluIHRoZSBmb3JtYXQgdHJpZ2dlciBydWxlIGV4ZWN1dGlvblxyXG4gICAgICAgICAgICAgICAgbGFiZWxGb3JtYXQucGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsU291cmNlVHlwZV8xLmdldFBhdGhzKHApLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsVG9rZW5Qcm9wID0gcHJvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5LmxhYmVsU291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbFRva2VuUHJvcCA9IHJvb3RUeXBlLmdldFBhdGgocHJvcGVydHkubGFiZWxTb3VyY2UucGF0aCArIFwiLlwiICsgcHJvcC5wYXRoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMub25DaGFuZ2VPZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNoYW5nZU9mID0gW2xhYmVsVG9rZW5Qcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uQ2hhbmdlT2YuaW5kZXhPZihsYWJlbFRva2VuUHJvcCkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uQ2hhbmdlT2YucHVzaChsYWJlbFRva2VuUHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRnVuY3Rpb25fMSA9IG9wdGlvbnMubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBmdW5jdGlvbiB0byBhcHBseSB0aGUgZm9ybWF0IHRvIHRoZSBwcm9wZXJ0eSBsYWJlbCB3aGVuIGdlbmVyYXRpbmcgdGhlIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlRnVuY3Rpb25fMS5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHJpbSgpLmxlbmd0aCA+IDAgJiYgbWVzc2FnZS5pbmRleE9mKFwie3Byb3BlcnR5fVwiKSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoXCJ7cHJvcGVydHl9XCIsIHByb3BlcnR5XzEuZXZhbHVhdGVMYWJlbChwcm9wZXJ0eSwgdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvbnZlcnRpbmcgbWVzc2FnZSBvZiB0eXBlICdcIiArICh0eXBlb2YgbWVzc2FnZSkgKyBcIicgZm9yIHJ1bGUgJ1wiICsgb3B0aW9ucy5uYW1lICsgXCInIHRvIGEgc3RyaW5nLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZVRlbXBsYXRlXzEgPSBvcHRpb25zLm1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gdG8gYXBwbHkgdGhlIGZvcm1hdCB0byB0aGUgcHJvcGVydHkgbGFiZWwgd2hlbiBnZW5lcmF0aW5nIHRoZSBtZXNzYWdlXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZVRlbXBsYXRlXzEucmVwbGFjZShcIntwcm9wZXJ0eX1cIiwgcHJvcGVydHlfMS5ldmFsdWF0ZUxhYmVsKHByb3BlcnR5LCB0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTdGF0aWMgcHJvcGVydHkgbGFiZWxcclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlLnJlcGxhY2UoXCJ7cHJvcGVydHl9XCIsIHByb3BlcnR5LmxhYmVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBVc2Ugc3RhdGljIHByb3BlcnR5IGxhYmVsIGluIGZ1bmN0aW9uIHJldHVybiB2YWx1ZVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5tZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlRnVuY3Rpb25fMiA9IG9wdGlvbnMubWVzc2FnZTtcclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIHRvIGFwcGx5IHRoZSBmb3JtYXQgdG8gdGhlIHByb3BlcnR5IGxhYmVsIHdoZW4gZ2VuZXJhdGluZyB0aGUgbWVzc2FnZVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZUZ1bmN0aW9uXzIuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50cmltKCkubGVuZ3RoID4gMCAmJiBtZXNzYWdlLmluZGV4T2YoXCJ7cHJvcGVydHl9XCIpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKFwie3Byb3BlcnR5fVwiLCBwcm9wZXJ0eS5sYWJlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb252ZXJ0aW5nIG1lc3NhZ2Ugb2YgdHlwZSAnXCIgKyAodHlwZW9mIG1lc3NhZ2UpICsgXCInIGZvciBydWxlICdcIiArIG9wdGlvbnMubmFtZSArIFwiJyB0byBhIHN0cmluZy5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLmlzVmFsaWQpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5hc3NlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNWYWxpZDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IG9wdGlvbnMuaXNWYWxpZC5jYWxsKHRoaXMsIG9wdGlvbnMucHJvcGVydHksIG9wdGlvbnMucHJvcGVydHkudmFsdWUodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZCA9PT0gdW5kZWZpbmVkID8gaXNWYWxpZCA6ICFpc1ZhbGlkO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxsIHRoZSBiYXNlIHJ1bGUgY29uc3RydWN0b3JcclxuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvb3RUeXBlLCBvcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwcm9wZXJ0eVwiLCB7IHZhbHVlOiBwcm9wZXJ0eSB9KTtcclxuICAgICAgICAvLyByZWdpc3RlciB0aGUgcnVsZSB3aXRoIHRoZSB0YXJnZXQgcHJvcGVydHlcclxuICAgICAgICBfdGhpcy5wcm9wZXJ0eS5ydWxlcy5wdXNoKF90aGlzKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gVmFsaWRhdGlvblJ1bGU7XHJcbn0oY29uZGl0aW9uX3J1bGVfMS5Db25kaXRpb25SdWxlKSk7XHJcbmV4cG9ydHMuVmFsaWRhdGlvblJ1bGUgPSBWYWxpZGF0aW9uUnVsZTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==