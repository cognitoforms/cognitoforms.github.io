(window["cfWebpackJsonp"] = window["cfWebpackJsonp"] || []).push([["vuemodel"],{

/***/ "../../libs/vuemodel/lib/array-observer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayObserver = void 0;
var custom_observer_1 = __webpack_require__("../../libs/vuemodel/lib/custom-observer.js");
/**
 * A subclass of Vue's internal `Observer` class for arrays, which uses observable
 * array events rather than property walking and rewriting
 */
var ArrayObserver = /** @class */ (function (_super) {
    __extends(ArrayObserver, _super);
    function ArrayObserver(value, shallow, mock) {
        if (shallow === void 0) { shallow = false; }
        if (mock === void 0) { mock = false; }
        return _super.call(this, value, shallow, mock) || this;
    }
    ArrayObserver.prototype.ensureObservable = function () {
        if (this._observable === true) {
            return;
        }
        this.value.changed.subscribe(this._onChange.bind(this));
        this._observable = true;
    };
    ArrayObserver.prototype._onChange = function () {
        this.dep.notify();
    };
    return ArrayObserver;
}(custom_observer_1.CustomObserver));
exports.ArrayObserver = ArrayObserver;


/***/ }),

/***/ "../../libs/vuemodel/lib/custom-observer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomObserver = void 0;
var vue_model_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model.js");
var helpers_1 = __webpack_require__("../../libs/vuemodel/lib/helpers.js");
var vue_model_observability_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model-observability.js");
var model_js_1 = __webpack_require__("../../libs/model.js/lib/index.js");
var VueInternals = vue_model_1.VueModel._VueInternals;
if (!VueInternals.Observer) {
    throw new Error("Vue's Observer constructor has not yet been obtained, be sure to call Vue.use(VueModel).");
}
var Observer = VueInternals.Observer;
/**
 * A subclass of Vue's internal Observer class that is responsible
 * for managing its own access/change events for properties rather than
 * walking the object's own properties
 */
var CustomObserver = /** @class */ (function (_super) {
    __extends(CustomObserver, _super);
    function CustomObserver(value, shallow, mock) {
        if (shallow === void 0) { shallow = false; }
        if (mock === void 0) { mock = false; }
        var _this = _super.call(this, value, shallow, mock) || this;
        _this.propertyDeps = {};
        return _this;
    }
    /**
     * Gets (or creates) a `Dep` object for a property of the given name
     * The `Dep` object will be stored internally by the observer, using
     * the given target property name as a key
     * @param propertyName The target property name
     * @param create If true, create the `Dep` object if it doesn't already exist
     */
    CustomObserver.prototype.getPropertyDep = function (propertyName, create) {
        if (create === void 0) { create = false; }
        var propertyDep;
        var Dep = VueInternals.Dep;
        var propertyDeps = this.propertyDeps;
        if ((0, helpers_1.hasOwnProperty)(propertyDeps, propertyName) && propertyDeps[propertyName] instanceof Dep) {
            propertyDep = propertyDeps[propertyName];
        }
        else if (create) {
            propertyDep = new Dep();
            Object.defineProperty(propertyDeps, propertyName, {
                configurable: true,
                enumerable: true,
                value: propertyDep,
                writable: true
            });
        }
        return propertyDep;
    };
    /**
     * Emulate's Vue's getter logic in `defineReactive()`
     * @param propertyName The property being accessed
     * @param value The current property value
     */
    CustomObserver.prototype.onPropertyAccess = function (propertyName, value) {
        var Dep = VueInternals.Dep;
        // Attach dependencies if something is watching
        if (Dep.target) {
            // Get or initialize the `Dep` object
            var propertyDep = this.getPropertyDep(propertyName, true);
            // Let an active observer target know that the property was accessed and is a dependency
            propertyDep.depend();
            var childOb = (0, vue_model_observability_1.observeEntity)(value);
            if (childOb) {
                childOb.dep.depend();
            }
            if (Array.isArray(value)) {
                // Track dependency on children as well (creating entity observer as needed)
                (0, vue_model_observability_1.dependChildArray)(value);
            }
        }
    };
    /**
     * Emulate's Vue's setter logic in `defineReactive()`
     * @param propertyName The property being accessed
     * @param newValue The new property value
     */
    CustomObserver.prototype.onPropertyChange = function (propertyName, newValue) {
        // Get or initialize the `Dep` object
        var propertyDep = this.getPropertyDep(propertyName, true);
        // Make sure a new value that is an entity is observable
        if (newValue && newValue instanceof model_js_1.Entity) {
            (0, vue_model_observability_1.observeEntity)(newValue).ensureObservable();
        }
        // Notify of property change
        propertyDep.notify();
    };
    return CustomObserver;
}(Observer));
exports.CustomObserver = CustomObserver;


/***/ }),

/***/ "../../libs/vuemodel/lib/entity-observer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityObserver = void 0;
var custom_observer_1 = __webpack_require__("../../libs/vuemodel/lib/custom-observer.js");
var vue_model_observability_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model-observability.js");
/**
 * A subclass of Vue's internal `Observer` class for entities, which uses model
 * metadata to manage property access/change rather than property walking and rewriting
 */
var EntityObserver = /** @class */ (function (_super) {
    __extends(EntityObserver, _super);
    function EntityObserver(value, shallow, mock) {
        if (shallow === void 0) { shallow = false; }
        if (mock === void 0) { mock = false; }
        return _super.call(this, value, shallow, mock) || this;
    }
    EntityObserver.prototype.ensureObservable = function () {
        if (this._observable === true) {
            return;
        }
        this.value.accessed.subscribe(this._onAccess.bind(this));
        this.value.changed.subscribe(this._onChange.bind(this));
        if (this.value.meta) {
            (0, vue_model_observability_1.getObjectMetaObserver)(this.value.meta).ensureObservable();
        }
        this._observable = true;
    };
    EntityObserver.prototype._onAccess = function (args) {
        // Get the current property value
        var value = args.entity.__fields__[args.property.name];
        // Notify interested observers of the property access in order to track dependencies
        this.onPropertyAccess(args.property.name, value);
    };
    EntityObserver.prototype._onChange = function (args) {
        // Get the current property value
        var newValue = args.entity.__fields__[args.property.name];
        // Notify interested observers of the property change
        this.onPropertyChange(args.property.name, newValue);
    };
    return EntityObserver;
}(custom_observer_1.CustomObserver));
exports.EntityObserver = EntityObserver;


/***/ }),

/***/ "../../libs/vuemodel/lib/helpers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.debug = exports.hasOwnProperty = exports.setProp = exports.getProp = exports.isEntity = void 0;
var model_js_1 = __webpack_require__("../../libs/model.js/lib/index.js");
function isEntity(obj) {
    return obj && obj.meta && obj.meta.type && obj.meta.type.jstype && (0, model_js_1.isEntityType)(obj.meta.type.jstype);
}
exports.isEntity = isEntity;
function getProp(obj, prop) {
    return obj[prop];
}
exports.getProp = getProp;
function setProp(target, key, value) {
    target[key] = value;
}
exports.setProp = setProp;
var hasOwnPropertyFn = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, prop) {
    return hasOwnPropertyFn.call(obj, prop);
}
exports.hasOwnProperty = hasOwnProperty;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function debug(message) {
    // console.log("%c[DEBUG] " + message, "background-color: #efefef; color: #999;");
}
exports.debug = debug;


/***/ }),

/***/ "../../libs/vuemodel/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.preventVueObservability = exports.isSourceAdapter = void 0;
var vue_model_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model.js");
// Include English resources by default
__webpack_require__("../../libs/model.js/lib/resource-en.js");
exports.default = vue_model_1.VueModel;
var source_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-adapter.js");
Object.defineProperty(exports, "isSourceAdapter", { enumerable: true, get: function () { return source_adapter_1.isSourceAdapter; } });
var vue_model_observability_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model-observability.js");
Object.defineProperty(exports, "preventVueObservability", { enumerable: true, get: function () { return vue_model_observability_1.preventVueObservability; } });


/***/ }),

/***/ "../../libs/vuemodel/lib/object-meta-observer.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectMetaObserver = void 0;
var custom_observer_1 = __webpack_require__("../../libs/vuemodel/lib/custom-observer.js");
/**
 * A subclass of Vue's internal `Observer` class for entity meta objects, which uses model
 * metadata to manage condition change rather than property walking and rewriting
 */
var ObjectMetaObserver = /** @class */ (function (_super) {
    __extends(ObjectMetaObserver, _super);
    function ObjectMetaObserver(value, shallow, mock) {
        if (shallow === void 0) { shallow = false; }
        if (mock === void 0) { mock = false; }
        return _super.call(this, value, shallow, mock) || this;
    }
    ObjectMetaObserver.prototype.ensureObservable = function () {
        if (this._observable === true) {
            return;
        }
        this.value.conditions.changed.subscribe(this._onConditionsChanged.bind(this));
        this._observable = true;
    };
    ObjectMetaObserver.prototype._onConditionsChanged = function () {
        // Notify interested observers of the condition change in order to update dependants
        this.onPropertyChange("conditions", null);
    };
    return ObjectMetaObserver;
}(custom_observer_1.CustomObserver));
exports.ObjectMetaObserver = ObjectMetaObserver;


/***/ }),

/***/ "../../libs/vuemodel/lib/source-adapter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.hasOverrideValue = exports.isSourcePropertyAdapter = exports.isSourceAdapter = exports.isSourceItemAdapter = exports.isSourcePathAdapter = exports.isSourceRootAdapter = void 0;
var source_root_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-root-adapter.js");
var source_path_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-path-adapter.js");
var source_item_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-item-adapter.js");
function isSourceRootAdapter(obj) {
    return obj instanceof source_root_adapter_1.SourceRootAdapter;
}
exports.isSourceRootAdapter = isSourceRootAdapter;
function isSourcePathAdapter(obj) {
    return obj instanceof source_path_adapter_1.SourcePathAdapter;
}
exports.isSourcePathAdapter = isSourcePathAdapter;
function isSourceItemAdapter(obj) {
    return obj instanceof source_item_adapter_1.SourceItemAdapter;
}
exports.isSourceItemAdapter = isSourceItemAdapter;
function isSourceAdapter(obj, allowAnyObject) {
    if (allowAnyObject === void 0) { allowAnyObject = true; }
    if (isSourceRootAdapter(obj))
        return true;
    if (isSourcePathAdapter(obj))
        return true;
    if (isSourceItemAdapter(obj))
        return true;
    if (allowAnyObject && typeof obj === "object")
        return true;
    return false;
}
exports.isSourceAdapter = isSourceAdapter;
function isSourcePropertyAdapter(obj) {
    if (isSourcePathAdapter(obj))
        return true;
    return false;
}
exports.isSourcePropertyAdapter = isSourcePropertyAdapter;
function hasOverrideValue(value, type) {
    if (type === String) {
        return typeof value === "string" && value.length > 0;
    }
    else if (type === Boolean) {
        return typeof value === "boolean";
    }
}
exports.hasOverrideValue = hasOverrideValue;


/***/ }),

/***/ "../../libs/vuemodel/lib/source-item-adapter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceItemAdapter = void 0;
var vue_1 = __importDefault(__webpack_require__("vue"));
var vue_property_decorator_1 = __webpack_require__("../../node_modules/.pnpm/vue-property-decorator@7.3.0/node_modules/vue-property-decorator/lib/vue-property-decorator.js");
var source_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-adapter.js");
var model_js_1 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var helpers_1 = __webpack_require__("../../libs/vuemodel/lib/helpers.js");
// @ts-ignore
var SourceItemAdapter = /** @class */ (function (_super) {
    __extends(SourceItemAdapter, _super);
    function SourceItemAdapter() {
        var _this_1 = _super !== null && _super.apply(this, arguments) || this;
        _this_1.isOrphaned = false;
        _this_1.internalIndex = -1;
        _this_1.isSubscribedToSourceChanges = false;
        return _this_1;
    }
    SourceItemAdapter.prototype.created = function () {
        // Track the intial index internally
        this.internalIndex = this.index;
        // Track changes to the list and update the component's state appropriately
        if (!this.suppressChangeTracking) {
            this.subscribeToSourceChanges();
        }
    };
    SourceItemAdapter.prototype.onIndexChanged = function (index) {
        this.internalIndex = index;
    };
    Object.defineProperty(SourceItemAdapter.prototype, "parent", {
        get: function () {
            if ((0, source_adapter_1.isSourceAdapter)(this.parentSource)) {
                return this.parentSource;
            }
            for (var parentVm = this.$parent.$parent, parentLevel = 1; parentVm != null; parentVm = parentVm.$parent, parentLevel += 1) {
                if ((0, source_adapter_1.isSourceAdapter)(parentVm.$source)) {
                    return parentVm.$source;
                }
            }
            throw new Error("Parent source not found!");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceItemAdapter.prototype, "readonly", {
        /**
         *  Indicants whether the source property is readonly.
         *
         *  @returns True if either the parent source or the source override is read only, otherwise false
         */
        get: function () {
            return this.parent.readonly || (this.overrides ? this.overrides.readonly : false);
        },
        enumerable: false,
        configurable: true
    });
    SourceItemAdapter.prototype.subscribeToSourceChanges = function () {
        if (this.isSubscribedToSourceChanges) {
            return;
        }
        var _this = this;
        var array = model_js_1.ObservableArray.ensureObservable(this.parent.value);
        array.changed.subscribe(function (args) {
            var index = _this.internalIndex;
            var isOrphaned = _this.isOrphaned;
            args.changes.forEach(function (c) {
                if (c.type === model_js_1.ArrayChangeType.remove) {
                    if (c.startIndex === index) {
                        index = -1;
                        isOrphaned = true;
                    }
                    else if (c.startIndex < index) {
                        if (c.items.length > index - c.startIndex) {
                            index = -1;
                            isOrphaned = true;
                        }
                        else {
                            index -= c.items.length;
                        }
                    }
                }
                else if (c.type === model_js_1.ArrayChangeType.add) {
                    if (c.startIndex >= 0) {
                        if (c.startIndex <= index) {
                            index += c.items.length;
                        }
                    }
                }
            });
            if (isOrphaned !== _this.isOrphaned) {
                vue_1.default.set(_this, "isOrphaned", isOrphaned);
            }
            if (index !== _this.internalIndex) {
                vue_1.default.set(_this, "internalIndex", index);
            }
        });
        this.isSubscribedToSourceChanges = true;
    };
    Object.defineProperty(SourceItemAdapter.prototype, "value", {
        get: function () {
            var list = this.parent.value;
            var value = list[this.internalIndex];
            return value;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceItemAdapter.prototype, "type", {
        get: function () {
            // If possible, determine the type based on the actual entity instance
            if (this.value && (0, helpers_1.isEntity)(this.value))
                return this.value.meta.type.jstype;
            return this.parent.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceItemAdapter.prototype, "isList", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceItemAdapter.prototype, "displayValue", {
        get: function () {
            var list = this.parent.value;
            var value = list[this.internalIndex];
            var displayValue;
            if ((0, source_adapter_1.isSourcePropertyAdapter)(this.parent) && this.parent.property.format != null) {
                // Use a markup or property format if available
                displayValue = this.parent.property.format.convert(value);
            }
            else {
                displayValue = value.toString();
            }
            return displayValue;
        },
        enumerable: false,
        configurable: true
    });
    SourceItemAdapter.prototype.toString = function () {
        return "Source[" + this.internalIndex + "]";
    };
    __decorate([
        (0, vue_property_decorator_1.Prop)(Number),
        __metadata("design:type", Number)
    ], SourceItemAdapter.prototype, "index", void 0);
    __decorate([
        (0, vue_property_decorator_1.Prop)(Object),
        __metadata("design:type", Object)
    ], SourceItemAdapter.prototype, "parentSource", void 0);
    __decorate([
        (0, vue_property_decorator_1.Prop)(Object),
        __metadata("design:type", Object)
    ], SourceItemAdapter.prototype, "overrides", void 0);
    __decorate([
        (0, vue_property_decorator_1.Prop)({ type: Boolean, default: false }),
        __metadata("design:type", Boolean)
    ], SourceItemAdapter.prototype, "suppressChangeTracking", void 0);
    __decorate([
        (0, vue_property_decorator_1.Watch)("index"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number]),
        __metadata("design:returntype", void 0)
    ], SourceItemAdapter.prototype, "onIndexChanged", null);
    SourceItemAdapter = __decorate([
        vue_property_decorator_1.Component
    ], SourceItemAdapter);
    return SourceItemAdapter;
}(vue_1.default));
exports.SourceItemAdapter = SourceItemAdapter;


/***/ }),

/***/ "../../libs/vuemodel/lib/source-option-adapter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceOptionAdapter = void 0;
var vue_1 = __importDefault(__webpack_require__("vue"));
var vue_property_decorator_1 = __webpack_require__("../../node_modules/.pnpm/vue-property-decorator@7.3.0/node_modules/vue-property-decorator/lib/vue-property-decorator.js");
var source_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-adapter.js");
var source_path_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-path-adapter.js");
// @ts-ignore
var SourceOptionAdapter = /** @class */ (function (_super) {
    __extends(SourceOptionAdapter, _super);
    function SourceOptionAdapter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(SourceOptionAdapter.prototype, "parent", {
        get: function () {
            for (var parentVm = this.$parent.$parent, parentLevel = 1; parentVm != null; parentVm = parentVm.$parent, parentLevel += 1) {
                if ((0, source_adapter_1.isSourcePropertyAdapter)(parentVm.$source)) {
                    return parentVm.$source;
                }
            }
            throw new Error("Parent source not found!");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceOptionAdapter.prototype, "label", {
        get: function () {
            return this.parent.label;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceOptionAdapter.prototype, "displayValue", {
        get: function () {
            return (0, source_path_adapter_1.formatDisplayValue)(this.parent, this.value);
        },
        enumerable: false,
        configurable: true
    });
    SourceOptionAdapter.prototype.toString = function () {
        return "Option for Source['" + this.parent.property.path + "']";
    };
    __decorate([
        (0, vue_property_decorator_1.Prop)(),
        __metadata("design:type", Object)
    ], SourceOptionAdapter.prototype, "value", void 0);
    SourceOptionAdapter = __decorate([
        vue_property_decorator_1.Component
    ], SourceOptionAdapter);
    return SourceOptionAdapter;
}(vue_1.default));
exports.SourceOptionAdapter = SourceOptionAdapter;


/***/ }),

/***/ "../../libs/vuemodel/lib/source-path-adapter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatDisplayValue = exports.SourcePathAdapter = void 0;
var vue_1 = __importDefault(__webpack_require__("vue"));
var vue_property_decorator_1 = __webpack_require__("../../node_modules/.pnpm/vue-property-decorator@7.3.0/node_modules/vue-property-decorator/lib/vue-property-decorator.js");
var model_js_1 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var model_js_2 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var source_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-adapter.js");
var source_option_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-option-adapter.js");
var model_js_3 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var vue_model_observability_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model-observability.js");
var model_js_4 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var model_js_5 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var source_item_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-item-adapter.js");
var model_js_6 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var model_js_7 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var helpers_1 = __webpack_require__("../../libs/vuemodel/lib/helpers.js");
var _id = 0;
// @ts-ignore
var SourcePathAdapter = /** @class */ (function (_super) {
    __extends(SourcePathAdapter, _super);
    function SourcePathAdapter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // viewState: { formatError: ConditionTarget } = { formatError: null };
        // formatError: FormatError = null;
        _this.formatErrorCondition = null;
        _this.id = "".concat(_id++);
        return _this;
    }
    Object.defineProperty(SourcePathAdapter.prototype, "parent", {
        get: function () {
            for (var parentVm = this.$parent.$parent, parentLevel = 1; parentVm != null; parentVm = parentVm.$parent, parentLevel += 1) {
                if ((0, source_adapter_1.isSourceAdapter)(parentVm.$source)) {
                    return parentVm.$source;
                }
            }
            throw new Error("Parent source not found!");
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "property", {
        get: function () {
            var property = this.parent.type.meta.getPath(this.source);
            (0, vue_model_observability_1.preventVueObservability)(property);
            return property;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "type", {
        get: function () {
            // If possible, determine the type based on the actual entity instance
            if (this.value && (0, helpers_1.isEntity)(this.value))
                return this.value.meta.type.jstype;
            return this.property.propertyType;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "isList", {
        get: function () {
            return this.property.isList;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "lastTarget", {
        get: function () {
            var property = this.property;
            return property.getLastTarget(this.parent.value);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "label", {
        /**
         *  Gets the label for the source property.
         *
         *  @returns The source override label if specified, or the model property label if not
         */
        get: function () {
            var label = this.overrides ? this.overrides.label : null;
            if (label === undefined || label === null) {
                if (this.property.labelIsFormat) {
                    label = (0, model_js_2.evaluateLabel)(this.property, this.parent.value);
                }
                else {
                    label = this.property.label;
                }
            }
            return label;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "helptext", {
        /**
         *  Gets the helptext for the source property.
         *
         *  @returns The source override helptext if specified, or the model property helptext if not
         */
        get: function () {
            var helptext = this.overrides ? this.overrides.helptext : null;
            if (helptext === undefined || helptext === null) {
                if (this.property.helptextIsFormat) {
                    helptext = this.parent.value.toString(this.property.helptext);
                }
                else {
                    helptext = this.property.helptext;
                }
            }
            return helptext;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "readonly", {
        /**
         *  Indicants whether the source property is readonly.
         *
         *  @returns True if either the parent source or the source override is read only, otherwise false
         */
        get: function () {
            return this.parent.readonly || (this.overrides ? !!this.overrides.readonly : false);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "required", {
        /**
        *  Indicants whether the source property is required.
        *
        *  @returns True if the property is required, otherwise false
        */
        get: function () {
            if (this.overrides && this.overrides.required != null)
                return this.overrides.required;
            if ((0, model_js_2.isPropertyBooleanFunctionAndOptions)(this.property.required)) {
                if ((0, model_js_2.isPropertyBooleanFunction)(this.property.required.function)) {
                    return this.property.required.function.call(this.parent.value);
                }
                else {
                    return true;
                }
            }
            if ((0, model_js_2.isPropertyBooleanFunction)(this.property.required))
                return this.property.required.call(this.parent.value);
            return this.property.required === true;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "value", {
        /**
         *  Gets the value of the source property on the entity.
         *
         *  @returns The observable raw value of the property
         */
        get: function () {
            // This adapter has no value if its parent has no value
            if (!this.parent.value)
                return;
            return this.ensureObservable(this.property.value(this.parent.value));
        },
        /**
         *  Sets the value of the source property on the entity.
         *
         *  @param value - The new value to assign to the property
         */
        set: function (value) {
            if (this.property.isList) {
                var valueArray_1 = value;
                var observableArray_1 = this.property.value(this.parent.value);
                observableArray_1.batchUpdate(function () { return (0, model_js_5.updateArray)(observableArray_1, valueArray_1); });
            }
            else {
                this.property.value(this.parent.value, this.ensureObservable(value));
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "conditions", {
        get: function () {
            var _this = this;
            var meta = this.parent.value.meta;
            var metaOb = (0, vue_model_observability_1.getObjectMetaObserver)(meta);
            // Make sure that the meta object is observable, ex: subscribes to conditions array changed
            metaOb.ensureObservable();
            var conditionTargets = meta.conditions;
            conditionTargets.forEach(function (condition) { (0, vue_model_observability_1.preventVueObservability)(condition); });
            // Raise property access to let Vue know that array was accessed
            // Changes to conditions will result in a Vue change notification for the 'conditions' property
            metaOb.onPropertyAccess("conditions", conditionTargets);
            var formatErrorConditions = this.formatErrorCondition ? [this.formatErrorCondition] : [];
            var property = this.property instanceof model_js_2.Property ? this.property : this.property instanceof model_js_4.PropertyChain ? this.property.lastProperty : null;
            if (!property)
                return formatErrorConditions;
            var conditions = conditionTargets.filter(function (c) { return c.properties.indexOf(property) >= 0; }).map(function (conditionTarget) {
                return conditionTarget.condition;
            });
            conditions = conditions.concat(formatErrorConditions);
            conditions = conditions.sort(function (conditionA, conditionB) {
                return _this.compare(conditionA, conditionB);
            });
            return conditions;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "formatError", {
        get: function () {
            return this.formatErrorCondition ? this.formatErrorCondition["formatError"] : null;
        },
        set: function (err) {
            if (err) {
                (0, vue_model_observability_1.preventVueObservability)(err);
                var formatErrorCondition = err.createCondition(this.property.getLastTarget(this.parent.value), this.property.lastProperty);
                (0, vue_model_observability_1.preventVueObservability)(formatErrorCondition);
                formatErrorCondition["formatError"] = err;
                this.formatErrorCondition = formatErrorCondition;
            }
            else {
                this.formatErrorCondition = null;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "invalidValue", {
        get: function () {
            if (this.formatError) {
                return this.formatError.invalidValue;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "firstError", {
        get: function () {
            return this.conditions.length ? this.conditions[0] : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "displayValue", {
        get: function () {
            if (this.formatError) {
                return this.formatError.invalidValue;
            }
            var value = this.ensureObservable(this.property.value(this.parent.value));
            return formatDisplayValue(this, value);
        },
        set: function (text) {
            if ((0, model_js_6.isEntityType)(this.property.propertyType)) {
                throw new Error("Cannot set displayValue property of Adapters for entity types.");
            }
            /// / TODO: Implement auto-reformat?
            // var initialValue = text;
            var newValue;
            var formatter;
            if (this.property.format != null) {
                formatter = this.property.format;
            }
            else if ((0, model_js_6.isValueType)(this.property.propertyType) && this.property.propertyType !== String) {
                // Try to use the general format by default
                formatter = this.property.containingType.model.getFormat(this.property.propertyType, "G");
            }
            if (this.formatError) {
                this.parent.value.meta.clearCondition(model_js_7.FormatError.ConditionType); // TODO: This shouldn't do anything...
                this.formatError = null;
            }
            if (formatter) {
                newValue = formatter.convertBack(text);
                if (newValue instanceof model_js_7.FormatError) {
                    (0, vue_model_observability_1.preventVueObservability)(newValue);
                    this.formatError = newValue;
                    return;
                }
            }
            else if (this.property.propertyType === String && typeof text === "string" && text.length === 0) {
                // Convert blank string to null
                newValue = null;
            }
            else {
                newValue = text;
            }
            this.value = newValue;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "allowedValuesRule", {
        get: function () {
            var property;
            if (this.property instanceof model_js_4.PropertyChain) {
                property = this.property.lastProperty;
            }
            else if (this.property instanceof model_js_2.Property) {
                property = this.property;
            }
            var allowedValuesRules = property.rules.filter(function (r) { return r instanceof model_js_3.AllowedValuesRule; });
            if (allowedValuesRules.length) {
                var allowedValuesRule = allowedValuesRules[0];
                (0, vue_model_observability_1.preventVueObservability)(allowedValuesRule);
                return allowedValuesRule;
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "allowedValues", {
        get: function () {
            var allowedValuesRule = this.allowedValuesRule;
            if (!allowedValuesRule) {
                // If there is no rule, return an empty list
                return;
            }
            var targetObj;
            if (this.property instanceof model_js_4.PropertyChain) {
                targetObj = this.property.getLastTarget(this.parent.value);
            }
            else {
                targetObj = this.parent.value;
            }
            // Retrieve the value of allowed values property
            var allowedValuesFromRule = allowedValuesRule.values(targetObj);
            if (allowedValuesFromRule) {
                // Clear our values that are no longer valid
                if (!allowedValuesRule.ignoreValidation) {
                    this.clearInvalidOptions(allowedValuesFromRule);
                }
            }
            else if (!allowedValuesRule.ignoreValidation) {
                // Clear out values since the property doesn't currently have any allowed values
                this.clearInvalidOptions(null);
            }
            allowedValuesFromRule.forEach(function (value) {
                if (value instanceof model_js_1.Entity) {
                    (0, vue_model_observability_1.observeEntity)(value).ensureObservable();
                }
                else if (typeof value === "object") {
                    (0, vue_model_observability_1.preventVueObservability)(value);
                }
            });
            return allowedValuesFromRule;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "options", {
        get: function () {
            var _this = this;
            // Destroy existing option components
            var optionsToDestroy = this.$children.filter(function (c) { return c instanceof source_option_adapter_1.SourceOptionAdapter; });
            optionsToDestroy.forEach(function (c) { return c.$destroy(); });
            // TODO: preserve option adapters if possible?
            var allowedValues = this.allowedValues;
            if (!allowedValues && this.property.propertyType === Boolean) {
                // Provide true and false as special allowed values for booleans
                allowedValues = [true, false];
            }
            if (!allowedValues) {
                return [];
            }
            // Map the allowed values to option adapters
            return allowedValues.map(function (v) { return new source_option_adapter_1.SourceOptionAdapter({ parent: _this, propsData: { value: v } }); });
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourcePathAdapter.prototype, "items", {
        get: function () {
            var items = [];
            // Collect existing option components to potentially be destroyed
            var existingItemsToDestroy = this.$children.filter(function (c) { return c instanceof source_item_adapter_1.SourceItemAdapter; });
            var value = this.value;
            if (Array.isArray(value)) {
                if ((0, model_js_6.isEntityType)(this.property.propertyType)) {
                    var existingItemsMap_1 = {};
                    existingItemsToDestroy.forEach(function (c) {
                        var adapter = c;
                        if (!adapter.isOrphaned) {
                            var key = adapter.value ? adapter.value.meta.id : null;
                            if (key) {
                                existingItemsMap_1[key] = adapter;
                            }
                        }
                    });
                    for (var i = 0; i < value.length; i++) {
                        var key = value[i].meta.id;
                        var existingItem = existingItemsMap_1[key];
                        if (existingItem) {
                            // Delete the existing item from the map so that it can't be fetched more than once
                            delete existingItemsMap_1[key];
                            // Remove the component from the list of items to destroy since we're going to reuse it
                            var existingItemIndex = existingItemsToDestroy.indexOf(existingItem);
                            if (existingItemIndex >= 0) {
                                existingItemsToDestroy.splice(existingItemIndex, 1);
                            }
                            // Set the backing storage for the 'index' prop, the internal data should
                            // already have this value, this just makes the component's state consistent,
                            // since the inconsistency is just a side-effect of reusing item adapters
                            var propsData = existingItem.$options.propsData;
                            propsData.index = i;
                            // Include the existing item in the return value
                            items.push(existingItem);
                        }
                        else {
                            // Create a new item adapter
                            var newItem = new source_item_adapter_1.SourceItemAdapter({ parent: this, propsData: { index: i, parentSource: this } });
                            // Subscribes to changes to its underlying list source in order to update its index and detect when it becomes orphaned
                            newItem.subscribeToSourceChanges();
                            // Include the new item in the return value
                            items.push(newItem);
                        }
                    }
                }
            }
            existingItemsToDestroy.forEach(function (c) { return c.$destroy(); });
            return items;
        },
        enumerable: false,
        configurable: true
    });
    SourcePathAdapter.prototype.compare = function (conditionTargetA, conditionTargetB) {
        if (conditionTargetA["formatError"] instanceof model_js_7.FormatError || conditionTargetB["formatError"] instanceof model_js_7.FormatError) {
            return conditionTargetA["formatError"] instanceof model_js_7.FormatError && conditionTargetB["formatError"] instanceof model_js_7.FormatError ? 0 :
                conditionTargetA["formatError"] instanceof model_js_7.FormatError ? -1 : 1;
        }
        else if (conditionTargetA["source"] instanceof model_js_1.RequiredRule || conditionTargetB["source"] instanceof model_js_1.RequiredRule)
            return conditionTargetA["source"] instanceof model_js_1.RequiredRule && conditionTargetB["source"] instanceof model_js_1.RequiredRule ? 0 :
                conditionTargetA["source"] instanceof model_js_1.RequiredRule ? -1 : 1;
        else if (conditionTargetA.type.category === "Error" || conditionTargetB.type.category === "Error")
            return conditionTargetA.type.category === "Error" && conditionTargetB.type.category === "Error" ? 0 :
                conditionTargetA.type.category === "Error" ? -1 : 1;
        else
            return 0;
    };
    SourcePathAdapter.prototype.clearInvalidOptions = function (allowedValues) {
        var property = this.property;
        var value = this.value;
        if (allowedValues) {
            // Remove option values that are no longer valid
            if (value instanceof Array) {
                var array = value;
                array.batchUpdate(function (array) {
                    // From the `purge()` function in ExoWeb...
                    for (var i = 0; i < array.length; i++) {
                        var item = array[i];
                        if (allowedValues.indexOf(item) < 0) {
                            array.splice(i--, 1);
                        }
                    }
                });
            }
            else if (value !== null && allowedValues.indexOf(value) < 0) {
                property.value(this.parent.value, null);
            }
        }
        else if (value instanceof Array) {
            value.splice(0, value.length);
        }
        else if (value !== null) {
            property.value(this.parent.value, null);
        }
    };
    SourcePathAdapter.prototype.ensureObservable = function (value) {
        if (Array.isArray(value)) {
            if (model_js_5.ObservableArray.isObservableArray(value)) {
                (0, vue_model_observability_1.observeArray)(value).ensureObservable();
            }
            for (var i = 0; i < value.length; i++) {
                var item = value[i];
                if (item instanceof model_js_1.Entity) {
                    (0, vue_model_observability_1.observeEntity)(item).ensureObservable();
                }
            }
        }
        else if (value instanceof model_js_1.Entity) {
            (0, vue_model_observability_1.observeEntity)(value).ensureObservable();
        }
        return value;
    };
    SourcePathAdapter.prototype.toString = function () {
        return "Source['" + this.source + "']";
    };
    __decorate([
        (0, vue_property_decorator_1.Prop)(String),
        __metadata("design:type", String)
    ], SourcePathAdapter.prototype, "source", void 0);
    __decorate([
        (0, vue_property_decorator_1.Prop)(Object),
        __metadata("design:type", Object)
    ], SourcePathAdapter.prototype, "overrides", void 0);
    SourcePathAdapter = __decorate([
        vue_property_decorator_1.Component
    ], SourcePathAdapter);
    return SourcePathAdapter;
}(vue_1.default));
exports.SourcePathAdapter = SourcePathAdapter;
function formatDisplayValue(adapter, value) {
    var displayValue;
    var property = adapter.property;
    if (value === null || value === undefined) {
        displayValue = "";
    }
    else if (property.format != null) {
        // Use a markup or property format if available
        if (Array.isArray(value)) {
            var array = value;
            displayValue = array.map(function (item) { return property.format.convert(item); });
        }
        else {
            displayValue = property.format.convert(value);
        }
    }
    else if (Array.isArray(value)) {
        // If no format exists, then fall back to toString
        var array = value;
        displayValue = array.map(function (item) {
            if (value === null || value === undefined) {
                return "";
            }
            else {
                return item.toString();
            }
        });
    }
    else {
        displayValue = value.toString();
    }
    displayValue = Array.isArray(displayValue) ? displayValue.join(", ") : displayValue;
    return displayValue;
}
exports.formatDisplayValue = formatDisplayValue;


/***/ }),

/***/ "../../libs/vuemodel/lib/source-path-mixin.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourcePathMixin = void 0;
var vue_1 = __importDefault(__webpack_require__("vue"));
var vue_property_decorator_1 = __webpack_require__("../../node_modules/.pnpm/vue-property-decorator@7.3.0/node_modules/vue-property-decorator/lib/vue-property-decorator.js");
var source_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-adapter.js");
var source_path_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-path-adapter.js");
// @ts-ignore
var SourcePathMixin = /** @class */ (function (_super) {
    __extends(SourcePathMixin, _super);
    function SourcePathMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SourcePathMixin.prototype.onLabelChanged = function (label) {
        this.onOverrideValueChanged(label, String);
    };
    SourcePathMixin.prototype.onHelptextChanged = function (helptext) {
        this.onOverrideValueChanged(helptext, String);
    };
    SourcePathMixin.prototype.onReadonlyChanged = function (readonly) {
        this.onOverrideValueChanged(readonly, Boolean);
    };
    SourcePathMixin.prototype.onRequiredChanged = function (required) {
        this.onOverrideValueChanged(required, Boolean);
    };
    Object.defineProperty(SourcePathMixin.prototype, "$source", {
        get: function () {
            // If the source is an adapter, then potentially apply overrides, and return it
            if ((0, source_adapter_1.isSourceAdapter)(this.source)) {
                this.ensureOverridesAppliedToSourceAdapter(this.source);
                return this.source;
            }
            return new source_path_adapter_1.SourcePathAdapter({ parent: this, propsData: { source: this.source, overrides: this } });
        },
        enumerable: false,
        configurable: true
    });
    SourcePathMixin.prototype.ensureOverridesAppliedToSourceAdapter = function (source) {
        var hasOverrides = (0, source_adapter_1.hasOverrideValue)(this.label, String) || (0, source_adapter_1.hasOverrideValue)(this.helptext, String) || (0, source_adapter_1.hasOverrideValue)(this.readonly, Boolean) || (0, source_adapter_1.hasOverrideValue)(this.required, Boolean);
        if ((0, source_adapter_1.isSourcePathAdapter)(source)) {
            if (hasOverrides) {
                if (source.overrides && source.overrides !== this) {
                    throw new Error("Overrides have already been applied to source of type '" + source.constructor.name + "'.");
                }
                // Apply the given overrides as the overrides for the source
                source.overrides = this;
            }
        }
        else {
            if (hasOverrides) {
                throw new Error("Cannot apply overrides to source of type '" + source.constructor.name + "'.");
            }
        }
    };
    SourcePathMixin.prototype.onOverrideValueChanged = function (value, type) {
        // If the source is an adapter, and an override value is set, then ensure that the
        if ((0, source_adapter_1.isSourceAdapter)(this.source) && (0, source_adapter_1.hasOverrideValue)(value, type)) {
            this.ensureOverridesAppliedToSourceAdapter(this.source);
        }
    };
    __decorate([
        (0, vue_property_decorator_1.Prop)({ type: [String, Object] }),
        __metadata("design:type", Object)
    ], SourcePathMixin.prototype, "source", void 0);
    __decorate([
        (0, vue_property_decorator_1.Prop)(String),
        __metadata("design:type", String)
    ], SourcePathMixin.prototype, "label", void 0);
    __decorate([
        (0, vue_property_decorator_1.Watch)("label"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], SourcePathMixin.prototype, "onLabelChanged", null);
    __decorate([
        (0, vue_property_decorator_1.Prop)(String),
        __metadata("design:type", String)
    ], SourcePathMixin.prototype, "helptext", void 0);
    __decorate([
        (0, vue_property_decorator_1.Watch)("helptext"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [String]),
        __metadata("design:returntype", void 0)
    ], SourcePathMixin.prototype, "onHelptextChanged", null);
    __decorate([
        (0, vue_property_decorator_1.Prop)({ type: Boolean, default: null }),
        __metadata("design:type", Boolean)
    ], SourcePathMixin.prototype, "readonly", void 0);
    __decorate([
        (0, vue_property_decorator_1.Watch)("readonly"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Boolean]),
        __metadata("design:returntype", void 0)
    ], SourcePathMixin.prototype, "onReadonlyChanged", null);
    __decorate([
        (0, vue_property_decorator_1.Prop)({ type: Boolean, default: null }),
        __metadata("design:type", Boolean)
    ], SourcePathMixin.prototype, "required", void 0);
    __decorate([
        (0, vue_property_decorator_1.Watch)("required"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Boolean]),
        __metadata("design:returntype", void 0)
    ], SourcePathMixin.prototype, "onRequiredChanged", null);
    SourcePathMixin = __decorate([
        vue_property_decorator_1.Component
    ], SourcePathMixin);
    return SourcePathMixin;
}(vue_1.default));
exports.SourcePathMixin = SourcePathMixin;


/***/ }),

/***/ "../../libs/vuemodel/lib/source-root-adapter.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceRootAdapter = void 0;
var vue_1 = __importDefault(__webpack_require__("vue"));
var vue_property_decorator_1 = __webpack_require__("../../node_modules/.pnpm/vue-property-decorator@7.3.0/node_modules/vue-property-decorator/lib/vue-property-decorator.js");
// @ts-ignore
var SourceRootAdapter = /** @class */ (function (_super) {
    __extends(SourceRootAdapter, _super);
    function SourceRootAdapter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.readonly = false;
        return _this;
    }
    Object.defineProperty(SourceRootAdapter.prototype, "value", {
        get: function () {
            return this.entity;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceRootAdapter.prototype, "type", {
        get: function () {
            return this.entity.meta.type.jstype;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceRootAdapter.prototype, "isList", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SourceRootAdapter.prototype, "displayValue", {
        get: function () {
            return this.entity.toString();
        },
        enumerable: false,
        configurable: true
    });
    SourceRootAdapter.prototype.toString = function () {
        return this.entity.meta.type.fullName + "|" + this.entity.meta.id;
    };
    __decorate([
        (0, vue_property_decorator_1.Prop)(Object),
        __metadata("design:type", Object)
    ], SourceRootAdapter.prototype, "entity", void 0);
    SourceRootAdapter = __decorate([
        vue_property_decorator_1.Component
    ], SourceRootAdapter);
    return SourceRootAdapter;
}(vue_1.default));
exports.SourceRootAdapter = SourceRootAdapter;


/***/ }),

/***/ "../../libs/vuemodel/lib/source-root-mixin.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceRootMixin = void 0;
var vue_1 = __importDefault(__webpack_require__("vue"));
var vue_property_decorator_1 = __webpack_require__("../../node_modules/.pnpm/vue-property-decorator@7.3.0/node_modules/vue-property-decorator/lib/vue-property-decorator.js");
var model_js_1 = __webpack_require__("../../libs/model.js/lib/index.js");
var source_root_adapter_1 = __webpack_require__("../../libs/vuemodel/lib/source-root-adapter.js");
var vue_model_observability_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model-observability.js");
// @ts-ignore
var SourceRootMixin = /** @class */ (function (_super) {
    __extends(SourceRootMixin, _super);
    function SourceRootMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SourceRootMixin.prototype.onReadonlyChanged = function (readonly) {
        this.$source.readonly = readonly;
    };
    Object.defineProperty(SourceRootMixin.prototype, "$source", {
        get: function () {
            var entity;
            if (this.source instanceof model_js_1.Entity) {
                entity = this.source;
            }
            else {
                entity = this[this.source || "entity"];
                if (!entity || !(entity instanceof model_js_1.Entity)) {
                    throw new Error("No entity data!");
                }
            }
            (0, vue_model_observability_1.observeEntity)(entity).ensureObservable();
            return new source_root_adapter_1.SourceRootAdapter({ parent: this, propsData: { entity: entity } });
        },
        enumerable: false,
        configurable: true
    });
    __decorate([
        (0, vue_property_decorator_1.Prop)({ type: [Object, String] }),
        __metadata("design:type", Object)
    ], SourceRootMixin.prototype, "source", void 0);
    __decorate([
        (0, vue_property_decorator_1.Prop)({ type: Boolean, default: null }),
        __metadata("design:type", Boolean)
    ], SourceRootMixin.prototype, "readonly", void 0);
    __decorate([
        (0, vue_property_decorator_1.Watch)("readonly"),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Boolean]),
        __metadata("design:returntype", void 0)
    ], SourceRootMixin.prototype, "onReadonlyChanged", null);
    SourceRootMixin = __decorate([
        vue_property_decorator_1.Component
    ], SourceRootMixin);
    return SourceRootMixin;
}(vue_1.default));
exports.SourceRootMixin = SourceRootMixin;


/***/ }),

/***/ "../../libs/vuemodel/lib/vm-root-component.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VMRoot = void 0;
var vue_property_decorator_1 = __webpack_require__("../../node_modules/.pnpm/vue-property-decorator@7.3.0/node_modules/vue-property-decorator/lib/vue-property-decorator.js");
var vue_class_component_1 = __webpack_require__("../../node_modules/.pnpm/vue-class-component@7.2.6_vue@2.7.15/node_modules/vue-class-component/dist/vue-class-component.esm.js");
var source_root_mixin_1 = __webpack_require__("../../libs/vuemodel/lib/source-root-mixin.js");
// @ts-ignore
var VMRoot = /** @class */ (function (_super) {
    __extends(VMRoot, _super);
    function VMRoot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    VMRoot.prototype.render = function () {
        var slotNodes = this.$scopedSlots.default({
            $source: this.$source
        });
        if (slotNodes.length !== 1) {
            throw new Error("Found " + slotNodes.length + " nodes in default slot for component 'vm-root'.");
        }
        return slotNodes[0];
    };
    VMRoot = __decorate([
        vue_property_decorator_1.Component
    ], VMRoot);
    return VMRoot;
}((0, vue_class_component_1.mixins)(source_root_mixin_1.SourceRootMixin)));
exports.VMRoot = VMRoot;


/***/ }),

/***/ "../../libs/vuemodel/lib/vm-source-component.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VMSource = void 0;
var vue_property_decorator_1 = __webpack_require__("../../node_modules/.pnpm/vue-property-decorator@7.3.0/node_modules/vue-property-decorator/lib/vue-property-decorator.js");
var vue_class_component_1 = __webpack_require__("../../node_modules/.pnpm/vue-class-component@7.2.6_vue@2.7.15/node_modules/vue-class-component/dist/vue-class-component.esm.js");
var source_path_mixin_1 = __webpack_require__("../../libs/vuemodel/lib/source-path-mixin.js");
// @ts-ignore
var VMSource = /** @class */ (function (_super) {
    __extends(VMSource, _super);
    function VMSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    VMSource.prototype.render = function () {
        var slotNodes = this.$scopedSlots.default({
            $source: this.$source
        });
        if (slotNodes.length !== 1) {
            throw new Error("Found " + slotNodes.length + " nodes in default slot for component 'vm-source'.");
        }
        return slotNodes[0];
    };
    VMSource = __decorate([
        vue_property_decorator_1.Component
    ], VMSource);
    return VMSource;
}((0, vue_class_component_1.mixins)(source_path_mixin_1.SourcePathMixin)));
exports.VMSource = VMSource;


/***/ }),

/***/ "../../libs/vuemodel/lib/vue-global-mixin.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VueModel$installGlobalMixin = void 0;
var model_js_1 = __webpack_require__("../../libs/model.js/lib/index.js");
var helpers_1 = __webpack_require__("../../libs/vuemodel/lib/helpers.js");
var vue_helpers_1 = __webpack_require__("../../libs/vuemodel/lib/vue-helpers.js");
var vue_model_observability_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model-observability.js");
/**
 * Installs a global Vue mixin that hooks into component events to intercept model entities as component data and make necesary adjustments
 * @param Vue The Vue constructor/module object
 */
function VueModel$installGlobalMixin(Vue) {
    Vue.mixin({
        beforeCreate: function VueModel$Plugin$beforeCreate() {
            var vm = this;
            if (vm.$options.data) {
                // Intercept data that is an entity or data function that returns an entity
                // so that this plugin can make the entity observable and create proxy properties
                preprocessDataToInterceptEntities(vm);
            }
        },
        created: function VueModel$Plugin$created() {
            var vm = this;
            var vm$private = vm;
            if (vm$private._entity) {
                var entity = vm$private._entity;
                if (!entity.meta.type.model._entitiesAreVueObservable) {
                    // Ensure that Model entities are observable objects compatible with Vue's observer
                    (0, vue_model_observability_1.makeEntitiesVueObservable)(vm$private._entity.meta.type.model);
                }
                (0, vue_model_observability_1.getEntityObserver)(vm$private._entity, true).ensureObservable();
                // Restore the data by attempting to emulate what would have happened to
                // the `data` object had it gone through normal component intialization
                restoreComponentEntityData(vm);
            }
        }
    });
}
exports.VueModel$installGlobalMixin = VueModel$installGlobalMixin;
function replaceEntityData(vm, data) {
    var vm$private = vm;
    if (data != null && data instanceof model_js_1.Entity) {
        (0, helpers_1.debug)("Data is an entity, returning empty object...");
        vm$private._entity = data;
        return {};
    }
    return data;
}
function preprocessDataToInterceptEntities(vm) {
    if (!vm.$options.data) {
        return;
    }
    if (vm.$options.data instanceof Function) {
        // The `.data` options is a function that will be invoked by Vue, so wrap it
        // to prevent Vue from getting an Entity prior to setting up Entity observability
        (0, helpers_1.debug)("Data is a function...wrapping to intercept the return value...");
        var dataFn = vm.$options.data;
        vm.$options.data = function () {
            return replaceEntityData(vm, dataFn.apply(this, arguments));
        };
    }
    else {
        // Don't let Vue from getting an Entity prior to setting up Entity observability
        vm.$options.data = replaceEntityData(vm, vm.$options.data);
    }
}
function restoreComponentEntityData(vm) {
    var vm$private = vm;
    // Since the entity is now observable, go ahead and let the component see it
    // TODO: Is it necessary to somehow "merge" the object? Or, just not set the data
    //      field since we're going to do custom proxying of properties anyway?
    vm$private._data = vm$private._entity;
    // Vue proxies the data objects `Object.keys()` onto the component itself,
    // so that the data objects properties can be used directly in templates
    proxyEntityPropertiesOntoComponentInstance(vm, vm$private._entity);
    // The internal `observe()` method basically makes the given object observable,
    // (entities should already be at this point) but it also updates a `vmCount` counter
    (0, vue_model_observability_1.observeEntity)(vm$private._entity, true).ensureObservable();
    // Null out the field now that we've finished preparing the entity
    vm$private._entity = null;
}
function proxyEntityPropertiesOntoComponentInstance(vm, entity) {
    // TODO: add proxies onto the component instance
    // proxy data on instance
    var properties = entity.meta.type.properties;
    var props = vm.$options.props;
    var methods = vm.$options.methods;
    for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (methods && (0, helpers_1.hasOwnProperty)(methods, property.name)) {
            (0, helpers_1.debug)("Property '" + property.name + "' is hidden by a component method with the same name.");
        }
        else if (props && (0, helpers_1.hasOwnProperty)(props, property.name)) {
            (0, helpers_1.debug)("Property '" + property.name + "' is hidden by a component prop with the same name.");
        }
        else if (!(0, vue_helpers_1.Vue$isReserved)(property.name)) {
            (0, vue_helpers_1.Vue$proxy)(vm, "_data", property.name);
        }
    }
}


/***/ }),

/***/ "../../libs/vuemodel/lib/vue-helpers.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Vue$proxy = exports.Vue$dependArray = exports.Vue$isReserved = void 0;
function Vue$isReserved(str) {
    var c = (str + "").charCodeAt(0);
    return c === 0x24 || c === 0x5F;
}
exports.Vue$isReserved = Vue$isReserved;
function Vue$dependArray(value) {
    for (var e, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        e && e.__ob__ && e.__ob__.dep.depend();
        if (Array.isArray(e)) {
            Vue$dependArray(e);
        }
    }
}
exports.Vue$dependArray = Vue$dependArray;
function Vue$proxy(target, sourceKey, key) {
    Object.defineProperty(target, key, {
        configurable: true,
        enumerable: true,
        get: function VueModel$proxyPropertyGet() {
            return this[sourceKey][key];
        },
        set: function VueModel$proxyPropertySet(value) {
            this[sourceKey][key] = value;
        }
    });
}
exports.Vue$proxy = Vue$proxy;


/***/ }),

/***/ "../../libs/vuemodel/lib/vue-internals.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureVueInternalTypes = exports.VueModel$Vue = void 0;
exports.VueModel$Vue = null;
function ensureVueInternalTypes(target, Vue) {
    // Exit early if Observer or Dep are already defined
    if (target.Observer || target.Dep) {
        return;
    }
    var observableData;
    if (Vue.observable) {
        observableData = Vue.observable({});
    }
    else {
        var component = new Vue({
            data: function () {
                return {};
            }
        });
        observableData = component.$data;
    }
    var observer = observableData.__ob__;
    var observerCtor = observer.constructor;
    var depCtor = observer.dep.constructor;
    target.Observer = observerCtor;
    target.Dep = depCtor;
}
exports.ensureVueInternalTypes = ensureVueInternalTypes;


/***/ }),

/***/ "../../libs/vuemodel/lib/vue-model-observability.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.makeEntitiesVueObservable = exports.dependChildArray = exports.getArrayObserverConstructor = exports.getArrayObserver = exports.observeArray = exports.getObjectMetaObserverConstructor = exports.getObjectMetaObserver = exports.getEntityObserverConstructor = exports.getEntityObserver = exports.observeEntity = exports.preventVueObservability = exports.getCustomObserverConstructor = void 0;
var vue_1 = __webpack_require__("vue");
var model_js_1 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var model_js_2 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var model_js_3 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var helpers_1 = __webpack_require__("../../libs/vuemodel/lib/helpers.js");
// eslint-disable-next-line no-redeclare
var CustomObserverConstructor = null;
function getCustomObserverConstructor() {
    return CustomObserverConstructor || (CustomObserverConstructor = __webpack_require__("../../libs/vuemodel/lib/custom-observer.js").CustomObserver);
}
exports.getCustomObserverConstructor = getCustomObserverConstructor;
function preventVueObservability(obj) {
    if (obj) {
        if (!(0, helpers_1.hasOwnProperty)(obj, "__ob__")) {
            // Mark the object as "raw" so that Vue won't try to make it observable
            (0, vue_1.markRaw)(obj);
            return true;
        }
        else {
            // Vue's default observability is also bypassed if the object's observer is a subclass of `CustomObserver`
            var CustomObserver = getCustomObserverConstructor();
            return obj.__ob__ instanceof CustomObserver;
        }
    }
}
exports.preventVueObservability = preventVueObservability;
/**
 * Based on Vue's internal `observe()` function. Ensures that the given entity
 * is observable and optionally notes that it is referenced by a component
 * @param entity The entity to observe
 * @param asRootData The entity is referenced as a component's data
 */
function observeEntity(entity, asRootData) {
    if (asRootData === void 0) { asRootData = false; }
    if (entity instanceof model_js_2.Entity) {
        var ob = getEntityObserver(entity, true);
        if (entity.meta) {
            getObjectMetaObserver(entity.meta, true);
        }
        if (asRootData && ob) {
            ob.vmCount++;
        }
        return ob;
    }
    else {
        // TODO: Warn about attempting to observe non-entity?
    }
}
exports.observeEntity = observeEntity;
/**
 * Gets or creates an `EntityObserver` for the given entity
 * @param entity The entity begin observed
 * @param create If true, create the observer if it doesn't already exist
 */
function getEntityObserver(entity, create) {
    if (create === void 0) { create = false; }
    var EntityObserver = getEntityObserverConstructor();
    if ((0, helpers_1.hasOwnProperty)(entity, "__ob__") && (0, helpers_1.getProp)(entity, "__ob__") instanceof EntityObserver) {
        return (0, helpers_1.getProp)(entity, "__ob__");
    }
    else if (create) {
        // Mark the entity as "raw" so that Vue won't try to make it observable
        (0, vue_1.markRaw)(entity);
        return new EntityObserver(entity, true);
    }
    else {
        return null;
    }
}
exports.getEntityObserver = getEntityObserver;
// eslint-disable-next-line no-redeclare
var EntityObserverConstructor = null;
function getEntityObserverConstructor() {
    return EntityObserverConstructor || (EntityObserverConstructor = __webpack_require__("../../libs/vuemodel/lib/entity-observer.js").EntityObserver);
}
exports.getEntityObserverConstructor = getEntityObserverConstructor;
/**
 * Gets or creates an `ObjectMetaObserver` for the given meta object
 * @param meta The object meta begin observed
 * @param create If true, create the observer if it doesn't already exist
 */
function getObjectMetaObserver(meta, create) {
    if (create === void 0) { create = false; }
    var ObjectMetaObserver = getObjectMetaObserverConstructor();
    if ((0, helpers_1.hasOwnProperty)(meta, "__ob__") && (0, helpers_1.getProp)(meta, "__ob__") instanceof ObjectMetaObserver) {
        return (0, helpers_1.getProp)(meta, "__ob__");
    }
    else if (create) {
        // Mark the object meta as "raw" so that Vue won't try to make it observable
        (0, vue_1.markRaw)(meta);
        return new ObjectMetaObserver(meta, true);
    }
    else {
        return null;
    }
}
exports.getObjectMetaObserver = getObjectMetaObserver;
// eslint-disable-next-line no-redeclare
var ObjectMetaObserverConstructor = null;
function getObjectMetaObserverConstructor() {
    return ObjectMetaObserverConstructor || (ObjectMetaObserverConstructor = __webpack_require__("../../libs/vuemodel/lib/object-meta-observer.js").ObjectMetaObserver);
}
exports.getObjectMetaObserverConstructor = getObjectMetaObserverConstructor;
/**
 * Based on Vue's internal `observe()` function. Ensures that the given array
 * is observable and optionally notes that it is referenced by a component
 * @param array The array to observe
 * @param asRootData The array is referenced as a component's data
 */
function observeArray(array, asRootData) {
    if (asRootData === void 0) { asRootData = false; }
    if (Array.isArray(array)) {
        if (model_js_3.ObservableArray.isObservableArray(array)) {
            var ob = getArrayObserver(array, true);
            if (asRootData && ob) {
                ob.vmCount++;
            }
            return ob;
        }
        else {
            // TODO: Warn about attempting to observe non-observable array?
        }
    }
    else {
        // TODO: Warn about attempting to observe non-array?
    }
}
exports.observeArray = observeArray;
/**
 * Gets or creates an `ArrayObserver` for the given observable array
 * @param entity The entity begin observed
 * @param create If true, create the observer if it doesn't already exist
 */
function getArrayObserver(array, create) {
    if (create === void 0) { create = false; }
    var ArrayObserver = getArrayObserverConstructor();
    if ((0, helpers_1.hasOwnProperty)(array, "__ob__") && (0, helpers_1.getProp)(array, "__ob__") instanceof ArrayObserver) {
        return (0, helpers_1.getProp)(array, "__ob__");
    }
    else if (create) {
        // Mark the array as "raw" so that Vue won't try to make it observable
        (0, vue_1.markRaw)(array);
        return new ArrayObserver(array, true);
    }
    else {
        return null;
    }
}
exports.getArrayObserver = getArrayObserver;
// eslint-disable-next-line no-redeclare
var ArrayObserverConstructor = null;
function getArrayObserverConstructor() {
    return ArrayObserverConstructor || (ArrayObserverConstructor = __webpack_require__("../../libs/vuemodel/lib/array-observer.js").ArrayObserver);
}
exports.getArrayObserverConstructor = getArrayObserverConstructor;
/**
 * Based on Vue's internals `dependArray()` function
 * @param array The child array to track as a dependency
 */
function dependChildArray(array) {
    var arrayObserver = observeArray(array);
    if (arrayObserver)
        arrayObserver.ensureObservable();
    for (var e, i = 0, l = array.length; i < l; i++) {
        e = array[i];
        if (e != null) {
            if (e instanceof model_js_2.Entity) {
                var observer = getEntityObserver(e, true);
                observer.ensureObservable();
                observer.dep.depend();
            }
            else if ((0, helpers_1.hasOwnProperty)(e, "__ob__")) {
                e.__ob__.dep.depend();
            }
            if (Array.isArray(e)) {
                dependChildArray(e);
            }
        }
    }
}
exports.dependChildArray = dependChildArray;
var vueCompatibleModels = [];
/**
 * Make sure that entities in the given model are observable by Vue
 * By default, entities would not be observable, since model properties
 * are added to the prototype, Vue will not detect them. So, we use a custom
 * observer that leverages model metadata to manage property access/change.
 * @param model The model to augment
 */
function makeEntitiesVueObservable(model) {
    if (!model || !(model instanceof model_js_1.Model)) {
        // TODO: Warn about missing or non-Model argument?
        return;
    }
    if (vueCompatibleModels.indexOf(model) >= 0 || model._entitiesAreVueObservable === true) {
        return;
    }
    model.entityRegistered.subscribe(function (args) {
        observeEntity(args.entity).ensureObservable();
    });
    // Make existing entities observable
    for (var _i = 0, _a = Object.keys(model.types); _i < _a.length; _i++) {
        var typeName = _a[_i];
        var type = model.types[typeName];
        type.known().forEach(function (entity) {
            observeEntity(entity).ensureObservable();
        });
    }
    vueCompatibleModels.push(model);
    model._entitiesAreVueObservable = true;
}
exports.makeEntitiesVueObservable = makeEntitiesVueObservable;


/***/ }),

/***/ "../../libs/vuemodel/lib/vue-model.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVueModel = exports.VueModel = void 0;
var model_js_1 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var model_js_2 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
var vue_internals_1 = __webpack_require__("../../libs/vuemodel/lib/vue-internals.js");
var vue_global_mixin_1 = __webpack_require__("../../libs/vuemodel/lib/vue-global-mixin.js");
var source_path_mixin_1 = __webpack_require__("../../libs/vuemodel/lib/source-path-mixin.js");
var source_root_mixin_1 = __webpack_require__("../../libs/vuemodel/lib/source-root-mixin.js");
var vue_model_observability_1 = __webpack_require__("../../libs/vuemodel/lib/vue-model-observability.js");
var vm_root_component_1 = __webpack_require__("../../libs/vuemodel/lib/vm-root-component.js");
var vm_source_component_1 = __webpack_require__("../../libs/vuemodel/lib/vm-source-component.js");
var model_js_3 = __webpack_require__("../../libs/model.js/lib/index.js"); // eslint-disable-line import/no-duplicates
// TODO: Do we need to take `toggleObserving()` into account?
var VueModel = /** @class */ (function (_super) {
    __extends(VueModel, _super);
    /**
     * Creates a new model with the specified type information.
     * @param options The set of model types to add.
     */
    function VueModel(options, config) {
        var _this = _super.call(this, options, config) || this;
        if (!VueModel._Vue) {
            // TODO: auto-install if needed?
            throw new Error("Vue.use(VueModel) must be called before constructing a VueModel instance.");
        }
        // Make sure that the model itself is not made observable by Vue, since anything that we want to be made observable should be made observable explicitly
        (0, vue_model_observability_1.preventVueObservability)(_this);
        // Make sure that entities are observable by Vue
        (0, vue_model_observability_1.makeEntitiesVueObservable)(_this);
        return _this;
    }
    /**
     * Implement the Vue plugin interface:
     * https://vuejs.org/v2/guide/plugins.html#Writing-a-Plugin
     */
    VueModel.install = function (vue) {
        // Detect if the plugin install has already been called
        if (VueModel._Vue)
            return;
        // Register components globally for use in templates
        vue.component("vm-root", vm_root_component_1.VMRoot);
        vue.component("vm-source", vm_source_component_1.VMSource);
        // Store a reference to the Vue constructor/module
        VueModel._Vue = vue;
        // Get access to Vue's internal types that we need
        (0, vue_internals_1.ensureVueInternalTypes)(VueModel._VueInternals, VueModel._Vue);
        // Install the Vue global mixin
        return (0, vue_global_mixin_1.VueModel$installGlobalMixin)(vue);
    };
    VueModel._Vue = null;
    VueModel._VueInternals = { Observer: null, Dep: null };
    /**
     * Provide access to Vue mixins for source provider/consumer
     */
    VueModel.mixins = {
        SourcePath: source_path_mixin_1.SourcePathMixin,
        SourceRoot: source_root_mixin_1.SourceRootMixin
    };
    VueModel.Entity = model_js_2.Entity;
    VueModel.CultureInfo = model_js_3.CultureInfo;
    return VueModel;
}(model_js_1.Model));
exports.VueModel = VueModel;
// eslint-disable-next-line no-redeclare
function createVueModel(options, config) {
    return new Promise(function (resolve) {
        var model = new VueModel(options, config);
        model.ready(function () {
            resolve(model);
        });
    });
}
exports.createVueModel = createVueModel;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvdnVlbW9kZWwvbGliL2FycmF5LW9ic2VydmVyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy92dWVtb2RlbC9saWIvY3VzdG9tLW9ic2VydmVyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy92dWVtb2RlbC9saWIvZW50aXR5LW9ic2VydmVyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy92dWVtb2RlbC9saWIvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvdnVlbW9kZWwvbGliL2luZGV4LmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy92dWVtb2RlbC9saWIvb2JqZWN0LW1ldGEtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL3Z1ZW1vZGVsL2xpYi9zb3VyY2UtYWRhcHRlci5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvdnVlbW9kZWwvbGliL3NvdXJjZS1pdGVtLWFkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL3Z1ZW1vZGVsL2xpYi9zb3VyY2Utb3B0aW9uLWFkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL3Z1ZW1vZGVsL2xpYi9zb3VyY2UtcGF0aC1hZGFwdGVyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy92dWVtb2RlbC9saWIvc291cmNlLXBhdGgtbWl4aW4uanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL3Z1ZW1vZGVsL2xpYi9zb3VyY2Utcm9vdC1hZGFwdGVyLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy92dWVtb2RlbC9saWIvc291cmNlLXJvb3QtbWl4aW4uanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL3Z1ZW1vZGVsL2xpYi92bS1yb290LWNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vQzovVXNlcnMvVHlsZXJUcm90dGVyL3JlcG9zL0NvZ25pdG8gRm9ybXMvQ29nbml0by5XZWIuQ2xpZW50L2xpYnMvdnVlbW9kZWwvbGliL3ZtLXNvdXJjZS1jb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL3Z1ZW1vZGVsL2xpYi92dWUtZ2xvYmFsLW1peGluLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy92dWVtb2RlbC9saWIvdnVlLWhlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL3Z1ZW1vZGVsL2xpYi92dWUtaW50ZXJuYWxzLmpzIiwid2VicGFjazovLy9DOi9Vc2Vycy9UeWxlclRyb3R0ZXIvcmVwb3MvQ29nbml0byBGb3Jtcy9Db2duaXRvLldlYi5DbGllbnQvbGlicy92dWVtb2RlbC9saWIvdnVlLW1vZGVsLW9ic2VydmFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vL0M6L1VzZXJzL1R5bGVyVHJvdHRlci9yZXBvcy9Db2duaXRvIEZvcm1zL0NvZ25pdG8uV2ViLkNsaWVudC9saWJzL3Z1ZW1vZGVsL2xpYi92dWUtbW9kZWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLDhFQUE4RTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyw0Q0FBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xELDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7Ozs7QUMxQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVB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O0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUVBQXFFLEVBQUU7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1FQUFtRSxFQUFFO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDRDQUE0QyxFQUFFO0FBQ2pIO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrREFBa0QsRUFBRTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsaUVBQWlFLEVBQUU7QUFDMUksbURBQW1ELHFCQUFxQixFQUFFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlEQUF5RCw0QkFBNEIsV0FBVyxFQUFFLEVBQUUs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiJ2dWVtb2RlbC4zMTc2NjdmZmM2ZTM1NjU5MWJlMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkFycmF5T2JzZXJ2ZXIgPSB2b2lkIDA7XHJcbnZhciBjdXN0b21fb2JzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL2N1c3RvbS1vYnNlcnZlclwiKTtcclxuLyoqXHJcbiAqIEEgc3ViY2xhc3Mgb2YgVnVlJ3MgaW50ZXJuYWwgYE9ic2VydmVyYCBjbGFzcyBmb3IgYXJyYXlzLCB3aGljaCB1c2VzIG9ic2VydmFibGVcclxuICogYXJyYXkgZXZlbnRzIHJhdGhlciB0aGFuIHByb3BlcnR5IHdhbGtpbmcgYW5kIHJld3JpdGluZ1xyXG4gKi9cclxudmFyIEFycmF5T2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQXJyYXlPYnNlcnZlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFycmF5T2JzZXJ2ZXIodmFsdWUsIHNoYWxsb3csIG1vY2spIHtcclxuICAgICAgICBpZiAoc2hhbGxvdyA9PT0gdm9pZCAwKSB7IHNoYWxsb3cgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmIChtb2NrID09PSB2b2lkIDApIHsgbW9jayA9IGZhbHNlOyB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlLCBzaGFsbG93LCBtb2NrKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQXJyYXlPYnNlcnZlci5wcm90b3R5cGUuZW5zdXJlT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fb2JzZXJ2YWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWUuY2hhbmdlZC5zdWJzY3JpYmUodGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZSA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlPYnNlcnZlci5wcm90b3R5cGUuX29uQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZGVwLm5vdGlmeSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBcnJheU9ic2VydmVyO1xyXG59KGN1c3RvbV9vYnNlcnZlcl8xLkN1c3RvbU9ic2VydmVyKSk7XHJcbmV4cG9ydHMuQXJyYXlPYnNlcnZlciA9IEFycmF5T2JzZXJ2ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkN1c3RvbU9ic2VydmVyID0gdm9pZCAwO1xyXG52YXIgdnVlX21vZGVsXzEgPSByZXF1aXJlKFwiLi92dWUtbW9kZWxcIik7XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG52YXIgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL3Z1ZS1tb2RlbC1vYnNlcnZhYmlsaXR5XCIpO1xyXG52YXIgbW9kZWxfanNfMSA9IHJlcXVpcmUoXCJAY29nbml0b2Zvcm1zL21vZGVsLmpzXCIpO1xyXG52YXIgVnVlSW50ZXJuYWxzID0gdnVlX21vZGVsXzEuVnVlTW9kZWwuX1Z1ZUludGVybmFscztcclxuaWYgKCFWdWVJbnRlcm5hbHMuT2JzZXJ2ZXIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIlZ1ZSdzIE9ic2VydmVyIGNvbnN0cnVjdG9yIGhhcyBub3QgeWV0IGJlZW4gb2J0YWluZWQsIGJlIHN1cmUgdG8gY2FsbCBWdWUudXNlKFZ1ZU1vZGVsKS5cIik7XHJcbn1cclxudmFyIE9ic2VydmVyID0gVnVlSW50ZXJuYWxzLk9ic2VydmVyO1xyXG4vKipcclxuICogQSBzdWJjbGFzcyBvZiBWdWUncyBpbnRlcm5hbCBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlXHJcbiAqIGZvciBtYW5hZ2luZyBpdHMgb3duIGFjY2Vzcy9jaGFuZ2UgZXZlbnRzIGZvciBwcm9wZXJ0aWVzIHJhdGhlciB0aGFuXHJcbiAqIHdhbGtpbmcgdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzXHJcbiAqL1xyXG52YXIgQ3VzdG9tT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ3VzdG9tT2JzZXJ2ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDdXN0b21PYnNlcnZlcih2YWx1ZSwgc2hhbGxvdywgbW9jaykge1xyXG4gICAgICAgIGlmIChzaGFsbG93ID09PSB2b2lkIDApIHsgc2hhbGxvdyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKG1vY2sgPT09IHZvaWQgMCkgeyBtb2NrID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSwgc2hhbGxvdywgbW9jaykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5wcm9wZXJ0eURlcHMgPSB7fTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgKG9yIGNyZWF0ZXMpIGEgYERlcGAgb2JqZWN0IGZvciBhIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBuYW1lXHJcbiAgICAgKiBUaGUgYERlcGAgb2JqZWN0IHdpbGwgYmUgc3RvcmVkIGludGVybmFsbHkgYnkgdGhlIG9ic2VydmVyLCB1c2luZ1xyXG4gICAgICogdGhlIGdpdmVuIHRhcmdldCBwcm9wZXJ0eSBuYW1lIGFzIGEga2V5XHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIFRoZSB0YXJnZXQgcHJvcGVydHkgbmFtZVxyXG4gICAgICogQHBhcmFtIGNyZWF0ZSBJZiB0cnVlLCBjcmVhdGUgdGhlIGBEZXBgIG9iamVjdCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcclxuICAgICAqL1xyXG4gICAgQ3VzdG9tT2JzZXJ2ZXIucHJvdG90eXBlLmdldFByb3BlcnR5RGVwID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgY3JlYXRlKSB7XHJcbiAgICAgICAgaWYgKGNyZWF0ZSA9PT0gdm9pZCAwKSB7IGNyZWF0ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHByb3BlcnR5RGVwO1xyXG4gICAgICAgIHZhciBEZXAgPSBWdWVJbnRlcm5hbHMuRGVwO1xyXG4gICAgICAgIHZhciBwcm9wZXJ0eURlcHMgPSB0aGlzLnByb3BlcnR5RGVwcztcclxuICAgICAgICBpZiAoKDAsIGhlbHBlcnNfMS5oYXNPd25Qcm9wZXJ0eSkocHJvcGVydHlEZXBzLCBwcm9wZXJ0eU5hbWUpICYmIHByb3BlcnR5RGVwc1twcm9wZXJ0eU5hbWVdIGluc3RhbmNlb2YgRGVwKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnR5RGVwID0gcHJvcGVydHlEZXBzW3Byb3BlcnR5TmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNyZWF0ZSkge1xyXG4gICAgICAgICAgICBwcm9wZXJ0eURlcCA9IG5ldyBEZXAoKTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BlcnR5RGVwcywgcHJvcGVydHlOYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb3BlcnR5RGVwLFxyXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eURlcDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVtdWxhdGUncyBWdWUncyBnZXR0ZXIgbG9naWMgaW4gYGRlZmluZVJlYWN0aXZlKClgXHJcbiAgICAgKiBAcGFyYW0gcHJvcGVydHlOYW1lIFRoZSBwcm9wZXJ0eSBiZWluZyBhY2Nlc3NlZFxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBjdXJyZW50IHByb3BlcnR5IHZhbHVlXHJcbiAgICAgKi9cclxuICAgIEN1c3RvbU9ic2VydmVyLnByb3RvdHlwZS5vblByb3BlcnR5QWNjZXNzID0gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgRGVwID0gVnVlSW50ZXJuYWxzLkRlcDtcclxuICAgICAgICAvLyBBdHRhY2ggZGVwZW5kZW5jaWVzIGlmIHNvbWV0aGluZyBpcyB3YXRjaGluZ1xyXG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBvciBpbml0aWFsaXplIHRoZSBgRGVwYCBvYmplY3RcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5RGVwID0gdGhpcy5nZXRQcm9wZXJ0eURlcChwcm9wZXJ0eU5hbWUsIHRydWUpO1xyXG4gICAgICAgICAgICAvLyBMZXQgYW4gYWN0aXZlIG9ic2VydmVyIHRhcmdldCBrbm93IHRoYXQgdGhlIHByb3BlcnR5IHdhcyBhY2Nlc3NlZCBhbmQgaXMgYSBkZXBlbmRlbmN5XHJcbiAgICAgICAgICAgIHByb3BlcnR5RGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICB2YXIgY2hpbGRPYiA9ICgwLCB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xLm9ic2VydmVFbnRpdHkpKHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkT2IpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgZGVwZW5kZW5jeSBvbiBjaGlsZHJlbiBhcyB3ZWxsIChjcmVhdGluZyBlbnRpdHkgb2JzZXJ2ZXIgYXMgbmVlZGVkKVxyXG4gICAgICAgICAgICAgICAgKDAsIHZ1ZV9tb2RlbF9vYnNlcnZhYmlsaXR5XzEuZGVwZW5kQ2hpbGRBcnJheSkodmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRW11bGF0ZSdzIFZ1ZSdzIHNldHRlciBsb2dpYyBpbiBgZGVmaW5lUmVhY3RpdmUoKWBcclxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eU5hbWUgVGhlIHByb3BlcnR5IGJlaW5nIGFjY2Vzc2VkXHJcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgVGhlIG5ldyBwcm9wZXJ0eSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBDdXN0b21PYnNlcnZlci5wcm90b3R5cGUub25Qcm9wZXJ0eUNoYW5nZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgLy8gR2V0IG9yIGluaXRpYWxpemUgdGhlIGBEZXBgIG9iamVjdFxyXG4gICAgICAgIHZhciBwcm9wZXJ0eURlcCA9IHRoaXMuZ2V0UHJvcGVydHlEZXAocHJvcGVydHlOYW1lLCB0cnVlKTtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgYSBuZXcgdmFsdWUgdGhhdCBpcyBhbiBlbnRpdHkgaXMgb2JzZXJ2YWJsZVxyXG4gICAgICAgIGlmIChuZXdWYWx1ZSAmJiBuZXdWYWx1ZSBpbnN0YW5jZW9mIG1vZGVsX2pzXzEuRW50aXR5KSB7XHJcbiAgICAgICAgICAgICgwLCB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xLm9ic2VydmVFbnRpdHkpKG5ld1ZhbHVlKS5lbnN1cmVPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdGlmeSBvZiBwcm9wZXJ0eSBjaGFuZ2VcclxuICAgICAgICBwcm9wZXJ0eURlcC5ub3RpZnkoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ3VzdG9tT2JzZXJ2ZXI7XHJcbn0oT2JzZXJ2ZXIpKTtcclxuZXhwb3J0cy5DdXN0b21PYnNlcnZlciA9IEN1c3RvbU9ic2VydmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5FbnRpdHlPYnNlcnZlciA9IHZvaWQgMDtcclxudmFyIGN1c3RvbV9vYnNlcnZlcl8xID0gcmVxdWlyZShcIi4vY3VzdG9tLW9ic2VydmVyXCIpO1xyXG52YXIgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL3Z1ZS1tb2RlbC1vYnNlcnZhYmlsaXR5XCIpO1xyXG4vKipcclxuICogQSBzdWJjbGFzcyBvZiBWdWUncyBpbnRlcm5hbCBgT2JzZXJ2ZXJgIGNsYXNzIGZvciBlbnRpdGllcywgd2hpY2ggdXNlcyBtb2RlbFxyXG4gKiBtZXRhZGF0YSB0byBtYW5hZ2UgcHJvcGVydHkgYWNjZXNzL2NoYW5nZSByYXRoZXIgdGhhbiBwcm9wZXJ0eSB3YWxraW5nIGFuZCByZXdyaXRpbmdcclxuICovXHJcbnZhciBFbnRpdHlPYnNlcnZlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhFbnRpdHlPYnNlcnZlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEVudGl0eU9ic2VydmVyKHZhbHVlLCBzaGFsbG93LCBtb2NrKSB7XHJcbiAgICAgICAgaWYgKHNoYWxsb3cgPT09IHZvaWQgMCkgeyBzaGFsbG93ID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAobW9jayA9PT0gdm9pZCAwKSB7IG1vY2sgPSBmYWxzZTsgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB2YWx1ZSwgc2hhbGxvdywgbW9jaykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEVudGl0eU9ic2VydmVyLnByb3RvdHlwZS5lbnN1cmVPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9vYnNlcnZhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWx1ZS5hY2Nlc3NlZC5zdWJzY3JpYmUodGhpcy5fb25BY2Nlc3MuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy52YWx1ZS5jaGFuZ2VkLnN1YnNjcmliZSh0aGlzLl9vbkNoYW5nZS5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAodGhpcy52YWx1ZS5tZXRhKSB7XHJcbiAgICAgICAgICAgICgwLCB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xLmdldE9iamVjdE1ldGFPYnNlcnZlcikodGhpcy52YWx1ZS5tZXRhKS5lbnN1cmVPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29ic2VydmFibGUgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIEVudGl0eU9ic2VydmVyLnByb3RvdHlwZS5fb25BY2Nlc3MgPSBmdW5jdGlvbiAoYXJncykge1xyXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBwcm9wZXJ0eSB2YWx1ZVxyXG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3MuZW50aXR5Ll9fZmllbGRzX19bYXJncy5wcm9wZXJ0eS5uYW1lXTtcclxuICAgICAgICAvLyBOb3RpZnkgaW50ZXJlc3RlZCBvYnNlcnZlcnMgb2YgdGhlIHByb3BlcnR5IGFjY2VzcyBpbiBvcmRlciB0byB0cmFjayBkZXBlbmRlbmNpZXNcclxuICAgICAgICB0aGlzLm9uUHJvcGVydHlBY2Nlc3MoYXJncy5wcm9wZXJ0eS5uYW1lLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgRW50aXR5T2JzZXJ2ZXIucHJvdG90eXBlLl9vbkNoYW5nZSA9IGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHByb3BlcnR5IHZhbHVlXHJcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gYXJncy5lbnRpdHkuX19maWVsZHNfX1thcmdzLnByb3BlcnR5Lm5hbWVdO1xyXG4gICAgICAgIC8vIE5vdGlmeSBpbnRlcmVzdGVkIG9ic2VydmVycyBvZiB0aGUgcHJvcGVydHkgY2hhbmdlXHJcbiAgICAgICAgdGhpcy5vblByb3BlcnR5Q2hhbmdlKGFyZ3MucHJvcGVydHkubmFtZSwgbmV3VmFsdWUpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFbnRpdHlPYnNlcnZlcjtcclxufShjdXN0b21fb2JzZXJ2ZXJfMS5DdXN0b21PYnNlcnZlcikpO1xyXG5leHBvcnRzLkVudGl0eU9ic2VydmVyID0gRW50aXR5T2JzZXJ2ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZGVidWcgPSBleHBvcnRzLmhhc093blByb3BlcnR5ID0gZXhwb3J0cy5zZXRQcm9wID0gZXhwb3J0cy5nZXRQcm9wID0gZXhwb3J0cy5pc0VudGl0eSA9IHZvaWQgMDtcclxudmFyIG1vZGVsX2pzXzEgPSByZXF1aXJlKFwiQGNvZ25pdG9mb3Jtcy9tb2RlbC5qc1wiKTtcclxuZnVuY3Rpb24gaXNFbnRpdHkob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqICYmIG9iai5tZXRhICYmIG9iai5tZXRhLnR5cGUgJiYgb2JqLm1ldGEudHlwZS5qc3R5cGUgJiYgKDAsIG1vZGVsX2pzXzEuaXNFbnRpdHlUeXBlKShvYmoubWV0YS50eXBlLmpzdHlwZSk7XHJcbn1cclxuZXhwb3J0cy5pc0VudGl0eSA9IGlzRW50aXR5O1xyXG5mdW5jdGlvbiBnZXRQcm9wKG9iaiwgcHJvcCkge1xyXG4gICAgcmV0dXJuIG9ialtwcm9wXTtcclxufVxyXG5leHBvcnRzLmdldFByb3AgPSBnZXRQcm9wO1xyXG5mdW5jdGlvbiBzZXRQcm9wKHRhcmdldCwga2V5LCB2YWx1ZSkge1xyXG4gICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcclxufVxyXG5leHBvcnRzLnNldFByb3AgPSBzZXRQcm9wO1xyXG52YXIgaGFzT3duUHJvcGVydHlGbiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xyXG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5Rm4uY2FsbChvYmosIHByb3ApO1xyXG59XHJcbmV4cG9ydHMuaGFzT3duUHJvcGVydHkgPSBoYXNPd25Qcm9wZXJ0eTtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xyXG5mdW5jdGlvbiBkZWJ1ZyhtZXNzYWdlKSB7XHJcbiAgICAvLyBjb25zb2xlLmxvZyhcIiVjW0RFQlVHXSBcIiArIG1lc3NhZ2UsIFwiYmFja2dyb3VuZC1jb2xvcjogI2VmZWZlZjsgY29sb3I6ICM5OTk7XCIpO1xyXG59XHJcbmV4cG9ydHMuZGVidWcgPSBkZWJ1ZztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5wcmV2ZW50VnVlT2JzZXJ2YWJpbGl0eSA9IGV4cG9ydHMuaXNTb3VyY2VBZGFwdGVyID0gdm9pZCAwO1xyXG52YXIgdnVlX21vZGVsXzEgPSByZXF1aXJlKFwiLi92dWUtbW9kZWxcIik7XHJcbi8vIEluY2x1ZGUgRW5nbGlzaCByZXNvdXJjZXMgYnkgZGVmYXVsdFxyXG5yZXF1aXJlKFwiQGNvZ25pdG9mb3Jtcy9tb2RlbC5qcy9saWIvcmVzb3VyY2UtZW5cIik7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHZ1ZV9tb2RlbF8xLlZ1ZU1vZGVsO1xyXG52YXIgc291cmNlX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL3NvdXJjZS1hZGFwdGVyXCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1NvdXJjZUFkYXB0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV9hZGFwdGVyXzEuaXNTb3VyY2VBZGFwdGVyOyB9IH0pO1xyXG52YXIgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL3Z1ZS1tb2RlbC1vYnNlcnZhYmlsaXR5XCIpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcmV2ZW50VnVlT2JzZXJ2YWJpbGl0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5wcmV2ZW50VnVlT2JzZXJ2YWJpbGl0eTsgfSB9KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuT2JqZWN0TWV0YU9ic2VydmVyID0gdm9pZCAwO1xyXG52YXIgY3VzdG9tX29ic2VydmVyXzEgPSByZXF1aXJlKFwiLi9jdXN0b20tb2JzZXJ2ZXJcIik7XHJcbi8qKlxyXG4gKiBBIHN1YmNsYXNzIG9mIFZ1ZSdzIGludGVybmFsIGBPYnNlcnZlcmAgY2xhc3MgZm9yIGVudGl0eSBtZXRhIG9iamVjdHMsIHdoaWNoIHVzZXMgbW9kZWxcclxuICogbWV0YWRhdGEgdG8gbWFuYWdlIGNvbmRpdGlvbiBjaGFuZ2UgcmF0aGVyIHRoYW4gcHJvcGVydHkgd2Fsa2luZyBhbmQgcmV3cml0aW5nXHJcbiAqL1xyXG52YXIgT2JqZWN0TWV0YU9ic2VydmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE9iamVjdE1ldGFPYnNlcnZlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9iamVjdE1ldGFPYnNlcnZlcih2YWx1ZSwgc2hhbGxvdywgbW9jaykge1xyXG4gICAgICAgIGlmIChzaGFsbG93ID09PSB2b2lkIDApIHsgc2hhbGxvdyA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKG1vY2sgPT09IHZvaWQgMCkgeyBtb2NrID0gZmFsc2U7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdmFsdWUsIHNoYWxsb3csIG1vY2spIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3RNZXRhT2JzZXJ2ZXIucHJvdG90eXBlLmVuc3VyZU9ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29ic2VydmFibGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbHVlLmNvbmRpdGlvbnMuY2hhbmdlZC5zdWJzY3JpYmUodGhpcy5fb25Db25kaXRpb25zQ2hhbmdlZC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLl9vYnNlcnZhYmxlID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBPYmplY3RNZXRhT2JzZXJ2ZXIucHJvdG90eXBlLl9vbkNvbmRpdGlvbnNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIE5vdGlmeSBpbnRlcmVzdGVkIG9ic2VydmVycyBvZiB0aGUgY29uZGl0aW9uIGNoYW5nZSBpbiBvcmRlciB0byB1cGRhdGUgZGVwZW5kYW50c1xyXG4gICAgICAgIHRoaXMub25Qcm9wZXJ0eUNoYW5nZShcImNvbmRpdGlvbnNcIiwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9iamVjdE1ldGFPYnNlcnZlcjtcclxufShjdXN0b21fb2JzZXJ2ZXJfMS5DdXN0b21PYnNlcnZlcikpO1xyXG5leHBvcnRzLk9iamVjdE1ldGFPYnNlcnZlciA9IE9iamVjdE1ldGFPYnNlcnZlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5oYXNPdmVycmlkZVZhbHVlID0gZXhwb3J0cy5pc1NvdXJjZVByb3BlcnR5QWRhcHRlciA9IGV4cG9ydHMuaXNTb3VyY2VBZGFwdGVyID0gZXhwb3J0cy5pc1NvdXJjZUl0ZW1BZGFwdGVyID0gZXhwb3J0cy5pc1NvdXJjZVBhdGhBZGFwdGVyID0gZXhwb3J0cy5pc1NvdXJjZVJvb3RBZGFwdGVyID0gdm9pZCAwO1xyXG52YXIgc291cmNlX3Jvb3RfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vc291cmNlLXJvb3QtYWRhcHRlclwiKTtcclxudmFyIHNvdXJjZV9wYXRoX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL3NvdXJjZS1wYXRoLWFkYXB0ZXJcIik7XHJcbnZhciBzb3VyY2VfaXRlbV9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9zb3VyY2UtaXRlbS1hZGFwdGVyXCIpO1xyXG5mdW5jdGlvbiBpc1NvdXJjZVJvb3RBZGFwdGVyKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHNvdXJjZV9yb290X2FkYXB0ZXJfMS5Tb3VyY2VSb290QWRhcHRlcjtcclxufVxyXG5leHBvcnRzLmlzU291cmNlUm9vdEFkYXB0ZXIgPSBpc1NvdXJjZVJvb3RBZGFwdGVyO1xyXG5mdW5jdGlvbiBpc1NvdXJjZVBhdGhBZGFwdGVyKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHNvdXJjZV9wYXRoX2FkYXB0ZXJfMS5Tb3VyY2VQYXRoQWRhcHRlcjtcclxufVxyXG5leHBvcnRzLmlzU291cmNlUGF0aEFkYXB0ZXIgPSBpc1NvdXJjZVBhdGhBZGFwdGVyO1xyXG5mdW5jdGlvbiBpc1NvdXJjZUl0ZW1BZGFwdGVyKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHNvdXJjZV9pdGVtX2FkYXB0ZXJfMS5Tb3VyY2VJdGVtQWRhcHRlcjtcclxufVxyXG5leHBvcnRzLmlzU291cmNlSXRlbUFkYXB0ZXIgPSBpc1NvdXJjZUl0ZW1BZGFwdGVyO1xyXG5mdW5jdGlvbiBpc1NvdXJjZUFkYXB0ZXIob2JqLCBhbGxvd0FueU9iamVjdCkge1xyXG4gICAgaWYgKGFsbG93QW55T2JqZWN0ID09PSB2b2lkIDApIHsgYWxsb3dBbnlPYmplY3QgPSB0cnVlOyB9XHJcbiAgICBpZiAoaXNTb3VyY2VSb290QWRhcHRlcihvYmopKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKGlzU291cmNlUGF0aEFkYXB0ZXIob2JqKSlcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIGlmIChpc1NvdXJjZUl0ZW1BZGFwdGVyKG9iaikpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoYWxsb3dBbnlPYmplY3QgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmlzU291cmNlQWRhcHRlciA9IGlzU291cmNlQWRhcHRlcjtcclxuZnVuY3Rpb24gaXNTb3VyY2VQcm9wZXJ0eUFkYXB0ZXIob2JqKSB7XHJcbiAgICBpZiAoaXNTb3VyY2VQYXRoQWRhcHRlcihvYmopKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmV4cG9ydHMuaXNTb3VyY2VQcm9wZXJ0eUFkYXB0ZXIgPSBpc1NvdXJjZVByb3BlcnR5QWRhcHRlcjtcclxuZnVuY3Rpb24gaGFzT3ZlcnJpZGVWYWx1ZSh2YWx1ZSwgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09IFN0cmluZykge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoID4gMDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGUgPT09IEJvb2xlYW4pIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmhhc092ZXJyaWRlVmFsdWUgPSBoYXNPdmVycmlkZVZhbHVlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU291cmNlSXRlbUFkYXB0ZXIgPSB2b2lkIDA7XHJcbnZhciB2dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidnVlXCIpKTtcclxudmFyIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCJ2dWUtcHJvcGVydHktZGVjb3JhdG9yXCIpO1xyXG52YXIgc291cmNlX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL3NvdXJjZS1hZGFwdGVyXCIpO1xyXG52YXIgbW9kZWxfanNfMSA9IHJlcXVpcmUoXCJAY29nbml0b2Zvcm1zL21vZGVsLmpzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1kdXBsaWNhdGVzXHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG4vLyBAdHMtaWdub3JlXHJcbnZhciBTb3VyY2VJdGVtQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTb3VyY2VJdGVtQWRhcHRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNvdXJjZUl0ZW1BZGFwdGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpc18xID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXNfMS5pc09ycGhhbmVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXNfMS5pbnRlcm5hbEluZGV4ID0gLTE7XHJcbiAgICAgICAgX3RoaXNfMS5pc1N1YnNjcmliZWRUb1NvdXJjZUNoYW5nZXMgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXNfMTtcclxuICAgIH1cclxuICAgIFNvdXJjZUl0ZW1BZGFwdGVyLnByb3RvdHlwZS5jcmVhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFRyYWNrIHRoZSBpbnRpYWwgaW5kZXggaW50ZXJuYWxseVxyXG4gICAgICAgIHRoaXMuaW50ZXJuYWxJbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgLy8gVHJhY2sgY2hhbmdlcyB0byB0aGUgbGlzdCBhbmQgdXBkYXRlIHRoZSBjb21wb25lbnQncyBzdGF0ZSBhcHByb3ByaWF0ZWx5XHJcbiAgICAgICAgaWYgKCF0aGlzLnN1cHByZXNzQ2hhbmdlVHJhY2tpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1NvdXJjZUNoYW5nZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU291cmNlSXRlbUFkYXB0ZXIucHJvdG90eXBlLm9uSW5kZXhDaGFuZ2VkID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcm5hbEluZGV4ID0gaW5kZXg7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZUl0ZW1BZGFwdGVyLnByb3RvdHlwZSwgXCJwYXJlbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoKDAsIHNvdXJjZV9hZGFwdGVyXzEuaXNTb3VyY2VBZGFwdGVyKSh0aGlzLnBhcmVudFNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBwYXJlbnRWbSA9IHRoaXMuJHBhcmVudC4kcGFyZW50LCBwYXJlbnRMZXZlbCA9IDE7IHBhcmVudFZtICE9IG51bGw7IHBhcmVudFZtID0gcGFyZW50Vm0uJHBhcmVudCwgcGFyZW50TGV2ZWwgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCgwLCBzb3VyY2VfYWRhcHRlcl8xLmlzU291cmNlQWRhcHRlcikocGFyZW50Vm0uJHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Vm0uJHNvdXJjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgc291cmNlIG5vdCBmb3VuZCFcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZUl0ZW1BZGFwdGVyLnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogIEluZGljYW50cyB3aGV0aGVyIHRoZSBzb3VyY2UgcHJvcGVydHkgaXMgcmVhZG9ubHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQHJldHVybnMgVHJ1ZSBpZiBlaXRoZXIgdGhlIHBhcmVudCBzb3VyY2Ugb3IgdGhlIHNvdXJjZSBvdmVycmlkZSBpcyByZWFkIG9ubHksIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucmVhZG9ubHkgfHwgKHRoaXMub3ZlcnJpZGVzID8gdGhpcy5vdmVycmlkZXMucmVhZG9ubHkgOiBmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU291cmNlSXRlbUFkYXB0ZXIucHJvdG90eXBlLnN1YnNjcmliZVRvU291cmNlQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1N1YnNjcmliZWRUb1NvdXJjZUNoYW5nZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBhcnJheSA9IG1vZGVsX2pzXzEuT2JzZXJ2YWJsZUFycmF5LmVuc3VyZU9ic2VydmFibGUodGhpcy5wYXJlbnQudmFsdWUpO1xyXG4gICAgICAgIGFycmF5LmNoYW5nZWQuc3Vic2NyaWJlKGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IF90aGlzLmludGVybmFsSW5kZXg7XHJcbiAgICAgICAgICAgIHZhciBpc09ycGhhbmVkID0gX3RoaXMuaXNPcnBoYW5lZDtcclxuICAgICAgICAgICAgYXJncy5jaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjLnR5cGUgPT09IG1vZGVsX2pzXzEuQXJyYXlDaGFuZ2VUeXBlLnJlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YXJ0SW5kZXggPT09IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT3JwaGFuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjLnN0YXJ0SW5kZXggPCBpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5pdGVtcy5sZW5ndGggPiBpbmRleCAtIGMuc3RhcnRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT3JwaGFuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggLT0gYy5pdGVtcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjLnR5cGUgPT09IG1vZGVsX2pzXzEuQXJyYXlDaGFuZ2VUeXBlLmFkZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YXJ0SW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFydEluZGV4IDw9IGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBjLml0ZW1zLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChpc09ycGhhbmVkICE9PSBfdGhpcy5pc09ycGhhbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB2dWVfMS5kZWZhdWx0LnNldChfdGhpcywgXCJpc09ycGhhbmVkXCIsIGlzT3JwaGFuZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gX3RoaXMuaW50ZXJuYWxJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgdnVlXzEuZGVmYXVsdC5zZXQoX3RoaXMsIFwiaW50ZXJuYWxJbmRleFwiLCBpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmlzU3Vic2NyaWJlZFRvU291cmNlQ2hhbmdlcyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZUl0ZW1BZGFwdGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5wYXJlbnQudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpc3RbdGhpcy5pbnRlcm5hbEluZGV4XTtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VJdGVtQWRhcHRlci5wcm90b3R5cGUsIFwidHlwZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHBvc3NpYmxlLCBkZXRlcm1pbmUgdGhlIHR5cGUgYmFzZWQgb24gdGhlIGFjdHVhbCBlbnRpdHkgaW5zdGFuY2VcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgJiYgKDAsIGhlbHBlcnNfMS5pc0VudGl0eSkodGhpcy52YWx1ZSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5tZXRhLnR5cGUuanN0eXBlO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQudHlwZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlSXRlbUFkYXB0ZXIucHJvdG90eXBlLCBcImlzTGlzdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlSXRlbUFkYXB0ZXIucHJvdG90eXBlLCBcImRpc3BsYXlWYWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ID0gdGhpcy5wYXJlbnQudmFsdWU7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpc3RbdGhpcy5pbnRlcm5hbEluZGV4XTtcclxuICAgICAgICAgICAgdmFyIGRpc3BsYXlWYWx1ZTtcclxuICAgICAgICAgICAgaWYgKCgwLCBzb3VyY2VfYWRhcHRlcl8xLmlzU291cmNlUHJvcGVydHlBZGFwdGVyKSh0aGlzLnBhcmVudCkgJiYgdGhpcy5wYXJlbnQucHJvcGVydHkuZm9ybWF0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIFVzZSBhIG1hcmt1cCBvciBwcm9wZXJ0eSBmb3JtYXQgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUgPSB0aGlzLnBhcmVudC5wcm9wZXJ0eS5mb3JtYXQuY29udmVydCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkaXNwbGF5VmFsdWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU291cmNlSXRlbUFkYXB0ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIlNvdXJjZVtcIiArIHRoaXMuaW50ZXJuYWxJbmRleCArIFwiXVwiO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuUHJvcCkoTnVtYmVyKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgU291cmNlSXRlbUFkYXB0ZXIucHJvdG90eXBlLCBcImluZGV4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgdnVlX3Byb3BlcnR5X2RlY29yYXRvcl8xLlByb3ApKE9iamVjdCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNvdXJjZUl0ZW1BZGFwdGVyLnByb3RvdHlwZSwgXCJwYXJlbnRTb3VyY2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuUHJvcCkoT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU291cmNlSXRlbUFkYXB0ZXIucHJvdG90eXBlLCBcIm92ZXJyaWRlc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMS5Qcm9wKSh7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU291cmNlSXRlbUFkYXB0ZXIucHJvdG90eXBlLCBcInN1cHByZXNzQ2hhbmdlVHJhY2tpbmdcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuV2F0Y2gpKFwiaW5kZXhcIiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBTb3VyY2VJdGVtQWRhcHRlci5wcm90b3R5cGUsIFwib25JbmRleENoYW5nZWRcIiwgbnVsbCk7XHJcbiAgICBTb3VyY2VJdGVtQWRhcHRlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMS5Db21wb25lbnRcclxuICAgIF0sIFNvdXJjZUl0ZW1BZGFwdGVyKTtcclxuICAgIHJldHVybiBTb3VyY2VJdGVtQWRhcHRlcjtcclxufSh2dWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuU291cmNlSXRlbUFkYXB0ZXIgPSBTb3VyY2VJdGVtQWRhcHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlNvdXJjZU9wdGlvbkFkYXB0ZXIgPSB2b2lkIDA7XHJcbnZhciB2dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidnVlXCIpKTtcclxudmFyIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCJ2dWUtcHJvcGVydHktZGVjb3JhdG9yXCIpO1xyXG52YXIgc291cmNlX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCIuL3NvdXJjZS1hZGFwdGVyXCIpO1xyXG52YXIgc291cmNlX3BhdGhfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vc291cmNlLXBhdGgtYWRhcHRlclwiKTtcclxuLy8gQHRzLWlnbm9yZVxyXG52YXIgU291cmNlT3B0aW9uQWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTb3VyY2VPcHRpb25BZGFwdGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU291cmNlT3B0aW9uQWRhcHRlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlT3B0aW9uQWRhcHRlci5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcGFyZW50Vm0gPSB0aGlzLiRwYXJlbnQuJHBhcmVudCwgcGFyZW50TGV2ZWwgPSAxOyBwYXJlbnRWbSAhPSBudWxsOyBwYXJlbnRWbSA9IHBhcmVudFZtLiRwYXJlbnQsIHBhcmVudExldmVsICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoMCwgc291cmNlX2FkYXB0ZXJfMS5pc1NvdXJjZVByb3BlcnR5QWRhcHRlcikocGFyZW50Vm0uJHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Vm0uJHNvdXJjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJlbnQgc291cmNlIG5vdCBmb3VuZCFcIik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZU9wdGlvbkFkYXB0ZXIucHJvdG90eXBlLCBcImxhYmVsXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmxhYmVsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VPcHRpb25BZGFwdGVyLnByb3RvdHlwZSwgXCJkaXNwbGF5VmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKDAsIHNvdXJjZV9wYXRoX2FkYXB0ZXJfMS5mb3JtYXREaXNwbGF5VmFsdWUpKHRoaXMucGFyZW50LCB0aGlzLnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBTb3VyY2VPcHRpb25BZGFwdGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gXCJPcHRpb24gZm9yIFNvdXJjZVsnXCIgKyB0aGlzLnBhcmVudC5wcm9wZXJ0eS5wYXRoICsgXCInXVwiO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuUHJvcCkoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU291cmNlT3B0aW9uQWRhcHRlci5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIFNvdXJjZU9wdGlvbkFkYXB0ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuQ29tcG9uZW50XHJcbiAgICBdLCBTb3VyY2VPcHRpb25BZGFwdGVyKTtcclxuICAgIHJldHVybiBTb3VyY2VPcHRpb25BZGFwdGVyO1xyXG59KHZ1ZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5Tb3VyY2VPcHRpb25BZGFwdGVyID0gU291cmNlT3B0aW9uQWRhcHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLmZvcm1hdERpc3BsYXlWYWx1ZSA9IGV4cG9ydHMuU291cmNlUGF0aEFkYXB0ZXIgPSB2b2lkIDA7XHJcbnZhciB2dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidnVlXCIpKTtcclxudmFyIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCJ2dWUtcHJvcGVydHktZGVjb3JhdG9yXCIpO1xyXG52YXIgbW9kZWxfanNfMSA9IHJlcXVpcmUoXCJAY29nbml0b2Zvcm1zL21vZGVsLmpzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1kdXBsaWNhdGVzXHJcbnZhciBtb2RlbF9qc18yID0gcmVxdWlyZShcIkBjb2duaXRvZm9ybXMvbW9kZWwuanNcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWR1cGxpY2F0ZXNcclxudmFyIHNvdXJjZV9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9zb3VyY2UtYWRhcHRlclwiKTtcclxudmFyIHNvdXJjZV9vcHRpb25fYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vc291cmNlLW9wdGlvbi1hZGFwdGVyXCIpO1xyXG52YXIgbW9kZWxfanNfMyA9IHJlcXVpcmUoXCJAY29nbml0b2Zvcm1zL21vZGVsLmpzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1kdXBsaWNhdGVzXHJcbnZhciB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xID0gcmVxdWlyZShcIi4vdnVlLW1vZGVsLW9ic2VydmFiaWxpdHlcIik7XHJcbnZhciBtb2RlbF9qc180ID0gcmVxdWlyZShcIkBjb2duaXRvZm9ybXMvbW9kZWwuanNcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWR1cGxpY2F0ZXNcclxudmFyIG1vZGVsX2pzXzUgPSByZXF1aXJlKFwiQGNvZ25pdG9mb3Jtcy9tb2RlbC5qc1wiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tZHVwbGljYXRlc1xyXG52YXIgc291cmNlX2l0ZW1fYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vc291cmNlLWl0ZW0tYWRhcHRlclwiKTtcclxudmFyIG1vZGVsX2pzXzYgPSByZXF1aXJlKFwiQGNvZ25pdG9mb3Jtcy9tb2RlbC5qc1wiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tZHVwbGljYXRlc1xyXG52YXIgbW9kZWxfanNfNyA9IHJlcXVpcmUoXCJAY29nbml0b2Zvcm1zL21vZGVsLmpzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1kdXBsaWNhdGVzXHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG52YXIgX2lkID0gMDtcclxuLy8gQHRzLWlnbm9yZVxyXG52YXIgU291cmNlUGF0aEFkYXB0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU291cmNlUGF0aEFkYXB0ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTb3VyY2VQYXRoQWRhcHRlcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAvLyB2aWV3U3RhdGU6IHsgZm9ybWF0RXJyb3I6IENvbmRpdGlvblRhcmdldCB9ID0geyBmb3JtYXRFcnJvcjogbnVsbCB9O1xyXG4gICAgICAgIC8vIGZvcm1hdEVycm9yOiBGb3JtYXRFcnJvciA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMuZm9ybWF0RXJyb3JDb25kaXRpb24gPSBudWxsO1xyXG4gICAgICAgIF90aGlzLmlkID0gXCJcIi5jb25jYXQoX2lkKyspO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VQYXRoQWRhcHRlci5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcGFyZW50Vm0gPSB0aGlzLiRwYXJlbnQuJHBhcmVudCwgcGFyZW50TGV2ZWwgPSAxOyBwYXJlbnRWbSAhPSBudWxsOyBwYXJlbnRWbSA9IHBhcmVudFZtLiRwYXJlbnQsIHBhcmVudExldmVsICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoMCwgc291cmNlX2FkYXB0ZXJfMS5pc1NvdXJjZUFkYXB0ZXIpKHBhcmVudFZtLiRzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudFZtLiRzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IHNvdXJjZSBub3QgZm91bmQhXCIpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VQYXRoQWRhcHRlci5wcm90b3R5cGUsIFwicHJvcGVydHlcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnBhcmVudC50eXBlLm1ldGEuZ2V0UGF0aCh0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgICAgICgwLCB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xLnByZXZlbnRWdWVPYnNlcnZhYmlsaXR5KShwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcInR5cGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBJZiBwb3NzaWJsZSwgZGV0ZXJtaW5lIHRoZSB0eXBlIGJhc2VkIG9uIHRoZSBhY3R1YWwgZW50aXR5IGluc3RhbmNlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlICYmICgwLCBoZWxwZXJzXzEuaXNFbnRpdHkpKHRoaXMudmFsdWUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubWV0YS50eXBlLmpzdHlwZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkucHJvcGVydHlUeXBlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VQYXRoQWRhcHRlci5wcm90b3R5cGUsIFwiaXNMaXN0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkuaXNMaXN0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VQYXRoQWRhcHRlci5wcm90b3R5cGUsIFwibGFzdFRhcmdldFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucHJvcGVydHk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eS5nZXRMYXN0VGFyZ2V0KHRoaXMucGFyZW50LnZhbHVlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcImxhYmVsXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgR2V0cyB0aGUgbGFiZWwgZm9yIHRoZSBzb3VyY2UgcHJvcGVydHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAgQHJldHVybnMgVGhlIHNvdXJjZSBvdmVycmlkZSBsYWJlbCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBtb2RlbCBwcm9wZXJ0eSBsYWJlbCBpZiBub3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5vdmVycmlkZXMgPyB0aGlzLm92ZXJyaWRlcy5sYWJlbCA6IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChsYWJlbCA9PT0gdW5kZWZpbmVkIHx8IGxhYmVsID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0eS5sYWJlbElzRm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSAoMCwgbW9kZWxfanNfMi5ldmFsdWF0ZUxhYmVsKSh0aGlzLnByb3BlcnR5LCB0aGlzLnBhcmVudC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMucHJvcGVydHkubGFiZWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VQYXRoQWRhcHRlci5wcm90b3R5cGUsIFwiaGVscHRleHRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICBHZXRzIHRoZSBoZWxwdGV4dCBmb3IgdGhlIHNvdXJjZSBwcm9wZXJ0eS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAcmV0dXJucyBUaGUgc291cmNlIG92ZXJyaWRlIGhlbHB0ZXh0IGlmIHNwZWNpZmllZCwgb3IgdGhlIG1vZGVsIHByb3BlcnR5IGhlbHB0ZXh0IGlmIG5vdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaGVscHRleHQgPSB0aGlzLm92ZXJyaWRlcyA/IHRoaXMub3ZlcnJpZGVzLmhlbHB0ZXh0IDogbnVsbDtcclxuICAgICAgICAgICAgaWYgKGhlbHB0ZXh0ID09PSB1bmRlZmluZWQgfHwgaGVscHRleHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnR5LmhlbHB0ZXh0SXNGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBoZWxwdGV4dCA9IHRoaXMucGFyZW50LnZhbHVlLnRvU3RyaW5nKHRoaXMucHJvcGVydHkuaGVscHRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscHRleHQgPSB0aGlzLnByb3BlcnR5LmhlbHB0ZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBoZWxwdGV4dDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgSW5kaWNhbnRzIHdoZXRoZXIgdGhlIHNvdXJjZSBwcm9wZXJ0eSBpcyByZWFkb25seS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAcmV0dXJucyBUcnVlIGlmIGVpdGhlciB0aGUgcGFyZW50IHNvdXJjZSBvciB0aGUgc291cmNlIG92ZXJyaWRlIGlzIHJlYWQgb25seSwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5yZWFkb25seSB8fCAodGhpcy5vdmVycmlkZXMgPyAhIXRoaXMub3ZlcnJpZGVzLnJlYWRvbmx5IDogZmFsc2UpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VQYXRoQWRhcHRlci5wcm90b3R5cGUsIFwicmVxdWlyZWRcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogIEluZGljYW50cyB3aGV0aGVyIHRoZSBzb3VyY2UgcHJvcGVydHkgaXMgcmVxdWlyZWQuXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogIEByZXR1cm5zIFRydWUgaWYgdGhlIHByb3BlcnR5IGlzIHJlcXVpcmVkLCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vdmVycmlkZXMgJiYgdGhpcy5vdmVycmlkZXMucmVxdWlyZWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJyaWRlcy5yZXF1aXJlZDtcclxuICAgICAgICAgICAgaWYgKCgwLCBtb2RlbF9qc18yLmlzUHJvcGVydHlCb29sZWFuRnVuY3Rpb25BbmRPcHRpb25zKSh0aGlzLnByb3BlcnR5LnJlcXVpcmVkKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCgwLCBtb2RlbF9qc18yLmlzUHJvcGVydHlCb29sZWFuRnVuY3Rpb24pKHRoaXMucHJvcGVydHkucmVxdWlyZWQuZnVuY3Rpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkucmVxdWlyZWQuZnVuY3Rpb24uY2FsbCh0aGlzLnBhcmVudC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKDAsIG1vZGVsX2pzXzIuaXNQcm9wZXJ0eUJvb2xlYW5GdW5jdGlvbikodGhpcy5wcm9wZXJ0eS5yZXF1aXJlZCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wZXJ0eS5yZXF1aXJlZC5jYWxsKHRoaXMucGFyZW50LnZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcGVydHkucmVxdWlyZWQgPT09IHRydWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZVBhdGhBZGFwdGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBzb3VyY2UgcHJvcGVydHkgb24gdGhlIGVudGl0eS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBAcmV0dXJucyBUaGUgb2JzZXJ2YWJsZSByYXcgdmFsdWUgb2YgdGhlIHByb3BlcnR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgYWRhcHRlciBoYXMgbm8gdmFsdWUgaWYgaXRzIHBhcmVudCBoYXMgbm8gdmFsdWVcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudC52YWx1ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlT2JzZXJ2YWJsZSh0aGlzLnByb3BlcnR5LnZhbHVlKHRoaXMucGFyZW50LnZhbHVlKSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNvdXJjZSBwcm9wZXJ0eSBvbiB0aGUgZW50aXR5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogIEBwYXJhbSB2YWx1ZSAtIFRoZSBuZXcgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSBwcm9wZXJ0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnR5LmlzTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlQXJyYXlfMSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9ic2VydmFibGVBcnJheV8xID0gdGhpcy5wcm9wZXJ0eS52YWx1ZSh0aGlzLnBhcmVudC52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlQXJyYXlfMS5iYXRjaFVwZGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiAoMCwgbW9kZWxfanNfNS51cGRhdGVBcnJheSkob2JzZXJ2YWJsZUFycmF5XzEsIHZhbHVlQXJyYXlfMSk7IH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0eS52YWx1ZSh0aGlzLnBhcmVudC52YWx1ZSwgdGhpcy5lbnN1cmVPYnNlcnZhYmxlKHZhbHVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcImNvbmRpdGlvbnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgbWV0YSA9IHRoaXMucGFyZW50LnZhbHVlLm1ldGE7XHJcbiAgICAgICAgICAgIHZhciBtZXRhT2IgPSAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5nZXRPYmplY3RNZXRhT2JzZXJ2ZXIpKG1ldGEpO1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgbWV0YSBvYmplY3QgaXMgb2JzZXJ2YWJsZSwgZXg6IHN1YnNjcmliZXMgdG8gY29uZGl0aW9ucyBhcnJheSBjaGFuZ2VkXHJcbiAgICAgICAgICAgIG1ldGFPYi5lbnN1cmVPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25UYXJnZXRzID0gbWV0YS5jb25kaXRpb25zO1xyXG4gICAgICAgICAgICBjb25kaXRpb25UYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGNvbmRpdGlvbikgeyAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5wcmV2ZW50VnVlT2JzZXJ2YWJpbGl0eSkoY29uZGl0aW9uKTsgfSk7XHJcbiAgICAgICAgICAgIC8vIFJhaXNlIHByb3BlcnR5IGFjY2VzcyB0byBsZXQgVnVlIGtub3cgdGhhdCBhcnJheSB3YXMgYWNjZXNzZWRcclxuICAgICAgICAgICAgLy8gQ2hhbmdlcyB0byBjb25kaXRpb25zIHdpbGwgcmVzdWx0IGluIGEgVnVlIGNoYW5nZSBub3RpZmljYXRpb24gZm9yIHRoZSAnY29uZGl0aW9ucycgcHJvcGVydHlcclxuICAgICAgICAgICAgbWV0YU9iLm9uUHJvcGVydHlBY2Nlc3MoXCJjb25kaXRpb25zXCIsIGNvbmRpdGlvblRhcmdldHMpO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0RXJyb3JDb25kaXRpb25zID0gdGhpcy5mb3JtYXRFcnJvckNvbmRpdGlvbiA/IFt0aGlzLmZvcm1hdEVycm9yQ29uZGl0aW9uXSA6IFtdO1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnByb3BlcnR5IGluc3RhbmNlb2YgbW9kZWxfanNfMi5Qcm9wZXJ0eSA/IHRoaXMucHJvcGVydHkgOiB0aGlzLnByb3BlcnR5IGluc3RhbmNlb2YgbW9kZWxfanNfNC5Qcm9wZXJ0eUNoYWluID8gdGhpcy5wcm9wZXJ0eS5sYXN0UHJvcGVydHkgOiBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIXByb3BlcnR5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEVycm9yQ29uZGl0aW9ucztcclxuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbnMgPSBjb25kaXRpb25UYXJnZXRzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5wcm9wZXJ0aWVzLmluZGV4T2YocHJvcGVydHkpID49IDA7IH0pLm1hcChmdW5jdGlvbiAoY29uZGl0aW9uVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uZGl0aW9uVGFyZ2V0LmNvbmRpdGlvbjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbmRpdGlvbnMgPSBjb25kaXRpb25zLmNvbmNhdChmb3JtYXRFcnJvckNvbmRpdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25kaXRpb25zID0gY29uZGl0aW9ucy5zb3J0KGZ1bmN0aW9uIChjb25kaXRpb25BLCBjb25kaXRpb25CKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29tcGFyZShjb25kaXRpb25BLCBjb25kaXRpb25CKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25kaXRpb25zO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VQYXRoQWRhcHRlci5wcm90b3R5cGUsIFwiZm9ybWF0RXJyb3JcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRFcnJvckNvbmRpdGlvbiA/IHRoaXMuZm9ybWF0RXJyb3JDb25kaXRpb25bXCJmb3JtYXRFcnJvclwiXSA6IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgKDAsIHZ1ZV9tb2RlbF9vYnNlcnZhYmlsaXR5XzEucHJldmVudFZ1ZU9ic2VydmFiaWxpdHkpKGVycik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0RXJyb3JDb25kaXRpb24gPSBlcnIuY3JlYXRlQ29uZGl0aW9uKHRoaXMucHJvcGVydHkuZ2V0TGFzdFRhcmdldCh0aGlzLnBhcmVudC52YWx1ZSksIHRoaXMucHJvcGVydHkubGFzdFByb3BlcnR5KTtcclxuICAgICAgICAgICAgICAgICgwLCB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xLnByZXZlbnRWdWVPYnNlcnZhYmlsaXR5KShmb3JtYXRFcnJvckNvbmRpdGlvbik7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXRFcnJvckNvbmRpdGlvbltcImZvcm1hdEVycm9yXCJdID0gZXJyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRFcnJvckNvbmRpdGlvbiA9IGZvcm1hdEVycm9yQ29uZGl0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXRFcnJvckNvbmRpdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcImludmFsaWRWYWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRFcnJvci5pbnZhbGlkVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcImZpcnN0RXJyb3JcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zLmxlbmd0aCA/IHRoaXMuY29uZGl0aW9uc1swXSA6IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZVBhdGhBZGFwdGVyLnByb3RvdHlwZSwgXCJkaXNwbGF5VmFsdWVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb3JtYXRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0RXJyb3IuaW52YWxpZFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZW5zdXJlT2JzZXJ2YWJsZSh0aGlzLnByb3BlcnR5LnZhbHVlKHRoaXMucGFyZW50LnZhbHVlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXREaXNwbGF5VmFsdWUodGhpcywgdmFsdWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgICAgICBpZiAoKDAsIG1vZGVsX2pzXzYuaXNFbnRpdHlUeXBlKSh0aGlzLnByb3BlcnR5LnByb3BlcnR5VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgZGlzcGxheVZhbHVlIHByb3BlcnR5IG9mIEFkYXB0ZXJzIGZvciBlbnRpdHkgdHlwZXMuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vLyAvIFRPRE86IEltcGxlbWVudCBhdXRvLXJlZm9ybWF0P1xyXG4gICAgICAgICAgICAvLyB2YXIgaW5pdGlhbFZhbHVlID0gdGV4dDtcclxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlO1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0eS5mb3JtYXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyID0gdGhpcy5wcm9wZXJ0eS5mb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIG1vZGVsX2pzXzYuaXNWYWx1ZVR5cGUpKHRoaXMucHJvcGVydHkucHJvcGVydHlUeXBlKSAmJiB0aGlzLnByb3BlcnR5LnByb3BlcnR5VHlwZSAhPT0gU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gdXNlIHRoZSBnZW5lcmFsIGZvcm1hdCBieSBkZWZhdWx0XHJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIgPSB0aGlzLnByb3BlcnR5LmNvbnRhaW5pbmdUeXBlLm1vZGVsLmdldEZvcm1hdCh0aGlzLnByb3BlcnR5LnByb3BlcnR5VHlwZSwgXCJHXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC52YWx1ZS5tZXRhLmNsZWFyQ29uZGl0aW9uKG1vZGVsX2pzXzcuRm9ybWF0RXJyb3IuQ29uZGl0aW9uVHlwZSk7IC8vIFRPRE86IFRoaXMgc2hvdWxkbid0IGRvIGFueXRoaW5nLi4uXHJcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdEVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGZvcm1hdHRlci5jb252ZXJ0QmFjayh0ZXh0KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSBpbnN0YW5jZW9mIG1vZGVsX2pzXzcuRm9ybWF0RXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5wcmV2ZW50VnVlT2JzZXJ2YWJpbGl0eSkobmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0RXJyb3IgPSBuZXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wZXJ0eS5wcm9wZXJ0eVR5cGUgPT09IFN0cmluZyAmJiB0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIiAmJiB0ZXh0Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBibGFuayBzdHJpbmcgdG8gbnVsbFxyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSB0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcImFsbG93ZWRWYWx1ZXNSdWxlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wZXJ0eSBpbnN0YW5jZW9mIG1vZGVsX2pzXzQuUHJvcGVydHlDaGFpbikge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSB0aGlzLnByb3BlcnR5Lmxhc3RQcm9wZXJ0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BlcnR5IGluc3RhbmNlb2YgbW9kZWxfanNfMi5Qcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgcHJvcGVydHkgPSB0aGlzLnByb3BlcnR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBhbGxvd2VkVmFsdWVzUnVsZXMgPSBwcm9wZXJ0eS5ydWxlcy5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIgaW5zdGFuY2VvZiBtb2RlbF9qc18zLkFsbG93ZWRWYWx1ZXNSdWxlOyB9KTtcclxuICAgICAgICAgICAgaWYgKGFsbG93ZWRWYWx1ZXNSdWxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhbGxvd2VkVmFsdWVzUnVsZSA9IGFsbG93ZWRWYWx1ZXNSdWxlc1swXTtcclxuICAgICAgICAgICAgICAgICgwLCB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xLnByZXZlbnRWdWVPYnNlcnZhYmlsaXR5KShhbGxvd2VkVmFsdWVzUnVsZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3dlZFZhbHVlc1J1bGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcImFsbG93ZWRWYWx1ZXNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYWxsb3dlZFZhbHVlc1J1bGUgPSB0aGlzLmFsbG93ZWRWYWx1ZXNSdWxlO1xyXG4gICAgICAgICAgICBpZiAoIWFsbG93ZWRWYWx1ZXNSdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBydWxlLCByZXR1cm4gYW4gZW1wdHkgbGlzdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0YXJnZXRPYmo7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BlcnR5IGluc3RhbmNlb2YgbW9kZWxfanNfNC5Qcm9wZXJ0eUNoYWluKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRPYmogPSB0aGlzLnByb3BlcnR5LmdldExhc3RUYXJnZXQodGhpcy5wYXJlbnQudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0T2JqID0gdGhpcy5wYXJlbnQudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIHZhbHVlIG9mIGFsbG93ZWQgdmFsdWVzIHByb3BlcnR5XHJcbiAgICAgICAgICAgIHZhciBhbGxvd2VkVmFsdWVzRnJvbVJ1bGUgPSBhbGxvd2VkVmFsdWVzUnVsZS52YWx1ZXModGFyZ2V0T2JqKTtcclxuICAgICAgICAgICAgaWYgKGFsbG93ZWRWYWx1ZXNGcm9tUnVsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3VyIHZhbHVlcyB0aGF0IGFyZSBubyBsb25nZXIgdmFsaWRcclxuICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZFZhbHVlc1J1bGUuaWdub3JlVmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJJbnZhbGlkT3B0aW9ucyhhbGxvd2VkVmFsdWVzRnJvbVJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFhbGxvd2VkVmFsdWVzUnVsZS5pZ25vcmVWYWxpZGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBvdXQgdmFsdWVzIHNpbmNlIHRoZSBwcm9wZXJ0eSBkb2Vzbid0IGN1cnJlbnRseSBoYXZlIGFueSBhbGxvd2VkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckludmFsaWRPcHRpb25zKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFsbG93ZWRWYWx1ZXNGcm9tUnVsZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgbW9kZWxfanNfMS5FbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5vYnNlcnZlRW50aXR5KSh2YWx1ZSkuZW5zdXJlT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIHZ1ZV9tb2RlbF9vYnNlcnZhYmlsaXR5XzEucHJldmVudFZ1ZU9ic2VydmFiaWxpdHkpKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvd2VkVmFsdWVzRnJvbVJ1bGU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZVBhdGhBZGFwdGVyLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgLy8gRGVzdHJveSBleGlzdGluZyBvcHRpb24gY29tcG9uZW50c1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uc1RvRGVzdHJveSA9IHRoaXMuJGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYyBpbnN0YW5jZW9mIHNvdXJjZV9vcHRpb25fYWRhcHRlcl8xLlNvdXJjZU9wdGlvbkFkYXB0ZXI7IH0pO1xyXG4gICAgICAgICAgICBvcHRpb25zVG9EZXN0cm95LmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuJGRlc3Ryb3koKTsgfSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHByZXNlcnZlIG9wdGlvbiBhZGFwdGVycyBpZiBwb3NzaWJsZT9cclxuICAgICAgICAgICAgdmFyIGFsbG93ZWRWYWx1ZXMgPSB0aGlzLmFsbG93ZWRWYWx1ZXM7XHJcbiAgICAgICAgICAgIGlmICghYWxsb3dlZFZhbHVlcyAmJiB0aGlzLnByb3BlcnR5LnByb3BlcnR5VHlwZSA9PT0gQm9vbGVhbikge1xyXG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSB0cnVlIGFuZCBmYWxzZSBhcyBzcGVjaWFsIGFsbG93ZWQgdmFsdWVzIGZvciBib29sZWFuc1xyXG4gICAgICAgICAgICAgICAgYWxsb3dlZFZhbHVlcyA9IFt0cnVlLCBmYWxzZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhbGxvd2VkVmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTWFwIHRoZSBhbGxvd2VkIHZhbHVlcyB0byBvcHRpb24gYWRhcHRlcnNcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG93ZWRWYWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgc291cmNlX29wdGlvbl9hZGFwdGVyXzEuU291cmNlT3B0aW9uQWRhcHRlcih7IHBhcmVudDogX3RoaXMsIHByb3BzRGF0YTogeyB2YWx1ZTogdiB9IH0pOyB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcIml0ZW1zXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XHJcbiAgICAgICAgICAgIC8vIENvbGxlY3QgZXhpc3Rpbmcgb3B0aW9uIGNvbXBvbmVudHMgdG8gcG90ZW50aWFsbHkgYmUgZGVzdHJveWVkXHJcbiAgICAgICAgICAgIHZhciBleGlzdGluZ0l0ZW1zVG9EZXN0cm95ID0gdGhpcy4kY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjIGluc3RhbmNlb2Ygc291cmNlX2l0ZW1fYWRhcHRlcl8xLlNvdXJjZUl0ZW1BZGFwdGVyOyB9KTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKDAsIG1vZGVsX2pzXzYuaXNFbnRpdHlUeXBlKSh0aGlzLnByb3BlcnR5LnByb3BlcnR5VHlwZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdJdGVtc01hcF8xID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJdGVtc1RvRGVzdHJveS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGFwdGVyID0gYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZGFwdGVyLmlzT3JwaGFuZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBhZGFwdGVyLnZhbHVlID8gYWRhcHRlci52YWx1ZS5tZXRhLmlkIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0l0ZW1zTWFwXzFba2V5XSA9IGFkYXB0ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB2YWx1ZVtpXS5tZXRhLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdJdGVtID0gZXhpc3RpbmdJdGVtc01hcF8xW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0l0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZSB0aGUgZXhpc3RpbmcgaXRlbSBmcm9tIHRoZSBtYXAgc28gdGhhdCBpdCBjYW4ndCBiZSBmZXRjaGVkIG1vcmUgdGhhbiBvbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXhpc3RpbmdJdGVtc01hcF8xW2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIHRoZSBsaXN0IG9mIGl0ZW1zIHRvIGRlc3Ryb3kgc2luY2Ugd2UncmUgZ29pbmcgdG8gcmV1c2UgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0l0ZW1JbmRleCA9IGV4aXN0aW5nSXRlbXNUb0Rlc3Ryb3kuaW5kZXhPZihleGlzdGluZ0l0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nSXRlbUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0l0ZW1zVG9EZXN0cm95LnNwbGljZShleGlzdGluZ0l0ZW1JbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGJhY2tpbmcgc3RvcmFnZSBmb3IgdGhlICdpbmRleCcgcHJvcCwgdGhlIGludGVybmFsIGRhdGEgc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGhhdmUgdGhpcyB2YWx1ZSwgdGhpcyBqdXN0IG1ha2VzIHRoZSBjb21wb25lbnQncyBzdGF0ZSBjb25zaXN0ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgdGhlIGluY29uc2lzdGVuY3kgaXMganVzdCBhIHNpZGUtZWZmZWN0IG9mIHJldXNpbmcgaXRlbSBhZGFwdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzRGF0YSA9IGV4aXN0aW5nSXRlbS4kb3B0aW9ucy5wcm9wc0RhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wc0RhdGEuaW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVkZSB0aGUgZXhpc3RpbmcgaXRlbSBpbiB0aGUgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGV4aXN0aW5nSXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBuZXcgaXRlbSBhZGFwdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SXRlbSA9IG5ldyBzb3VyY2VfaXRlbV9hZGFwdGVyXzEuU291cmNlSXRlbUFkYXB0ZXIoeyBwYXJlbnQ6IHRoaXMsIHByb3BzRGF0YTogeyBpbmRleDogaSwgcGFyZW50U291cmNlOiB0aGlzIH0gfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJzY3JpYmVzIHRvIGNoYW5nZXMgdG8gaXRzIHVuZGVybHlpbmcgbGlzdCBzb3VyY2UgaW4gb3JkZXIgdG8gdXBkYXRlIGl0cyBpbmRleCBhbmQgZGV0ZWN0IHdoZW4gaXQgYmVjb21lcyBvcnBoYW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SXRlbS5zdWJzY3JpYmVUb1NvdXJjZUNoYW5nZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIG5ldyBpdGVtIGluIHRoZSByZXR1cm4gdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobmV3SXRlbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhpc3RpbmdJdGVtc1RvRGVzdHJveS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLiRkZXN0cm95KCk7IH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoY29uZGl0aW9uVGFyZ2V0QSwgY29uZGl0aW9uVGFyZ2V0Qikge1xyXG4gICAgICAgIGlmIChjb25kaXRpb25UYXJnZXRBW1wiZm9ybWF0RXJyb3JcIl0gaW5zdGFuY2VvZiBtb2RlbF9qc183LkZvcm1hdEVycm9yIHx8IGNvbmRpdGlvblRhcmdldEJbXCJmb3JtYXRFcnJvclwiXSBpbnN0YW5jZW9mIG1vZGVsX2pzXzcuRm9ybWF0RXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvblRhcmdldEFbXCJmb3JtYXRFcnJvclwiXSBpbnN0YW5jZW9mIG1vZGVsX2pzXzcuRm9ybWF0RXJyb3IgJiYgY29uZGl0aW9uVGFyZ2V0QltcImZvcm1hdEVycm9yXCJdIGluc3RhbmNlb2YgbW9kZWxfanNfNy5Gb3JtYXRFcnJvciA/IDAgOlxyXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uVGFyZ2V0QVtcImZvcm1hdEVycm9yXCJdIGluc3RhbmNlb2YgbW9kZWxfanNfNy5Gb3JtYXRFcnJvciA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uZGl0aW9uVGFyZ2V0QVtcInNvdXJjZVwiXSBpbnN0YW5jZW9mIG1vZGVsX2pzXzEuUmVxdWlyZWRSdWxlIHx8IGNvbmRpdGlvblRhcmdldEJbXCJzb3VyY2VcIl0gaW5zdGFuY2VvZiBtb2RlbF9qc18xLlJlcXVpcmVkUnVsZSlcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvblRhcmdldEFbXCJzb3VyY2VcIl0gaW5zdGFuY2VvZiBtb2RlbF9qc18xLlJlcXVpcmVkUnVsZSAmJiBjb25kaXRpb25UYXJnZXRCW1wic291cmNlXCJdIGluc3RhbmNlb2YgbW9kZWxfanNfMS5SZXF1aXJlZFJ1bGUgPyAwIDpcclxuICAgICAgICAgICAgICAgIGNvbmRpdGlvblRhcmdldEFbXCJzb3VyY2VcIl0gaW5zdGFuY2VvZiBtb2RlbF9qc18xLlJlcXVpcmVkUnVsZSA/IC0xIDogMTtcclxuICAgICAgICBlbHNlIGlmIChjb25kaXRpb25UYXJnZXRBLnR5cGUuY2F0ZWdvcnkgPT09IFwiRXJyb3JcIiB8fCBjb25kaXRpb25UYXJnZXRCLnR5cGUuY2F0ZWdvcnkgPT09IFwiRXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmRpdGlvblRhcmdldEEudHlwZS5jYXRlZ29yeSA9PT0gXCJFcnJvclwiICYmIGNvbmRpdGlvblRhcmdldEIudHlwZS5jYXRlZ29yeSA9PT0gXCJFcnJvclwiID8gMCA6XHJcbiAgICAgICAgICAgICAgICBjb25kaXRpb25UYXJnZXRBLnR5cGUuY2F0ZWdvcnkgPT09IFwiRXJyb3JcIiA/IC0xIDogMTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgfTtcclxuICAgIFNvdXJjZVBhdGhBZGFwdGVyLnByb3RvdHlwZS5jbGVhckludmFsaWRPcHRpb25zID0gZnVuY3Rpb24gKGFsbG93ZWRWYWx1ZXMpIHtcclxuICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLnByb3BlcnR5O1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgaWYgKGFsbG93ZWRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9wdGlvbiB2YWx1ZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHZhbGlkXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGFycmF5LmJhdGNoVXBkYXRlKGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZyb20gdGhlIGBwdXJnZSgpYCBmdW5jdGlvbiBpbiBFeG9XZWIuLi5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd2VkVmFsdWVzLmluZGV4T2YoaXRlbSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheS5zcGxpY2UoaS0tLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSBudWxsICYmIGFsbG93ZWRWYWx1ZXMuaW5kZXhPZih2YWx1ZSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS52YWx1ZSh0aGlzLnBhcmVudC52YWx1ZSwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICB2YWx1ZS5zcGxpY2UoMCwgdmFsdWUubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcHJvcGVydHkudmFsdWUodGhpcy5wYXJlbnQudmFsdWUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBTb3VyY2VQYXRoQWRhcHRlci5wcm90b3R5cGUuZW5zdXJlT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBpZiAobW9kZWxfanNfNS5PYnNlcnZhYmxlQXJyYXkuaXNPYnNlcnZhYmxlQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5vYnNlcnZlQXJyYXkpKHZhbHVlKS5lbnN1cmVPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB2YWx1ZVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgbW9kZWxfanNfMS5FbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5vYnNlcnZlRW50aXR5KShpdGVtKS5lbnN1cmVPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBtb2RlbF9qc18xLkVudGl0eSkge1xyXG4gICAgICAgICAgICAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5vYnNlcnZlRW50aXR5KSh2YWx1ZSkuZW5zdXJlT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBcIlNvdXJjZVsnXCIgKyB0aGlzLnNvdXJjZSArIFwiJ11cIjtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgdnVlX3Byb3BlcnR5X2RlY29yYXRvcl8xLlByb3ApKFN0cmluZyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFNvdXJjZVBhdGhBZGFwdGVyLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuUHJvcCkoT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU291cmNlUGF0aEFkYXB0ZXIucHJvdG90eXBlLCBcIm92ZXJyaWRlc1wiLCB2b2lkIDApO1xyXG4gICAgU291cmNlUGF0aEFkYXB0ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuQ29tcG9uZW50XHJcbiAgICBdLCBTb3VyY2VQYXRoQWRhcHRlcik7XHJcbiAgICByZXR1cm4gU291cmNlUGF0aEFkYXB0ZXI7XHJcbn0odnVlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLlNvdXJjZVBhdGhBZGFwdGVyID0gU291cmNlUGF0aEFkYXB0ZXI7XHJcbmZ1bmN0aW9uIGZvcm1hdERpc3BsYXlWYWx1ZShhZGFwdGVyLCB2YWx1ZSkge1xyXG4gICAgdmFyIGRpc3BsYXlWYWx1ZTtcclxuICAgIHZhciBwcm9wZXJ0eSA9IGFkYXB0ZXIucHJvcGVydHk7XHJcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGRpc3BsYXlWYWx1ZSA9IFwiXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwcm9wZXJ0eS5mb3JtYXQgIT0gbnVsbCkge1xyXG4gICAgICAgIC8vIFVzZSBhIG1hcmt1cCBvciBwcm9wZXJ0eSBmb3JtYXQgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IHZhbHVlO1xyXG4gICAgICAgICAgICBkaXNwbGF5VmFsdWUgPSBhcnJheS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIHByb3BlcnR5LmZvcm1hdC5jb252ZXJ0KGl0ZW0pOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlWYWx1ZSA9IHByb3BlcnR5LmZvcm1hdC5jb252ZXJ0KHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIC8vIElmIG5vIGZvcm1hdCBleGlzdHMsIHRoZW4gZmFsbCBiYWNrIHRvIHRvU3RyaW5nXHJcbiAgICAgICAgdmFyIGFycmF5ID0gdmFsdWU7XHJcbiAgICAgICAgZGlzcGxheVZhbHVlID0gYXJyYXkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRpc3BsYXlWYWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBkaXNwbGF5VmFsdWUgPSBBcnJheS5pc0FycmF5KGRpc3BsYXlWYWx1ZSkgPyBkaXNwbGF5VmFsdWUuam9pbihcIiwgXCIpIDogZGlzcGxheVZhbHVlO1xyXG4gICAgcmV0dXJuIGRpc3BsYXlWYWx1ZTtcclxufVxyXG5leHBvcnRzLmZvcm1hdERpc3BsYXlWYWx1ZSA9IGZvcm1hdERpc3BsYXlWYWx1ZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgX19tZXRhZGF0YSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcclxufTtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlNvdXJjZVBhdGhNaXhpbiA9IHZvaWQgMDtcclxudmFyIHZ1ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ2dWVcIikpO1xyXG52YXIgdnVlX3Byb3BlcnR5X2RlY29yYXRvcl8xID0gcmVxdWlyZShcInZ1ZS1wcm9wZXJ0eS1kZWNvcmF0b3JcIik7XHJcbnZhciBzb3VyY2VfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vc291cmNlLWFkYXB0ZXJcIik7XHJcbnZhciBzb3VyY2VfcGF0aF9hZGFwdGVyXzEgPSByZXF1aXJlKFwiLi9zb3VyY2UtcGF0aC1hZGFwdGVyXCIpO1xyXG4vLyBAdHMtaWdub3JlXHJcbnZhciBTb3VyY2VQYXRoTWl4aW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoU291cmNlUGF0aE1peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU291cmNlUGF0aE1peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFNvdXJjZVBhdGhNaXhpbi5wcm90b3R5cGUub25MYWJlbENoYW5nZWQgPSBmdW5jdGlvbiAobGFiZWwpIHtcclxuICAgICAgICB0aGlzLm9uT3ZlcnJpZGVWYWx1ZUNoYW5nZWQobGFiZWwsIFN0cmluZyk7XHJcbiAgICB9O1xyXG4gICAgU291cmNlUGF0aE1peGluLnByb3RvdHlwZS5vbkhlbHB0ZXh0Q2hhbmdlZCA9IGZ1bmN0aW9uIChoZWxwdGV4dCkge1xyXG4gICAgICAgIHRoaXMub25PdmVycmlkZVZhbHVlQ2hhbmdlZChoZWxwdGV4dCwgU3RyaW5nKTtcclxuICAgIH07XHJcbiAgICBTb3VyY2VQYXRoTWl4aW4ucHJvdG90eXBlLm9uUmVhZG9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHJlYWRvbmx5KSB7XHJcbiAgICAgICAgdGhpcy5vbk92ZXJyaWRlVmFsdWVDaGFuZ2VkKHJlYWRvbmx5LCBCb29sZWFuKTtcclxuICAgIH07XHJcbiAgICBTb3VyY2VQYXRoTWl4aW4ucHJvdG90eXBlLm9uUmVxdWlyZWRDaGFuZ2VkID0gZnVuY3Rpb24gKHJlcXVpcmVkKSB7XHJcbiAgICAgICAgdGhpcy5vbk92ZXJyaWRlVmFsdWVDaGFuZ2VkKHJlcXVpcmVkLCBCb29sZWFuKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUGF0aE1peGluLnByb3RvdHlwZSwgXCIkc291cmNlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHNvdXJjZSBpcyBhbiBhZGFwdGVyLCB0aGVuIHBvdGVudGlhbGx5IGFwcGx5IG92ZXJyaWRlcywgYW5kIHJldHVybiBpdFxyXG4gICAgICAgICAgICBpZiAoKDAsIHNvdXJjZV9hZGFwdGVyXzEuaXNTb3VyY2VBZGFwdGVyKSh0aGlzLnNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlT3ZlcnJpZGVzQXBwbGllZFRvU291cmNlQWRhcHRlcih0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzb3VyY2VfcGF0aF9hZGFwdGVyXzEuU291cmNlUGF0aEFkYXB0ZXIoeyBwYXJlbnQ6IHRoaXMsIHByb3BzRGF0YTogeyBzb3VyY2U6IHRoaXMuc291cmNlLCBvdmVycmlkZXM6IHRoaXMgfSB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBTb3VyY2VQYXRoTWl4aW4ucHJvdG90eXBlLmVuc3VyZU92ZXJyaWRlc0FwcGxpZWRUb1NvdXJjZUFkYXB0ZXIgPSBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgdmFyIGhhc092ZXJyaWRlcyA9ICgwLCBzb3VyY2VfYWRhcHRlcl8xLmhhc092ZXJyaWRlVmFsdWUpKHRoaXMubGFiZWwsIFN0cmluZykgfHwgKDAsIHNvdXJjZV9hZGFwdGVyXzEuaGFzT3ZlcnJpZGVWYWx1ZSkodGhpcy5oZWxwdGV4dCwgU3RyaW5nKSB8fCAoMCwgc291cmNlX2FkYXB0ZXJfMS5oYXNPdmVycmlkZVZhbHVlKSh0aGlzLnJlYWRvbmx5LCBCb29sZWFuKSB8fCAoMCwgc291cmNlX2FkYXB0ZXJfMS5oYXNPdmVycmlkZVZhbHVlKSh0aGlzLnJlcXVpcmVkLCBCb29sZWFuKTtcclxuICAgICAgICBpZiAoKDAsIHNvdXJjZV9hZGFwdGVyXzEuaXNTb3VyY2VQYXRoQWRhcHRlcikoc291cmNlKSkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLm92ZXJyaWRlcyAmJiBzb3VyY2Uub3ZlcnJpZGVzICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3ZlcnJpZGVzIGhhdmUgYWxyZWFkeSBiZWVuIGFwcGxpZWQgdG8gc291cmNlIG9mIHR5cGUgJ1wiICsgc291cmNlLmNvbnN0cnVjdG9yLm5hbWUgKyBcIicuXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGdpdmVuIG92ZXJyaWRlcyBhcyB0aGUgb3ZlcnJpZGVzIGZvciB0aGUgc291cmNlXHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uub3ZlcnJpZGVzID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGhhc092ZXJyaWRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IG92ZXJyaWRlcyB0byBzb3VyY2Ugb2YgdHlwZSAnXCIgKyBzb3VyY2UuY29uc3RydWN0b3IubmFtZSArIFwiJy5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgU291cmNlUGF0aE1peGluLnByb3RvdHlwZS5vbk92ZXJyaWRlVmFsdWVDaGFuZ2VkID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIHNvdXJjZSBpcyBhbiBhZGFwdGVyLCBhbmQgYW4gb3ZlcnJpZGUgdmFsdWUgaXMgc2V0LCB0aGVuIGVuc3VyZSB0aGF0IHRoZVxyXG4gICAgICAgIGlmICgoMCwgc291cmNlX2FkYXB0ZXJfMS5pc1NvdXJjZUFkYXB0ZXIpKHRoaXMuc291cmNlKSAmJiAoMCwgc291cmNlX2FkYXB0ZXJfMS5oYXNPdmVycmlkZVZhbHVlKSh2YWx1ZSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnN1cmVPdmVycmlkZXNBcHBsaWVkVG9Tb3VyY2VBZGFwdGVyKHRoaXMuc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMS5Qcm9wKSh7IHR5cGU6IFtTdHJpbmcsIE9iamVjdF0gfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIFNvdXJjZVBhdGhNaXhpbi5wcm90b3R5cGUsIFwic291cmNlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgdnVlX3Byb3BlcnR5X2RlY29yYXRvcl8xLlByb3ApKFN0cmluZyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIFNvdXJjZVBhdGhNaXhpbi5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuV2F0Y2gpKFwibGFiZWxcIiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBTb3VyY2VQYXRoTWl4aW4ucHJvdG90eXBlLCBcIm9uTGFiZWxDaGFuZ2VkXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMS5Qcm9wKShTdHJpbmcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBTb3VyY2VQYXRoTWl4aW4ucHJvdG90eXBlLCBcImhlbHB0ZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgdnVlX3Byb3BlcnR5X2RlY29yYXRvcl8xLldhdGNoKShcImhlbHB0ZXh0XCIpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxyXG4gICAgXSwgU291cmNlUGF0aE1peGluLnByb3RvdHlwZSwgXCJvbkhlbHB0ZXh0Q2hhbmdlZFwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuUHJvcCkoeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBudWxsIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgU291cmNlUGF0aE1peGluLnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMS5XYXRjaCkoXCJyZWFkb25seVwiKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXHJcbiAgICBdLCBTb3VyY2VQYXRoTWl4aW4ucHJvdG90eXBlLCBcIm9uUmVhZG9ubHlDaGFuZ2VkXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMS5Qcm9wKSh7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IG51bGwgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTb3VyY2VQYXRoTWl4aW4ucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgdnVlX3Byb3BlcnR5X2RlY29yYXRvcl8xLldhdGNoKShcInJlcXVpcmVkXCIpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIFNvdXJjZVBhdGhNaXhpbi5wcm90b3R5cGUsIFwib25SZXF1aXJlZENoYW5nZWRcIiwgbnVsbCk7XHJcbiAgICBTb3VyY2VQYXRoTWl4aW4gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuQ29tcG9uZW50XHJcbiAgICBdLCBTb3VyY2VQYXRoTWl4aW4pO1xyXG4gICAgcmV0dXJuIFNvdXJjZVBhdGhNaXhpbjtcclxufSh2dWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuU291cmNlUGF0aE1peGluID0gU291cmNlUGF0aE1peGluO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBfX21ldGFkYXRhID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xyXG59O1xyXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU291cmNlUm9vdEFkYXB0ZXIgPSB2b2lkIDA7XHJcbnZhciB2dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidnVlXCIpKTtcclxudmFyIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCJ2dWUtcHJvcGVydHktZGVjb3JhdG9yXCIpO1xyXG4vLyBAdHMtaWdub3JlXHJcbnZhciBTb3VyY2VSb290QWRhcHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhTb3VyY2VSb290QWRhcHRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNvdXJjZVJvb3RBZGFwdGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnJlYWRvbmx5ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZVJvb3RBZGFwdGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudGl0eTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUm9vdEFkYXB0ZXIucHJvdG90eXBlLCBcInR5cGVcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnRpdHkubWV0YS50eXBlLmpzdHlwZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUm9vdEFkYXB0ZXIucHJvdG90eXBlLCBcImlzTGlzdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlUm9vdEFkYXB0ZXIucHJvdG90eXBlLCBcImRpc3BsYXlWYWx1ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVudGl0eS50b1N0cmluZygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIFNvdXJjZVJvb3RBZGFwdGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRpdHkubWV0YS50eXBlLmZ1bGxOYW1lICsgXCJ8XCIgKyB0aGlzLmVudGl0eS5tZXRhLmlkO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuUHJvcCkoT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgU291cmNlUm9vdEFkYXB0ZXIucHJvdG90eXBlLCBcImVudGl0eVwiLCB2b2lkIDApO1xyXG4gICAgU291cmNlUm9vdEFkYXB0ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuQ29tcG9uZW50XHJcbiAgICBdLCBTb3VyY2VSb290QWRhcHRlcik7XHJcbiAgICByZXR1cm4gU291cmNlUm9vdEFkYXB0ZXI7XHJcbn0odnVlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLlNvdXJjZVJvb3RBZGFwdGVyID0gU291cmNlUm9vdEFkYXB0ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XHJcbn07XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Tb3VyY2VSb290TWl4aW4gPSB2b2lkIDA7XHJcbnZhciB2dWVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwidnVlXCIpKTtcclxudmFyIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCJ2dWUtcHJvcGVydHktZGVjb3JhdG9yXCIpO1xyXG52YXIgbW9kZWxfanNfMSA9IHJlcXVpcmUoXCJAY29nbml0b2Zvcm1zL21vZGVsLmpzXCIpO1xyXG52YXIgc291cmNlX3Jvb3RfYWRhcHRlcl8xID0gcmVxdWlyZShcIi4vc291cmNlLXJvb3QtYWRhcHRlclwiKTtcclxudmFyIHZ1ZV9tb2RlbF9vYnNlcnZhYmlsaXR5XzEgPSByZXF1aXJlKFwiLi92dWUtbW9kZWwtb2JzZXJ2YWJpbGl0eVwiKTtcclxuLy8gQHRzLWlnbm9yZVxyXG52YXIgU291cmNlUm9vdE1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFNvdXJjZVJvb3RNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFNvdXJjZVJvb3RNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBTb3VyY2VSb290TWl4aW4ucHJvdG90eXBlLm9uUmVhZG9ubHlDaGFuZ2VkID0gZnVuY3Rpb24gKHJlYWRvbmx5KSB7XHJcbiAgICAgICAgdGhpcy4kc291cmNlLnJlYWRvbmx5ID0gcmVhZG9ubHk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvdXJjZVJvb3RNaXhpbi5wcm90b3R5cGUsIFwiJHNvdXJjZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRpdHk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZSBpbnN0YW5jZW9mIG1vZGVsX2pzXzEuRW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkgPSB0aGlzLnNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eSA9IHRoaXNbdGhpcy5zb3VyY2UgfHwgXCJlbnRpdHlcIl07XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVudGl0eSB8fCAhKGVudGl0eSBpbnN0YW5jZW9mIG1vZGVsX2pzXzEuRW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGVudGl0eSBkYXRhIVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5vYnNlcnZlRW50aXR5KShlbnRpdHkpLmVuc3VyZU9ic2VydmFibGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBzb3VyY2Vfcm9vdF9hZGFwdGVyXzEuU291cmNlUm9vdEFkYXB0ZXIoeyBwYXJlbnQ6IHRoaXMsIHByb3BzRGF0YTogeyBlbnRpdHk6IGVudGl0eSB9IH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgICgwLCB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuUHJvcCkoeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBTb3VyY2VSb290TWl4aW4ucHJvdG90eXBlLCBcInNvdXJjZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgKDAsIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMS5Qcm9wKSh7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IG51bGwgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBTb3VyY2VSb290TWl4aW4ucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICAoMCwgdnVlX3Byb3BlcnR5X2RlY29yYXRvcl8xLldhdGNoKShcInJlYWRvbmx5XCIpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcclxuICAgIF0sIFNvdXJjZVJvb3RNaXhpbi5wcm90b3R5cGUsIFwib25SZWFkb25seUNoYW5nZWRcIiwgbnVsbCk7XHJcbiAgICBTb3VyY2VSb290TWl4aW4gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuQ29tcG9uZW50XHJcbiAgICBdLCBTb3VyY2VSb290TWl4aW4pO1xyXG4gICAgcmV0dXJuIFNvdXJjZVJvb3RNaXhpbjtcclxufSh2dWVfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuU291cmNlUm9vdE1peGluID0gU291cmNlUm9vdE1peGluO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5WTVJvb3QgPSB2b2lkIDA7XHJcbnZhciB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEgPSByZXF1aXJlKFwidnVlLXByb3BlcnR5LWRlY29yYXRvclwiKTtcclxudmFyIHZ1ZV9jbGFzc19jb21wb25lbnRfMSA9IHJlcXVpcmUoXCJ2dWUtY2xhc3MtY29tcG9uZW50XCIpO1xyXG52YXIgc291cmNlX3Jvb3RfbWl4aW5fMSA9IHJlcXVpcmUoXCIuL3NvdXJjZS1yb290LW1peGluXCIpO1xyXG4vLyBAdHMtaWdub3JlXHJcbnZhciBWTVJvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVk1Sb290LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVk1Sb290KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFZNUm9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzY29wZWRTbG90cy5kZWZhdWx0KHtcclxuICAgICAgICAgICAgJHNvdXJjZTogdGhpcy4kc291cmNlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHNsb3ROb2Rlcy5sZW5ndGggIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm91bmQgXCIgKyBzbG90Tm9kZXMubGVuZ3RoICsgXCIgbm9kZXMgaW4gZGVmYXVsdCBzbG90IGZvciBjb21wb25lbnQgJ3ZtLXJvb3QnLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNsb3ROb2Rlc1swXTtcclxuICAgIH07XHJcbiAgICBWTVJvb3QgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICB2dWVfcHJvcGVydHlfZGVjb3JhdG9yXzEuQ29tcG9uZW50XHJcbiAgICBdLCBWTVJvb3QpO1xyXG4gICAgcmV0dXJuIFZNUm9vdDtcclxufSgoMCwgdnVlX2NsYXNzX2NvbXBvbmVudF8xLm1peGlucykoc291cmNlX3Jvb3RfbWl4aW5fMS5Tb3VyY2VSb290TWl4aW4pKSk7XHJcbmV4cG9ydHMuVk1Sb290ID0gVk1Sb290O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5WTVNvdXJjZSA9IHZvaWQgMDtcclxudmFyIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMSA9IHJlcXVpcmUoXCJ2dWUtcHJvcGVydHktZGVjb3JhdG9yXCIpO1xyXG52YXIgdnVlX2NsYXNzX2NvbXBvbmVudF8xID0gcmVxdWlyZShcInZ1ZS1jbGFzcy1jb21wb25lbnRcIik7XHJcbnZhciBzb3VyY2VfcGF0aF9taXhpbl8xID0gcmVxdWlyZShcIi4vc291cmNlLXBhdGgtbWl4aW5cIik7XHJcbi8vIEB0cy1pZ25vcmVcclxudmFyIFZNU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZNU291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVk1Tb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVk1Tb3VyY2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2NvcGVkU2xvdHMuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgICRzb3VyY2U6IHRoaXMuJHNvdXJjZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChzbG90Tm9kZXMubGVuZ3RoICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvdW5kIFwiICsgc2xvdE5vZGVzLmxlbmd0aCArIFwiIG5vZGVzIGluIGRlZmF1bHQgc2xvdCBmb3IgY29tcG9uZW50ICd2bS1zb3VyY2UnLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNsb3ROb2Rlc1swXTtcclxuICAgIH07XHJcbiAgICBWTVNvdXJjZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIHZ1ZV9wcm9wZXJ0eV9kZWNvcmF0b3JfMS5Db21wb25lbnRcclxuICAgIF0sIFZNU291cmNlKTtcclxuICAgIHJldHVybiBWTVNvdXJjZTtcclxufSgoMCwgdnVlX2NsYXNzX2NvbXBvbmVudF8xLm1peGlucykoc291cmNlX3BhdGhfbWl4aW5fMS5Tb3VyY2VQYXRoTWl4aW4pKSk7XHJcbmV4cG9ydHMuVk1Tb3VyY2UgPSBWTVNvdXJjZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5WdWVNb2RlbCRpbnN0YWxsR2xvYmFsTWl4aW4gPSB2b2lkIDA7XHJcbnZhciBtb2RlbF9qc18xID0gcmVxdWlyZShcIkBjb2duaXRvZm9ybXMvbW9kZWwuanNcIik7XHJcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpO1xyXG52YXIgdnVlX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Z1ZS1oZWxwZXJzXCIpO1xyXG52YXIgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMSA9IHJlcXVpcmUoXCIuL3Z1ZS1tb2RlbC1vYnNlcnZhYmlsaXR5XCIpO1xyXG4vKipcclxuICogSW5zdGFsbHMgYSBnbG9iYWwgVnVlIG1peGluIHRoYXQgaG9va3MgaW50byBjb21wb25lbnQgZXZlbnRzIHRvIGludGVyY2VwdCBtb2RlbCBlbnRpdGllcyBhcyBjb21wb25lbnQgZGF0YSBhbmQgbWFrZSBuZWNlc2FyeSBhZGp1c3RtZW50c1xyXG4gKiBAcGFyYW0gVnVlIFRoZSBWdWUgY29uc3RydWN0b3IvbW9kdWxlIG9iamVjdFxyXG4gKi9cclxuZnVuY3Rpb24gVnVlTW9kZWwkaW5zdGFsbEdsb2JhbE1peGluKFZ1ZSkge1xyXG4gICAgVnVlLm1peGluKHtcclxuICAgICAgICBiZWZvcmVDcmVhdGU6IGZ1bmN0aW9uIFZ1ZU1vZGVsJFBsdWdpbiRiZWZvcmVDcmVhdGUoKSB7XHJcbiAgICAgICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgICAgIGlmICh2bS4kb3B0aW9ucy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbnRlcmNlcHQgZGF0YSB0aGF0IGlzIGFuIGVudGl0eSBvciBkYXRhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlbnRpdHlcclxuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhpcyBwbHVnaW4gY2FuIG1ha2UgdGhlIGVudGl0eSBvYnNlcnZhYmxlIGFuZCBjcmVhdGUgcHJveHkgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgcHJlcHJvY2Vzc0RhdGFUb0ludGVyY2VwdEVudGl0aWVzKHZtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY3JlYXRlZDogZnVuY3Rpb24gVnVlTW9kZWwkUGx1Z2luJGNyZWF0ZWQoKSB7XHJcbiAgICAgICAgICAgIHZhciB2bSA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciB2bSRwcml2YXRlID0gdm07XHJcbiAgICAgICAgICAgIGlmICh2bSRwcml2YXRlLl9lbnRpdHkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRpdHkgPSB2bSRwcml2YXRlLl9lbnRpdHk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWVudGl0eS5tZXRhLnR5cGUubW9kZWwuX2VudGl0aWVzQXJlVnVlT2JzZXJ2YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IE1vZGVsIGVudGl0aWVzIGFyZSBvYnNlcnZhYmxlIG9iamVjdHMgY29tcGF0aWJsZSB3aXRoIFZ1ZSdzIG9ic2VydmVyXHJcbiAgICAgICAgICAgICAgICAgICAgKDAsIHZ1ZV9tb2RlbF9vYnNlcnZhYmlsaXR5XzEubWFrZUVudGl0aWVzVnVlT2JzZXJ2YWJsZSkodm0kcHJpdmF0ZS5fZW50aXR5Lm1ldGEudHlwZS5tb2RlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5nZXRFbnRpdHlPYnNlcnZlcikodm0kcHJpdmF0ZS5fZW50aXR5LCB0cnVlKS5lbnN1cmVPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBkYXRhIGJ5IGF0dGVtcHRpbmcgdG8gZW11bGF0ZSB3aGF0IHdvdWxkIGhhdmUgaGFwcGVuZWQgdG9cclxuICAgICAgICAgICAgICAgIC8vIHRoZSBgZGF0YWAgb2JqZWN0IGhhZCBpdCBnb25lIHRocm91Z2ggbm9ybWFsIGNvbXBvbmVudCBpbnRpYWxpemF0aW9uXHJcbiAgICAgICAgICAgICAgICByZXN0b3JlQ29tcG9uZW50RW50aXR5RGF0YSh2bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLlZ1ZU1vZGVsJGluc3RhbGxHbG9iYWxNaXhpbiA9IFZ1ZU1vZGVsJGluc3RhbGxHbG9iYWxNaXhpbjtcclxuZnVuY3Rpb24gcmVwbGFjZUVudGl0eURhdGEodm0sIGRhdGEpIHtcclxuICAgIHZhciB2bSRwcml2YXRlID0gdm07XHJcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmIGRhdGEgaW5zdGFuY2VvZiBtb2RlbF9qc18xLkVudGl0eSkge1xyXG4gICAgICAgICgwLCBoZWxwZXJzXzEuZGVidWcpKFwiRGF0YSBpcyBhbiBlbnRpdHksIHJldHVybmluZyBlbXB0eSBvYmplY3QuLi5cIik7XHJcbiAgICAgICAgdm0kcHJpdmF0ZS5fZW50aXR5ID0gZGF0YTtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGF0YTtcclxufVxyXG5mdW5jdGlvbiBwcmVwcm9jZXNzRGF0YVRvSW50ZXJjZXB0RW50aXRpZXModm0pIHtcclxuICAgIGlmICghdm0uJG9wdGlvbnMuZGF0YSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2bS4kb3B0aW9ucy5kYXRhIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAvLyBUaGUgYC5kYXRhYCBvcHRpb25zIGlzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGludm9rZWQgYnkgVnVlLCBzbyB3cmFwIGl0XHJcbiAgICAgICAgLy8gdG8gcHJldmVudCBWdWUgZnJvbSBnZXR0aW5nIGFuIEVudGl0eSBwcmlvciB0byBzZXR0aW5nIHVwIEVudGl0eSBvYnNlcnZhYmlsaXR5XHJcbiAgICAgICAgKDAsIGhlbHBlcnNfMS5kZWJ1ZykoXCJEYXRhIGlzIGEgZnVuY3Rpb24uLi53cmFwcGluZyB0byBpbnRlcmNlcHQgdGhlIHJldHVybiB2YWx1ZS4uLlwiKTtcclxuICAgICAgICB2YXIgZGF0YUZuID0gdm0uJG9wdGlvbnMuZGF0YTtcclxuICAgICAgICB2bS4kb3B0aW9ucy5kYXRhID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVwbGFjZUVudGl0eURhdGEodm0sIGRhdGFGbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gRG9uJ3QgbGV0IFZ1ZSBmcm9tIGdldHRpbmcgYW4gRW50aXR5IHByaW9yIHRvIHNldHRpbmcgdXAgRW50aXR5IG9ic2VydmFiaWxpdHlcclxuICAgICAgICB2bS4kb3B0aW9ucy5kYXRhID0gcmVwbGFjZUVudGl0eURhdGEodm0sIHZtLiRvcHRpb25zLmRhdGEpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlc3RvcmVDb21wb25lbnRFbnRpdHlEYXRhKHZtKSB7XHJcbiAgICB2YXIgdm0kcHJpdmF0ZSA9IHZtO1xyXG4gICAgLy8gU2luY2UgdGhlIGVudGl0eSBpcyBub3cgb2JzZXJ2YWJsZSwgZ28gYWhlYWQgYW5kIGxldCB0aGUgY29tcG9uZW50IHNlZSBpdFxyXG4gICAgLy8gVE9ETzogSXMgaXQgbmVjZXNzYXJ5IHRvIHNvbWVob3cgXCJtZXJnZVwiIHRoZSBvYmplY3Q/IE9yLCBqdXN0IG5vdCBzZXQgdGhlIGRhdGFcclxuICAgIC8vICAgICAgZmllbGQgc2luY2Ugd2UncmUgZ29pbmcgdG8gZG8gY3VzdG9tIHByb3h5aW5nIG9mIHByb3BlcnRpZXMgYW55d2F5P1xyXG4gICAgdm0kcHJpdmF0ZS5fZGF0YSA9IHZtJHByaXZhdGUuX2VudGl0eTtcclxuICAgIC8vIFZ1ZSBwcm94aWVzIHRoZSBkYXRhIG9iamVjdHMgYE9iamVjdC5rZXlzKClgIG9udG8gdGhlIGNvbXBvbmVudCBpdHNlbGYsXHJcbiAgICAvLyBzbyB0aGF0IHRoZSBkYXRhIG9iamVjdHMgcHJvcGVydGllcyBjYW4gYmUgdXNlZCBkaXJlY3RseSBpbiB0ZW1wbGF0ZXNcclxuICAgIHByb3h5RW50aXR5UHJvcGVydGllc09udG9Db21wb25lbnRJbnN0YW5jZSh2bSwgdm0kcHJpdmF0ZS5fZW50aXR5KTtcclxuICAgIC8vIFRoZSBpbnRlcm5hbCBgb2JzZXJ2ZSgpYCBtZXRob2QgYmFzaWNhbGx5IG1ha2VzIHRoZSBnaXZlbiBvYmplY3Qgb2JzZXJ2YWJsZSxcclxuICAgIC8vIChlbnRpdGllcyBzaG91bGQgYWxyZWFkeSBiZSBhdCB0aGlzIHBvaW50KSBidXQgaXQgYWxzbyB1cGRhdGVzIGEgYHZtQ291bnRgIGNvdW50ZXJcclxuICAgICgwLCB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xLm9ic2VydmVFbnRpdHkpKHZtJHByaXZhdGUuX2VudGl0eSwgdHJ1ZSkuZW5zdXJlT2JzZXJ2YWJsZSgpO1xyXG4gICAgLy8gTnVsbCBvdXQgdGhlIGZpZWxkIG5vdyB0aGF0IHdlJ3ZlIGZpbmlzaGVkIHByZXBhcmluZyB0aGUgZW50aXR5XHJcbiAgICB2bSRwcml2YXRlLl9lbnRpdHkgPSBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIHByb3h5RW50aXR5UHJvcGVydGllc09udG9Db21wb25lbnRJbnN0YW5jZSh2bSwgZW50aXR5KSB7XHJcbiAgICAvLyBUT0RPOiBhZGQgcHJveGllcyBvbnRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2VcclxuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcclxuICAgIHZhciBwcm9wZXJ0aWVzID0gZW50aXR5Lm1ldGEudHlwZS5wcm9wZXJ0aWVzO1xyXG4gICAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XHJcbiAgICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgIGlmIChtZXRob2RzICYmICgwLCBoZWxwZXJzXzEuaGFzT3duUHJvcGVydHkpKG1ldGhvZHMsIHByb3BlcnR5Lm5hbWUpKSB7XHJcbiAgICAgICAgICAgICgwLCBoZWxwZXJzXzEuZGVidWcpKFwiUHJvcGVydHkgJ1wiICsgcHJvcGVydHkubmFtZSArIFwiJyBpcyBoaWRkZW4gYnkgYSBjb21wb25lbnQgbWV0aG9kIHdpdGggdGhlIHNhbWUgbmFtZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHByb3BzICYmICgwLCBoZWxwZXJzXzEuaGFzT3duUHJvcGVydHkpKHByb3BzLCBwcm9wZXJ0eS5uYW1lKSkge1xyXG4gICAgICAgICAgICAoMCwgaGVscGVyc18xLmRlYnVnKShcIlByb3BlcnR5ICdcIiArIHByb3BlcnR5Lm5hbWUgKyBcIicgaXMgaGlkZGVuIGJ5IGEgY29tcG9uZW50IHByb3Agd2l0aCB0aGUgc2FtZSBuYW1lLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoISgwLCB2dWVfaGVscGVyc18xLlZ1ZSRpc1Jlc2VydmVkKShwcm9wZXJ0eS5uYW1lKSkge1xyXG4gICAgICAgICAgICAoMCwgdnVlX2hlbHBlcnNfMS5WdWUkcHJveHkpKHZtLCBcIl9kYXRhXCIsIHByb3BlcnR5Lm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlZ1ZSRwcm94eSA9IGV4cG9ydHMuVnVlJGRlcGVuZEFycmF5ID0gZXhwb3J0cy5WdWUkaXNSZXNlcnZlZCA9IHZvaWQgMDtcclxuZnVuY3Rpb24gVnVlJGlzUmVzZXJ2ZWQoc3RyKSB7XHJcbiAgICB2YXIgYyA9IChzdHIgKyBcIlwiKS5jaGFyQ29kZUF0KDApO1xyXG4gICAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RjtcclxufVxyXG5leHBvcnRzLlZ1ZSRpc1Jlc2VydmVkID0gVnVlJGlzUmVzZXJ2ZWQ7XHJcbmZ1bmN0aW9uIFZ1ZSRkZXBlbmRBcnJheSh2YWx1ZSkge1xyXG4gICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBlID0gdmFsdWVbaV07XHJcbiAgICAgICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcclxuICAgICAgICAgICAgVnVlJGRlcGVuZEFycmF5KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLlZ1ZSRkZXBlbmRBcnJheSA9IFZ1ZSRkZXBlbmRBcnJheTtcclxuZnVuY3Rpb24gVnVlJHByb3h5KHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gVnVlTW9kZWwkcHJveHlQcm9wZXJ0eUdldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBWdWVNb2RlbCRwcm94eVByb3BlcnR5U2V0KHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5WdWUkcHJveHkgPSBWdWUkcHJveHk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZW5zdXJlVnVlSW50ZXJuYWxUeXBlcyA9IGV4cG9ydHMuVnVlTW9kZWwkVnVlID0gdm9pZCAwO1xyXG5leHBvcnRzLlZ1ZU1vZGVsJFZ1ZSA9IG51bGw7XHJcbmZ1bmN0aW9uIGVuc3VyZVZ1ZUludGVybmFsVHlwZXModGFyZ2V0LCBWdWUpIHtcclxuICAgIC8vIEV4aXQgZWFybHkgaWYgT2JzZXJ2ZXIgb3IgRGVwIGFyZSBhbHJlYWR5IGRlZmluZWRcclxuICAgIGlmICh0YXJnZXQuT2JzZXJ2ZXIgfHwgdGFyZ2V0LkRlcCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBvYnNlcnZhYmxlRGF0YTtcclxuICAgIGlmIChWdWUub2JzZXJ2YWJsZSkge1xyXG4gICAgICAgIG9ic2VydmFibGVEYXRhID0gVnVlLm9ic2VydmFibGUoe30pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IG5ldyBWdWUoe1xyXG4gICAgICAgICAgICBkYXRhOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBvYnNlcnZhYmxlRGF0YSA9IGNvbXBvbmVudC4kZGF0YTtcclxuICAgIH1cclxuICAgIHZhciBvYnNlcnZlciA9IG9ic2VydmFibGVEYXRhLl9fb2JfXztcclxuICAgIHZhciBvYnNlcnZlckN0b3IgPSBvYnNlcnZlci5jb25zdHJ1Y3RvcjtcclxuICAgIHZhciBkZXBDdG9yID0gb2JzZXJ2ZXIuZGVwLmNvbnN0cnVjdG9yO1xyXG4gICAgdGFyZ2V0Lk9ic2VydmVyID0gb2JzZXJ2ZXJDdG9yO1xyXG4gICAgdGFyZ2V0LkRlcCA9IGRlcEN0b3I7XHJcbn1cclxuZXhwb3J0cy5lbnN1cmVWdWVJbnRlcm5hbFR5cGVzID0gZW5zdXJlVnVlSW50ZXJuYWxUeXBlcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5tYWtlRW50aXRpZXNWdWVPYnNlcnZhYmxlID0gZXhwb3J0cy5kZXBlbmRDaGlsZEFycmF5ID0gZXhwb3J0cy5nZXRBcnJheU9ic2VydmVyQ29uc3RydWN0b3IgPSBleHBvcnRzLmdldEFycmF5T2JzZXJ2ZXIgPSBleHBvcnRzLm9ic2VydmVBcnJheSA9IGV4cG9ydHMuZ2V0T2JqZWN0TWV0YU9ic2VydmVyQ29uc3RydWN0b3IgPSBleHBvcnRzLmdldE9iamVjdE1ldGFPYnNlcnZlciA9IGV4cG9ydHMuZ2V0RW50aXR5T2JzZXJ2ZXJDb25zdHJ1Y3RvciA9IGV4cG9ydHMuZ2V0RW50aXR5T2JzZXJ2ZXIgPSBleHBvcnRzLm9ic2VydmVFbnRpdHkgPSBleHBvcnRzLnByZXZlbnRWdWVPYnNlcnZhYmlsaXR5ID0gZXhwb3J0cy5nZXRDdXN0b21PYnNlcnZlckNvbnN0cnVjdG9yID0gdm9pZCAwO1xyXG52YXIgdnVlXzEgPSByZXF1aXJlKFwidnVlXCIpO1xyXG52YXIgbW9kZWxfanNfMSA9IHJlcXVpcmUoXCJAY29nbml0b2Zvcm1zL21vZGVsLmpzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1kdXBsaWNhdGVzXHJcbnZhciBtb2RlbF9qc18yID0gcmVxdWlyZShcIkBjb2duaXRvZm9ybXMvbW9kZWwuanNcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWR1cGxpY2F0ZXNcclxudmFyIG1vZGVsX2pzXzMgPSByZXF1aXJlKFwiQGNvZ25pdG9mb3Jtcy9tb2RlbC5qc1wiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tZHVwbGljYXRlc1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIi4vaGVscGVyc1wiKTtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxyXG52YXIgQ3VzdG9tT2JzZXJ2ZXJDb25zdHJ1Y3RvciA9IG51bGw7XHJcbmZ1bmN0aW9uIGdldEN1c3RvbU9ic2VydmVyQ29uc3RydWN0b3IoKSB7XHJcbiAgICByZXR1cm4gQ3VzdG9tT2JzZXJ2ZXJDb25zdHJ1Y3RvciB8fCAoQ3VzdG9tT2JzZXJ2ZXJDb25zdHJ1Y3RvciA9IHJlcXVpcmUoXCIuL2N1c3RvbS1vYnNlcnZlclwiKS5DdXN0b21PYnNlcnZlcik7XHJcbn1cclxuZXhwb3J0cy5nZXRDdXN0b21PYnNlcnZlckNvbnN0cnVjdG9yID0gZ2V0Q3VzdG9tT2JzZXJ2ZXJDb25zdHJ1Y3RvcjtcclxuZnVuY3Rpb24gcHJldmVudFZ1ZU9ic2VydmFiaWxpdHkob2JqKSB7XHJcbiAgICBpZiAob2JqKSB7XHJcbiAgICAgICAgaWYgKCEoMCwgaGVscGVyc18xLmhhc093blByb3BlcnR5KShvYmosIFwiX19vYl9fXCIpKSB7XHJcbiAgICAgICAgICAgIC8vIE1hcmsgdGhlIG9iamVjdCBhcyBcInJhd1wiIHNvIHRoYXQgVnVlIHdvbid0IHRyeSB0byBtYWtlIGl0IG9ic2VydmFibGVcclxuICAgICAgICAgICAgKDAsIHZ1ZV8xLm1hcmtSYXcpKG9iaik7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVnVlJ3MgZGVmYXVsdCBvYnNlcnZhYmlsaXR5IGlzIGFsc28gYnlwYXNzZWQgaWYgdGhlIG9iamVjdCdzIG9ic2VydmVyIGlzIGEgc3ViY2xhc3Mgb2YgYEN1c3RvbU9ic2VydmVyYFxyXG4gICAgICAgICAgICB2YXIgQ3VzdG9tT2JzZXJ2ZXIgPSBnZXRDdXN0b21PYnNlcnZlckNvbnN0cnVjdG9yKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmouX19vYl9fIGluc3RhbmNlb2YgQ3VzdG9tT2JzZXJ2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucHJldmVudFZ1ZU9ic2VydmFiaWxpdHkgPSBwcmV2ZW50VnVlT2JzZXJ2YWJpbGl0eTtcclxuLyoqXHJcbiAqIEJhc2VkIG9uIFZ1ZSdzIGludGVybmFsIGBvYnNlcnZlKClgIGZ1bmN0aW9uLiBFbnN1cmVzIHRoYXQgdGhlIGdpdmVuIGVudGl0eVxyXG4gKiBpcyBvYnNlcnZhYmxlIGFuZCBvcHRpb25hbGx5IG5vdGVzIHRoYXQgaXQgaXMgcmVmZXJlbmNlZCBieSBhIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gZW50aXR5IFRoZSBlbnRpdHkgdG8gb2JzZXJ2ZVxyXG4gKiBAcGFyYW0gYXNSb290RGF0YSBUaGUgZW50aXR5IGlzIHJlZmVyZW5jZWQgYXMgYSBjb21wb25lbnQncyBkYXRhXHJcbiAqL1xyXG5mdW5jdGlvbiBvYnNlcnZlRW50aXR5KGVudGl0eSwgYXNSb290RGF0YSkge1xyXG4gICAgaWYgKGFzUm9vdERhdGEgPT09IHZvaWQgMCkgeyBhc1Jvb3REYXRhID0gZmFsc2U7IH1cclxuICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBtb2RlbF9qc18yLkVudGl0eSkge1xyXG4gICAgICAgIHZhciBvYiA9IGdldEVudGl0eU9ic2VydmVyKGVudGl0eSwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGVudGl0eS5tZXRhKSB7XHJcbiAgICAgICAgICAgIGdldE9iamVjdE1ldGFPYnNlcnZlcihlbnRpdHkubWV0YSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XHJcbiAgICAgICAgICAgIG9iLnZtQ291bnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVE9ETzogV2FybiBhYm91dCBhdHRlbXB0aW5nIHRvIG9ic2VydmUgbm9uLWVudGl0eT9cclxuICAgIH1cclxufVxyXG5leHBvcnRzLm9ic2VydmVFbnRpdHkgPSBvYnNlcnZlRW50aXR5O1xyXG4vKipcclxuICogR2V0cyBvciBjcmVhdGVzIGFuIGBFbnRpdHlPYnNlcnZlcmAgZm9yIHRoZSBnaXZlbiBlbnRpdHlcclxuICogQHBhcmFtIGVudGl0eSBUaGUgZW50aXR5IGJlZ2luIG9ic2VydmVkXHJcbiAqIEBwYXJhbSBjcmVhdGUgSWYgdHJ1ZSwgY3JlYXRlIHRoZSBvYnNlcnZlciBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcclxuICovXHJcbmZ1bmN0aW9uIGdldEVudGl0eU9ic2VydmVyKGVudGl0eSwgY3JlYXRlKSB7XHJcbiAgICBpZiAoY3JlYXRlID09PSB2b2lkIDApIHsgY3JlYXRlID0gZmFsc2U7IH1cclxuICAgIHZhciBFbnRpdHlPYnNlcnZlciA9IGdldEVudGl0eU9ic2VydmVyQ29uc3RydWN0b3IoKTtcclxuICAgIGlmICgoMCwgaGVscGVyc18xLmhhc093blByb3BlcnR5KShlbnRpdHksIFwiX19vYl9fXCIpICYmICgwLCBoZWxwZXJzXzEuZ2V0UHJvcCkoZW50aXR5LCBcIl9fb2JfX1wiKSBpbnN0YW5jZW9mIEVudGl0eU9ic2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCBoZWxwZXJzXzEuZ2V0UHJvcCkoZW50aXR5LCBcIl9fb2JfX1wiKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNyZWF0ZSkge1xyXG4gICAgICAgIC8vIE1hcmsgdGhlIGVudGl0eSBhcyBcInJhd1wiIHNvIHRoYXQgVnVlIHdvbid0IHRyeSB0byBtYWtlIGl0IG9ic2VydmFibGVcclxuICAgICAgICAoMCwgdnVlXzEubWFya1JhdykoZW50aXR5KTtcclxuICAgICAgICByZXR1cm4gbmV3IEVudGl0eU9ic2VydmVyKGVudGl0eSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldEVudGl0eU9ic2VydmVyID0gZ2V0RW50aXR5T2JzZXJ2ZXI7XHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcclxudmFyIEVudGl0eU9ic2VydmVyQ29uc3RydWN0b3IgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRFbnRpdHlPYnNlcnZlckNvbnN0cnVjdG9yKCkge1xyXG4gICAgcmV0dXJuIEVudGl0eU9ic2VydmVyQ29uc3RydWN0b3IgfHwgKEVudGl0eU9ic2VydmVyQ29uc3RydWN0b3IgPSByZXF1aXJlKFwiLi9lbnRpdHktb2JzZXJ2ZXJcIikuRW50aXR5T2JzZXJ2ZXIpO1xyXG59XHJcbmV4cG9ydHMuZ2V0RW50aXR5T2JzZXJ2ZXJDb25zdHJ1Y3RvciA9IGdldEVudGl0eU9ic2VydmVyQ29uc3RydWN0b3I7XHJcbi8qKlxyXG4gKiBHZXRzIG9yIGNyZWF0ZXMgYW4gYE9iamVjdE1ldGFPYnNlcnZlcmAgZm9yIHRoZSBnaXZlbiBtZXRhIG9iamVjdFxyXG4gKiBAcGFyYW0gbWV0YSBUaGUgb2JqZWN0IG1ldGEgYmVnaW4gb2JzZXJ2ZWRcclxuICogQHBhcmFtIGNyZWF0ZSBJZiB0cnVlLCBjcmVhdGUgdGhlIG9ic2VydmVyIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0T2JqZWN0TWV0YU9ic2VydmVyKG1ldGEsIGNyZWF0ZSkge1xyXG4gICAgaWYgKGNyZWF0ZSA9PT0gdm9pZCAwKSB7IGNyZWF0ZSA9IGZhbHNlOyB9XHJcbiAgICB2YXIgT2JqZWN0TWV0YU9ic2VydmVyID0gZ2V0T2JqZWN0TWV0YU9ic2VydmVyQ29uc3RydWN0b3IoKTtcclxuICAgIGlmICgoMCwgaGVscGVyc18xLmhhc093blByb3BlcnR5KShtZXRhLCBcIl9fb2JfX1wiKSAmJiAoMCwgaGVscGVyc18xLmdldFByb3ApKG1ldGEsIFwiX19vYl9fXCIpIGluc3RhbmNlb2YgT2JqZWN0TWV0YU9ic2VydmVyKSB7XHJcbiAgICAgICAgcmV0dXJuICgwLCBoZWxwZXJzXzEuZ2V0UHJvcCkobWV0YSwgXCJfX29iX19cIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjcmVhdGUpIHtcclxuICAgICAgICAvLyBNYXJrIHRoZSBvYmplY3QgbWV0YSBhcyBcInJhd1wiIHNvIHRoYXQgVnVlIHdvbid0IHRyeSB0byBtYWtlIGl0IG9ic2VydmFibGVcclxuICAgICAgICAoMCwgdnVlXzEubWFya1JhdykobWV0YSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RNZXRhT2JzZXJ2ZXIobWV0YSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldE9iamVjdE1ldGFPYnNlcnZlciA9IGdldE9iamVjdE1ldGFPYnNlcnZlcjtcclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxyXG52YXIgT2JqZWN0TWV0YU9ic2VydmVyQ29uc3RydWN0b3IgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRPYmplY3RNZXRhT2JzZXJ2ZXJDb25zdHJ1Y3RvcigpIHtcclxuICAgIHJldHVybiBPYmplY3RNZXRhT2JzZXJ2ZXJDb25zdHJ1Y3RvciB8fCAoT2JqZWN0TWV0YU9ic2VydmVyQ29uc3RydWN0b3IgPSByZXF1aXJlKFwiLi9vYmplY3QtbWV0YS1vYnNlcnZlclwiKS5PYmplY3RNZXRhT2JzZXJ2ZXIpO1xyXG59XHJcbmV4cG9ydHMuZ2V0T2JqZWN0TWV0YU9ic2VydmVyQ29uc3RydWN0b3IgPSBnZXRPYmplY3RNZXRhT2JzZXJ2ZXJDb25zdHJ1Y3RvcjtcclxuLyoqXHJcbiAqIEJhc2VkIG9uIFZ1ZSdzIGludGVybmFsIGBvYnNlcnZlKClgIGZ1bmN0aW9uLiBFbnN1cmVzIHRoYXQgdGhlIGdpdmVuIGFycmF5XHJcbiAqIGlzIG9ic2VydmFibGUgYW5kIG9wdGlvbmFsbHkgbm90ZXMgdGhhdCBpdCBpcyByZWZlcmVuY2VkIGJ5IGEgY29tcG9uZW50XHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gb2JzZXJ2ZVxyXG4gKiBAcGFyYW0gYXNSb290RGF0YSBUaGUgYXJyYXkgaXMgcmVmZXJlbmNlZCBhcyBhIGNvbXBvbmVudCdzIGRhdGFcclxuICovXHJcbmZ1bmN0aW9uIG9ic2VydmVBcnJheShhcnJheSwgYXNSb290RGF0YSkge1xyXG4gICAgaWYgKGFzUm9vdERhdGEgPT09IHZvaWQgMCkgeyBhc1Jvb3REYXRhID0gZmFsc2U7IH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xyXG4gICAgICAgIGlmIChtb2RlbF9qc18zLk9ic2VydmFibGVBcnJheS5pc09ic2VydmFibGVBcnJheShhcnJheSkpIHtcclxuICAgICAgICAgICAgdmFyIG9iID0gZ2V0QXJyYXlPYnNlcnZlcihhcnJheSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XHJcbiAgICAgICAgICAgICAgICBvYi52bUNvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9iO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogV2FybiBhYm91dCBhdHRlbXB0aW5nIHRvIG9ic2VydmUgbm9uLW9ic2VydmFibGUgYXJyYXk/XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gVE9ETzogV2FybiBhYm91dCBhdHRlbXB0aW5nIHRvIG9ic2VydmUgbm9uLWFycmF5P1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMub2JzZXJ2ZUFycmF5ID0gb2JzZXJ2ZUFycmF5O1xyXG4vKipcclxuICogR2V0cyBvciBjcmVhdGVzIGFuIGBBcnJheU9ic2VydmVyYCBmb3IgdGhlIGdpdmVuIG9ic2VydmFibGUgYXJyYXlcclxuICogQHBhcmFtIGVudGl0eSBUaGUgZW50aXR5IGJlZ2luIG9ic2VydmVkXHJcbiAqIEBwYXJhbSBjcmVhdGUgSWYgdHJ1ZSwgY3JlYXRlIHRoZSBvYnNlcnZlciBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3RcclxuICovXHJcbmZ1bmN0aW9uIGdldEFycmF5T2JzZXJ2ZXIoYXJyYXksIGNyZWF0ZSkge1xyXG4gICAgaWYgKGNyZWF0ZSA9PT0gdm9pZCAwKSB7IGNyZWF0ZSA9IGZhbHNlOyB9XHJcbiAgICB2YXIgQXJyYXlPYnNlcnZlciA9IGdldEFycmF5T2JzZXJ2ZXJDb25zdHJ1Y3RvcigpO1xyXG4gICAgaWYgKCgwLCBoZWxwZXJzXzEuaGFzT3duUHJvcGVydHkpKGFycmF5LCBcIl9fb2JfX1wiKSAmJiAoMCwgaGVscGVyc18xLmdldFByb3ApKGFycmF5LCBcIl9fb2JfX1wiKSBpbnN0YW5jZW9mIEFycmF5T2JzZXJ2ZXIpIHtcclxuICAgICAgICByZXR1cm4gKDAsIGhlbHBlcnNfMS5nZXRQcm9wKShhcnJheSwgXCJfX29iX19cIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjcmVhdGUpIHtcclxuICAgICAgICAvLyBNYXJrIHRoZSBhcnJheSBhcyBcInJhd1wiIHNvIHRoYXQgVnVlIHdvbid0IHRyeSB0byBtYWtlIGl0IG9ic2VydmFibGVcclxuICAgICAgICAoMCwgdnVlXzEubWFya1JhdykoYXJyYXkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZlcihhcnJheSwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldEFycmF5T2JzZXJ2ZXIgPSBnZXRBcnJheU9ic2VydmVyO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXHJcbnZhciBBcnJheU9ic2VydmVyQ29uc3RydWN0b3IgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRBcnJheU9ic2VydmVyQ29uc3RydWN0b3IoKSB7XHJcbiAgICByZXR1cm4gQXJyYXlPYnNlcnZlckNvbnN0cnVjdG9yIHx8IChBcnJheU9ic2VydmVyQ29uc3RydWN0b3IgPSByZXF1aXJlKFwiLi9hcnJheS1vYnNlcnZlclwiKS5BcnJheU9ic2VydmVyKTtcclxufVxyXG5leHBvcnRzLmdldEFycmF5T2JzZXJ2ZXJDb25zdHJ1Y3RvciA9IGdldEFycmF5T2JzZXJ2ZXJDb25zdHJ1Y3RvcjtcclxuLyoqXHJcbiAqIEJhc2VkIG9uIFZ1ZSdzIGludGVybmFscyBgZGVwZW5kQXJyYXkoKWAgZnVuY3Rpb25cclxuICogQHBhcmFtIGFycmF5IFRoZSBjaGlsZCBhcnJheSB0byB0cmFjayBhcyBhIGRlcGVuZGVuY3lcclxuICovXHJcbmZ1bmN0aW9uIGRlcGVuZENoaWxkQXJyYXkoYXJyYXkpIHtcclxuICAgIHZhciBhcnJheU9ic2VydmVyID0gb2JzZXJ2ZUFycmF5KGFycmF5KTtcclxuICAgIGlmIChhcnJheU9ic2VydmVyKVxyXG4gICAgICAgIGFycmF5T2JzZXJ2ZXIuZW5zdXJlT2JzZXJ2YWJsZSgpO1xyXG4gICAgZm9yICh2YXIgZSwgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBlID0gYXJyYXlbaV07XHJcbiAgICAgICAgaWYgKGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIG1vZGVsX2pzXzIuRW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBnZXRFbnRpdHlPYnNlcnZlcihlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmVuc3VyZU9ic2VydmFibGUoKTtcclxuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRlcC5kZXBlbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgaGVscGVyc18xLmhhc093blByb3BlcnR5KShlLCBcIl9fb2JfX1wiKSkge1xyXG4gICAgICAgICAgICAgICAgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XHJcbiAgICAgICAgICAgICAgICBkZXBlbmRDaGlsZEFycmF5KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuZGVwZW5kQ2hpbGRBcnJheSA9IGRlcGVuZENoaWxkQXJyYXk7XHJcbnZhciB2dWVDb21wYXRpYmxlTW9kZWxzID0gW107XHJcbi8qKlxyXG4gKiBNYWtlIHN1cmUgdGhhdCBlbnRpdGllcyBpbiB0aGUgZ2l2ZW4gbW9kZWwgYXJlIG9ic2VydmFibGUgYnkgVnVlXHJcbiAqIEJ5IGRlZmF1bHQsIGVudGl0aWVzIHdvdWxkIG5vdCBiZSBvYnNlcnZhYmxlLCBzaW5jZSBtb2RlbCBwcm9wZXJ0aWVzXHJcbiAqIGFyZSBhZGRlZCB0byB0aGUgcHJvdG90eXBlLCBWdWUgd2lsbCBub3QgZGV0ZWN0IHRoZW0uIFNvLCB3ZSB1c2UgYSBjdXN0b21cclxuICogb2JzZXJ2ZXIgdGhhdCBsZXZlcmFnZXMgbW9kZWwgbWV0YWRhdGEgdG8gbWFuYWdlIHByb3BlcnR5IGFjY2Vzcy9jaGFuZ2UuXHJcbiAqIEBwYXJhbSBtb2RlbCBUaGUgbW9kZWwgdG8gYXVnbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gbWFrZUVudGl0aWVzVnVlT2JzZXJ2YWJsZShtb2RlbCkge1xyXG4gICAgaWYgKCFtb2RlbCB8fCAhKG1vZGVsIGluc3RhbmNlb2YgbW9kZWxfanNfMS5Nb2RlbCkpIHtcclxuICAgICAgICAvLyBUT0RPOiBXYXJuIGFib3V0IG1pc3Npbmcgb3Igbm9uLU1vZGVsIGFyZ3VtZW50P1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2dWVDb21wYXRpYmxlTW9kZWxzLmluZGV4T2YobW9kZWwpID49IDAgfHwgbW9kZWwuX2VudGl0aWVzQXJlVnVlT2JzZXJ2YWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIG1vZGVsLmVudGl0eVJlZ2lzdGVyZWQuc3Vic2NyaWJlKGZ1bmN0aW9uIChhcmdzKSB7XHJcbiAgICAgICAgb2JzZXJ2ZUVudGl0eShhcmdzLmVudGl0eSkuZW5zdXJlT2JzZXJ2YWJsZSgpO1xyXG4gICAgfSk7XHJcbiAgICAvLyBNYWtlIGV4aXN0aW5nIGVudGl0aWVzIG9ic2VydmFibGVcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhtb2RlbC50eXBlcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIHR5cGVOYW1lID0gX2FbX2ldO1xyXG4gICAgICAgIHZhciB0eXBlID0gbW9kZWwudHlwZXNbdHlwZU5hbWVdO1xyXG4gICAgICAgIHR5cGUua25vd24oKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRpdHkpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZUVudGl0eShlbnRpdHkpLmVuc3VyZU9ic2VydmFibGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHZ1ZUNvbXBhdGlibGVNb2RlbHMucHVzaChtb2RlbCk7XHJcbiAgICBtb2RlbC5fZW50aXRpZXNBcmVWdWVPYnNlcnZhYmxlID0gdHJ1ZTtcclxufVxyXG5leHBvcnRzLm1ha2VFbnRpdGllc1Z1ZU9ic2VydmFibGUgPSBtYWtlRW50aXRpZXNWdWVPYnNlcnZhYmxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5jcmVhdGVWdWVNb2RlbCA9IGV4cG9ydHMuVnVlTW9kZWwgPSB2b2lkIDA7XHJcbnZhciBtb2RlbF9qc18xID0gcmVxdWlyZShcIkBjb2duaXRvZm9ybXMvbW9kZWwuanNcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgaW1wb3J0L25vLWR1cGxpY2F0ZXNcclxudmFyIG1vZGVsX2pzXzIgPSByZXF1aXJlKFwiQGNvZ25pdG9mb3Jtcy9tb2RlbC5qc1wiKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBpbXBvcnQvbm8tZHVwbGljYXRlc1xyXG52YXIgdnVlX2ludGVybmFsc18xID0gcmVxdWlyZShcIi4vdnVlLWludGVybmFsc1wiKTtcclxudmFyIHZ1ZV9nbG9iYWxfbWl4aW5fMSA9IHJlcXVpcmUoXCIuL3Z1ZS1nbG9iYWwtbWl4aW5cIik7XHJcbnZhciBzb3VyY2VfcGF0aF9taXhpbl8xID0gcmVxdWlyZShcIi4vc291cmNlLXBhdGgtbWl4aW5cIik7XHJcbnZhciBzb3VyY2Vfcm9vdF9taXhpbl8xID0gcmVxdWlyZShcIi4vc291cmNlLXJvb3QtbWl4aW5cIik7XHJcbnZhciB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xID0gcmVxdWlyZShcIi4vdnVlLW1vZGVsLW9ic2VydmFiaWxpdHlcIik7XHJcbnZhciB2bV9yb290X2NvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vdm0tcm9vdC1jb21wb25lbnRcIik7XHJcbnZhciB2bV9zb3VyY2VfY29tcG9uZW50XzEgPSByZXF1aXJlKFwiLi92bS1zb3VyY2UtY29tcG9uZW50XCIpO1xyXG52YXIgbW9kZWxfanNfMyA9IHJlcXVpcmUoXCJAY29nbml0b2Zvcm1zL21vZGVsLmpzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1kdXBsaWNhdGVzXHJcbi8vIFRPRE86IERvIHdlIG5lZWQgdG8gdGFrZSBgdG9nZ2xlT2JzZXJ2aW5nKClgIGludG8gYWNjb3VudD9cclxudmFyIFZ1ZU1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFZ1ZU1vZGVsLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1vZGVsIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlIGluZm9ybWF0aW9uLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIHNldCBvZiBtb2RlbCB0eXBlcyB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFZ1ZU1vZGVsKG9wdGlvbnMsIGNvbmZpZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGNvbmZpZykgfHwgdGhpcztcclxuICAgICAgICBpZiAoIVZ1ZU1vZGVsLl9WdWUpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogYXV0by1pbnN0YWxsIGlmIG5lZWRlZD9cclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVnVlLnVzZShWdWVNb2RlbCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGNvbnN0cnVjdGluZyBhIFZ1ZU1vZGVsIGluc3RhbmNlLlwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIG1vZGVsIGl0c2VsZiBpcyBub3QgbWFkZSBvYnNlcnZhYmxlIGJ5IFZ1ZSwgc2luY2UgYW55dGhpbmcgdGhhdCB3ZSB3YW50IHRvIGJlIG1hZGUgb2JzZXJ2YWJsZSBzaG91bGQgYmUgbWFkZSBvYnNlcnZhYmxlIGV4cGxpY2l0bHlcclxuICAgICAgICAoMCwgdnVlX21vZGVsX29ic2VydmFiaWxpdHlfMS5wcmV2ZW50VnVlT2JzZXJ2YWJpbGl0eSkoX3RoaXMpO1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGVudGl0aWVzIGFyZSBvYnNlcnZhYmxlIGJ5IFZ1ZVxyXG4gICAgICAgICgwLCB2dWVfbW9kZWxfb2JzZXJ2YWJpbGl0eV8xLm1ha2VFbnRpdGllc1Z1ZU9ic2VydmFibGUpKF90aGlzKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEltcGxlbWVudCB0aGUgVnVlIHBsdWdpbiBpbnRlcmZhY2U6XHJcbiAgICAgKiBodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9wbHVnaW5zLmh0bWwjV3JpdGluZy1hLVBsdWdpblxyXG4gICAgICovXHJcbiAgICBWdWVNb2RlbC5pbnN0YWxsID0gZnVuY3Rpb24gKHZ1ZSkge1xyXG4gICAgICAgIC8vIERldGVjdCBpZiB0aGUgcGx1Z2luIGluc3RhbGwgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcclxuICAgICAgICBpZiAoVnVlTW9kZWwuX1Z1ZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIFJlZ2lzdGVyIGNvbXBvbmVudHMgZ2xvYmFsbHkgZm9yIHVzZSBpbiB0ZW1wbGF0ZXNcclxuICAgICAgICB2dWUuY29tcG9uZW50KFwidm0tcm9vdFwiLCB2bV9yb290X2NvbXBvbmVudF8xLlZNUm9vdCk7XHJcbiAgICAgICAgdnVlLmNvbXBvbmVudChcInZtLXNvdXJjZVwiLCB2bV9zb3VyY2VfY29tcG9uZW50XzEuVk1Tb3VyY2UpO1xyXG4gICAgICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBWdWUgY29uc3RydWN0b3IvbW9kdWxlXHJcbiAgICAgICAgVnVlTW9kZWwuX1Z1ZSA9IHZ1ZTtcclxuICAgICAgICAvLyBHZXQgYWNjZXNzIHRvIFZ1ZSdzIGludGVybmFsIHR5cGVzIHRoYXQgd2UgbmVlZFxyXG4gICAgICAgICgwLCB2dWVfaW50ZXJuYWxzXzEuZW5zdXJlVnVlSW50ZXJuYWxUeXBlcykoVnVlTW9kZWwuX1Z1ZUludGVybmFscywgVnVlTW9kZWwuX1Z1ZSk7XHJcbiAgICAgICAgLy8gSW5zdGFsbCB0aGUgVnVlIGdsb2JhbCBtaXhpblxyXG4gICAgICAgIHJldHVybiAoMCwgdnVlX2dsb2JhbF9taXhpbl8xLlZ1ZU1vZGVsJGluc3RhbGxHbG9iYWxNaXhpbikodnVlKTtcclxuICAgIH07XHJcbiAgICBWdWVNb2RlbC5fVnVlID0gbnVsbDtcclxuICAgIFZ1ZU1vZGVsLl9WdWVJbnRlcm5hbHMgPSB7IE9ic2VydmVyOiBudWxsLCBEZXA6IG51bGwgfTtcclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZSBhY2Nlc3MgdG8gVnVlIG1peGlucyBmb3Igc291cmNlIHByb3ZpZGVyL2NvbnN1bWVyXHJcbiAgICAgKi9cclxuICAgIFZ1ZU1vZGVsLm1peGlucyA9IHtcclxuICAgICAgICBTb3VyY2VQYXRoOiBzb3VyY2VfcGF0aF9taXhpbl8xLlNvdXJjZVBhdGhNaXhpbixcclxuICAgICAgICBTb3VyY2VSb290OiBzb3VyY2Vfcm9vdF9taXhpbl8xLlNvdXJjZVJvb3RNaXhpblxyXG4gICAgfTtcclxuICAgIFZ1ZU1vZGVsLkVudGl0eSA9IG1vZGVsX2pzXzIuRW50aXR5O1xyXG4gICAgVnVlTW9kZWwuQ3VsdHVyZUluZm8gPSBtb2RlbF9qc18zLkN1bHR1cmVJbmZvO1xyXG4gICAgcmV0dXJuIFZ1ZU1vZGVsO1xyXG59KG1vZGVsX2pzXzEuTW9kZWwpKTtcclxuZXhwb3J0cy5WdWVNb2RlbCA9IFZ1ZU1vZGVsO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXHJcbmZ1bmN0aW9uIGNyZWF0ZVZ1ZU1vZGVsKG9wdGlvbnMsIGNvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsID0gbmV3IFZ1ZU1vZGVsKG9wdGlvbnMsIGNvbmZpZyk7XHJcbiAgICAgICAgbW9kZWwucmVhZHkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXNvbHZlKG1vZGVsKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlVnVlTW9kZWwgPSBjcmVhdGVWdWVNb2RlbDtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==